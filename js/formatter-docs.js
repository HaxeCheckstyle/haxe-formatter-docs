// Generated by Haxe 4.1.2
(function ($global) { "use strict";
var $hxClasses = {},$estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
class EReg {
	constructor(r,opt) {
		this.r = new RegExp(r,opt.split("u").join(""));
	}
	match(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	matched(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw haxe_Exception.thrown("EReg::matched");
		}
	}
	matchedPos() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		return { pos : this.r.m.index, len : this.r.m[0].length};
	}
	matchSub(s,pos,len) {
		if(len == null) {
			len = -1;
		}
		if(this.r.global) {
			this.r.lastIndex = pos;
			this.r.m = this.r.exec(len < 0 ? s : HxOverrides.substr(s,0,pos + len));
			let b = this.r.m != null;
			if(b) {
				this.r.s = s;
			}
			return b;
		} else {
			let b = this.match(len < 0 ? HxOverrides.substr(s,pos,null) : HxOverrides.substr(s,pos,len));
			if(b) {
				this.r.s = s;
				this.r.m.index += pos;
			}
			return b;
		}
	}
	map(s,f) {
		let offset = 0;
		let buf_b = "";
		while(true) {
			if(offset >= s.length) {
				break;
			} else if(!this.matchSub(s,offset)) {
				buf_b += Std.string(HxOverrides.substr(s,offset,null));
				break;
			}
			let p = this.matchedPos();
			buf_b += Std.string(HxOverrides.substr(s,offset,p.pos - offset));
			buf_b += Std.string(f(this));
			if(p.len == 0) {
				buf_b += Std.string(HxOverrides.substr(s,p.pos,1));
				offset = p.pos + 1;
			} else {
				offset = p.pos + p.len;
			}
			if(!this.r.global) {
				break;
			}
		}
		if(!this.r.global && offset > 0 && offset < s.length) {
			buf_b += Std.string(HxOverrides.substr(s,offset,null));
		}
		return buf_b;
	}
}
$hxClasses["EReg"] = EReg;
EReg.__name__ = "EReg";
Object.assign(EReg.prototype, {
	__class__: EReg
	,r: null
});
class HxOverrides {
	static cca(s,index) {
		let x = s.charCodeAt(index);
		if(x != x) {
			return undefined;
		}
		return x;
	}
	static substr(s,pos,len) {
		if(len == null) {
			len = s.length;
		} else if(len < 0) {
			if(pos == 0) {
				len = s.length + len;
			} else {
				return "";
			}
		}
		return s.substr(pos,len);
	}
	static remove(a,obj) {
		let i = a.indexOf(obj);
		if(i == -1) {
			return false;
		}
		a.splice(i,1);
		return true;
	}
	static now() {
		return Date.now();
	}
}
$hxClasses["HxOverrides"] = HxOverrides;
HxOverrides.__name__ = "HxOverrides";
class json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		this.errors = errors;
		this.putils = putils;
		this.errorType = errorType;
	}
	fromJson(jsonString,filename) {
		if(filename == null) {
			filename = "";
		}
		this.putils = new json2object_PositionUtils(jsonString);
		this.errors = [];
		try {
			let json = new hxjsonast_Parser(jsonString,filename).parseRec();
			this.loadJson(json);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			let _g1 = haxe_Exception.caught(_g).unwrap();
			if(((_g1) instanceof hxjsonast_Error)) {
				let e = _g1;
				this.errors.push(json2object_Error.ParserError(e.message,this.putils.convertPosition(e.pos)));
			} else {
				throw _g;
			}
		}
		return this.value;
	}
	loadJson(json,variable) {
		if(variable == null) {
			variable = "";
		}
		let pos = this.putils.convertPosition(json.pos);
		let _g = json.value;
		switch(_g._hx_index) {
		case 0:
			let s = _g.s;
			this.loadJsonString(s,pos,variable);
			break;
		case 1:
			let n = _g.s;
			this.loadJsonNumber(n,pos,variable);
			break;
		case 2:
			let o = _g.fields;
			this.loadJsonObject(o,pos,variable);
			break;
		case 3:
			let a = _g.values;
			this.loadJsonArray(a,pos,variable);
			break;
		case 4:
			let b = _g.b;
			this.loadJsonBool(b,pos,variable);
			break;
		case 5:
			this.loadJsonNull(pos,variable);
			break;
		}
		return this.value;
	}
	loadJsonNull(pos,variable) {
		this.onIncorrectType(pos,variable);
	}
	loadJsonString(s,pos,variable) {
		this.onIncorrectType(pos,variable);
	}
	loadString(s,pos,variable,validValues,defaultValue) {
		if(validValues.indexOf(s) != -1) {
			return s;
		}
		this.onIncorrectType(pos,variable);
		return defaultValue;
	}
	loadJsonNumber(f,pos,variable) {
		this.onIncorrectType(pos,variable);
	}
	loadJsonInt(f,pos,variable,value) {
		if(Std.parseInt(f) != null && Std.parseInt(f) == parseFloat(f)) {
			return Std.parseInt(f);
		}
		this.onIncorrectType(pos,variable);
		return value;
	}
	loadJsonBool(b,pos,variable) {
		this.onIncorrectType(pos,variable);
	}
	loadJsonArray(a,pos,variable) {
		this.onIncorrectType(pos,variable);
	}
	loadJsonArrayValue(a,loadJsonFn,variable) {
		let _g = [];
		let _g1 = 0;
		while(_g1 < a.length) {
			let j = a[_g1];
			++_g1;
			let tmp;
			try {
				tmp = loadJsonFn(j,variable);
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				if(typeof(haxe_Exception.caught(_g).unwrap()) == "string") {
					continue;
				} else {
					throw _g;
				}
			}
			_g.push(tmp);
		}
		return _g;
	}
	loadJsonObject(o,pos,variable) {
		this.onIncorrectType(pos,variable);
	}
	loadObjectField(loadJsonFn,field,name,assigned,defaultValue) {
		try {
			let ret = loadJsonFn(field.value,field.name);
			this.mapSet(assigned,name,true);
			return ret;
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
		}
		return defaultValue;
	}
	objectSetupAssign(assigned,keys,values) {
		let _g = 0;
		let _g1 = keys.length;
		while(_g < _g1) {
			let i = _g++;
			this.mapSet(assigned,keys[i],values[i]);
		}
	}
	objectErrors(assigned,pos) {
		let lastPos = this.putils.convertPosition(new hxjsonast_Position(pos.file,pos.max - 1,pos.max - 1));
		let s = haxe_ds_StringMap.keysIterator(assigned.h);
		while(s.hasNext()) {
			let s1 = s.next();
			if(!assigned.h[s1]) {
				this.errors.push(json2object_Error.UninitializedVariable(s1,lastPos));
			}
		}
	}
	onIncorrectType(pos,variable) {
		this.parsingThrow();
	}
	parsingThrow() {
		if(this.errorType != 0) {
			throw haxe_Exception.thrown("json2object: parsing throw");
		}
	}
	objectThrow(pos,variable) {
		if(this.errorType == 2) {
			throw haxe_Exception.thrown("json2object: parsing throw");
		} else if(this.errorType == 1) {
			this.errors.push(json2object_Error.UninitializedVariable(variable,pos));
		}
	}
	mapSet(map,key,value) {
		map.h[key] = value;
	}
}
$hxClasses["json2object.reader.BaseParser"] = json2object_reader_BaseParser;
json2object_reader_BaseParser.__name__ = "json2object.reader.BaseParser";
Object.assign(json2object_reader_BaseParser.prototype, {
	__class__: json2object_reader_BaseParser
	,value: null
	,errors: null
	,errorType: null
	,putils: null
});
class JsonParser_$1 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?wrapping : Null<formatter.config.WrapConfig>, ?whitespace : Null<formatter.config.WhitespaceConfig>, ?sameLine : Null<formatter.config.SameLineConfig>, ?lineEnds : Null<formatter.config.LineEndConfig>, ?indentation : Null<formatter.config.IndentationConfig>, ?excludes : Null<Array<String>>, ?emptyLines : Null<formatter.config.EmptyLinesConfig>, ?disableFormatting : Null<Bool> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["disableFormatting","emptyLines","excludes","indentation","lineEnds","sameLine","whitespace","wrapping"],[true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "disableFormatting":
				this.value.disableFormatting = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"disableFormatting",assigned,this.value.disableFormatting);
				break;
			case "emptyLines":
				this.value.emptyLines = this.loadObjectField(($_=new JsonParser_$4(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"emptyLines",assigned,this.value.emptyLines);
				break;
			case "excludes":
				this.value.excludes = this.loadObjectField(($_=new JsonParser_$66(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"excludes",assigned,this.value.excludes);
				break;
			case "indentation":
				this.value.indentation = this.loadObjectField(($_=new JsonParser_$33(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"indentation",assigned,this.value.indentation);
				break;
			case "lineEnds":
				this.value.lineEnds = this.loadObjectField(($_=new JsonParser_$36(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"lineEnds",assigned,this.value.lineEnds);
				break;
			case "sameLine":
				this.value.sameLine = this.loadObjectField(($_=new JsonParser_$39(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"sameLine",assigned,this.value.sameLine);
				break;
			case "whitespace":
				this.value.whitespace = this.loadObjectField(($_=new JsonParser_$42(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"whitespace",assigned,this.value.whitespace);
				break;
			case "wrapping":
				this.value.wrapping = this.loadObjectField(($_=new JsonParser_$60(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"wrapping",assigned,this.value.wrapping);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { disableFormatting : false, emptyLines : new JsonParser_$4([],this.putils,0).getAuto(), excludes : ["\\.haxelib","\\.git","node_modules"], indentation : new JsonParser_$33([],this.putils,0).getAuto(), lineEnds : new JsonParser_$36([],this.putils,0).getAuto(), sameLine : new JsonParser_$39([],this.putils,0).getAuto(), whitespace : new JsonParser_$42([],this.putils,0).getAuto(), wrapping : new JsonParser_$60([],this.putils,0).getAuto()};
	}
}
$hxClasses["JsonParser_1"] = JsonParser_$1;
JsonParser_$1.__name__ = "JsonParser_1";
JsonParser_$1.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$1.prototype, {
	__class__: JsonParser_$1
});
class JsonParser_$112 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "beforeLast";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.WrappingLocation",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["beforeLast","afterLast"],"beforeLast");
	}
}
$hxClasses["JsonParser_112"] = JsonParser_$112;
JsonParser_$112.__name__ = "JsonParser_112";
JsonParser_$112.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$112.prototype, {
	__class__: JsonParser_$112
});
class JsonParser_$114 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "onePerLine";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.WrappingType",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["onePerLine","onePerLineAfterFirst","equalNumber","fillLine","fillLineWithLeadingBreak","noWrap","keep"],"onePerLine");
	}
}
$hxClasses["JsonParser_114"] = JsonParser_$114;
JsonParser_$114.__name__ = "JsonParser_114";
JsonParser_$114.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$114.prototype, {
	__class__: JsonParser_$114
});
class JsonParser_$116 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"Array<formatter.config.WrapRule>",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonArray(a,pos,variable) {
		this.value = this.loadJsonArrayValue(a,($_=new JsonParser_$118(this.errors,this.putils,2),$bind($_,$_.loadJson)),variable);
	}
}
$hxClasses["JsonParser_116"] = JsonParser_$116;
JsonParser_$116.__name__ = "JsonParser_116";
JsonParser_$116.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$116.prototype, {
	__class__: JsonParser_$116
});
class JsonParser_$118 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ type : formatter.config.WrappingType, ?location : Null<formatter.config.WrappingLocation>, conditions : Array<formatter.config.WrapCondition>, ?additionalIndent : Null<Int> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["additionalIndent","conditions","location","type"],[true,false,true,false]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "additionalIndent":
				this.value.additionalIndent = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"additionalIndent",assigned,this.value.additionalIndent);
				break;
			case "conditions":
				this.value.conditions = this.loadObjectField(($_=new JsonParser_$119(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"conditions",assigned,this.value.conditions);
				break;
			case "location":
				this.value.location = this.loadObjectField(($_=new JsonParser_$112(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"location",assigned,this.value.location);
				break;
			case "type":
				this.value.type = this.loadObjectField(($_=new JsonParser_$120(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"type",assigned,this.value.type);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { additionalIndent : 0, conditions : new JsonParser_$119([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1))), location : "afterLast", type : new JsonParser_$120([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)))};
	}
}
$hxClasses["JsonParser_118"] = JsonParser_$118;
JsonParser_$118.__name__ = "JsonParser_118";
JsonParser_$118.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$118.prototype, {
	__class__: JsonParser_$118
});
class JsonParser_$119 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"Array<formatter.config.WrapCondition>",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonArray(a,pos,variable) {
		this.value = this.loadJsonArrayValue(a,($_=new JsonParser_$122(this.errors,this.putils,2),$bind($_,$_.loadJson)),variable);
	}
}
$hxClasses["JsonParser_119"] = JsonParser_$119;
JsonParser_$119.__name__ = "JsonParser_119";
JsonParser_$119.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$119.prototype, {
	__class__: JsonParser_$119
});
class JsonParser_$12 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?beforeError : Null<Int>, ?beforeEnd : Null<Int>, ?beforeElse : Null<Int>, ?afterIf : Null<Int>, ?afterError : Null<Int>, ?afterElse : Null<Int> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["afterElse","afterError","afterIf","beforeElse","beforeEnd","beforeError"],[true,true,true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "afterElse":
				this.value.afterElse = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterElse",assigned,this.value.afterElse);
				break;
			case "afterError":
				this.value.afterError = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterError",assigned,this.value.afterError);
				break;
			case "afterIf":
				this.value.afterIf = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterIf",assigned,this.value.afterIf);
				break;
			case "beforeElse":
				this.value.beforeElse = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeElse",assigned,this.value.beforeElse);
				break;
			case "beforeEnd":
				this.value.beforeEnd = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeEnd",assigned,this.value.beforeEnd);
				break;
			case "beforeError":
				this.value.beforeError = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeError",assigned,this.value.beforeError);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { afterElse : 0, afterError : 0, afterIf : 0, beforeElse : 0, beforeEnd : 0, beforeError : 0};
	}
}
$hxClasses["JsonParser_12"] = JsonParser_$12;
JsonParser_$12.__name__ = "JsonParser_12";
JsonParser_$12.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$12.prototype, {
	__class__: JsonParser_$12
});
class JsonParser_$120 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "onePerLine";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.WrappingType",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["onePerLine","onePerLineAfterFirst","equalNumber","fillLine","fillLineWithLeadingBreak","noWrap","keep"],"onePerLine");
	}
}
$hxClasses["JsonParser_120"] = JsonParser_$120;
JsonParser_$120.__name__ = "JsonParser_120";
JsonParser_$120.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$120.prototype, {
	__class__: JsonParser_$120
});
class JsonParser_$122 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?value : Null<Int>, cond : formatter.config.WrapConditionType }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["cond","value"],[false,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "cond":
				this.value.cond = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"cond",assigned,this.value.cond);
				break;
			case "value":
				this.value.value = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"value",assigned,this.value.value);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { cond : new JsonParser_$123([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1))), value : 1};
	}
}
$hxClasses["JsonParser_122"] = JsonParser_$122;
JsonParser_$122.__name__ = "JsonParser_122";
JsonParser_$122.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$122.prototype, {
	__class__: JsonParser_$122
});
class JsonParser_$123 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "itemCount >= n";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.WrapConditionType",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["itemCount >= n","itemCount <= n","anyItemLength >= n","anyItemLength <= n","totalItemLength >= n","totalItemLength <= n","lineLength >= n","lineLength <= n","hasMultilineItems","exceedsMaxLineLength"],"itemCount >= n");
	}
}
$hxClasses["JsonParser_123"] = JsonParser_$123;
JsonParser_$123.__name__ = "JsonParser_123";
JsonParser_$123.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$123.prototype, {
	__class__: JsonParser_$123
});
class JsonParser_$125 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "none";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.WhitespacePolicy",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["none","before","noneBefore","onlyBefore","after","onlyAfter","noneAfter","around"],"none");
	}
}
$hxClasses["JsonParser_125"] = JsonParser_$125;
JsonParser_$125.__name__ = "JsonParser_125";
JsonParser_$125.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$125.prototype, {
	__class__: JsonParser_$125
});
class JsonParser_$15 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?existingBetweenFields : Null<formatter.config.KeepEmptyLinesPolicy>, ?endType : Null<Int>, ?betweenVars : Null<Int>, ?betweenFunctions : Null<Int>, ?beginType : Null<Int>, ?afterVars : Null<Int> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["afterVars","beginType","betweenFunctions","betweenVars","endType","existingBetweenFields"],[true,true,true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "afterVars":
				this.value.afterVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterVars",assigned,this.value.afterVars);
				break;
			case "beginType":
				this.value.beginType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beginType",assigned,this.value.beginType);
				break;
			case "betweenFunctions":
				this.value.betweenFunctions = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenFunctions",assigned,this.value.betweenFunctions);
				break;
			case "betweenVars":
				this.value.betweenVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenVars",assigned,this.value.betweenVars);
				break;
			case "endType":
				this.value.endType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"endType",assigned,this.value.endType);
				break;
			case "existingBetweenFields":
				this.value.existingBetweenFields = this.loadObjectField(($_=new JsonParser_$196(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"existingBetweenFields",assigned,this.value.existingBetweenFields);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { afterVars : 1, beginType : 0, betweenFunctions : 1, betweenVars : 0, endType : 0, existingBetweenFields : "keep"};
	}
}
$hxClasses["JsonParser_15"] = JsonParser_$15;
JsonParser_$15.__name__ = "JsonParser_15";
JsonParser_$15.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$15.prototype, {
	__class__: JsonParser_$15
});
class JsonParser_$165 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "same";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.SameLinePolicy",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["same","next","keep"],"same");
	}
}
$hxClasses["JsonParser_165"] = JsonParser_$165;
JsonParser_$165.__name__ = "JsonParser_165";
JsonParser_$165.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$165.prototype, {
	__class__: JsonParser_$165
});
class JsonParser_$168 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?rightCurly : Null<formatter.config.RightCurlyLineEndPolicy>, ?leftCurly : Null<formatter.config.LeftCurlyLineEndPolicy>, ?emptyCurly : Null<formatter.config.EmptyCurlyPolicy> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["emptyCurly","leftCurly","rightCurly"],[true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "emptyCurly":
				this.value.emptyCurly = this.loadObjectField(($_=new JsonParser_$176(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"emptyCurly",assigned,this.value.emptyCurly);
				break;
			case "leftCurly":
				this.value.leftCurly = this.loadObjectField(($_=new JsonParser_$178(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"leftCurly",assigned,this.value.leftCurly);
				break;
			case "rightCurly":
				this.value.rightCurly = this.loadObjectField(($_=new JsonParser_$184(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"rightCurly",assigned,this.value.rightCurly);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { emptyCurly : "noBreak", leftCurly : "after", rightCurly : "both"};
	}
}
$hxClasses["JsonParser_168"] = JsonParser_$168;
JsonParser_$168.__name__ = "JsonParser_168";
JsonParser_$168.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$168.prototype, {
	__class__: JsonParser_$168
});
class JsonParser_$174 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "none";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.CaseColonLineEndPolicy",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["none","after"],"none");
	}
}
$hxClasses["JsonParser_174"] = JsonParser_$174;
JsonParser_$174.__name__ = "JsonParser_174";
JsonParser_$174.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$174.prototype, {
	__class__: JsonParser_$174
});
class JsonParser_$176 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "noBreak";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.EmptyCurlyPolicy",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["noBreak","break"],"noBreak");
	}
}
$hxClasses["JsonParser_176"] = JsonParser_$176;
JsonParser_$176.__name__ = "JsonParser_176";
JsonParser_$176.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$176.prototype, {
	__class__: JsonParser_$176
});
class JsonParser_$178 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "none";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.LeftCurlyLineEndPolicy",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["none","after","before","both"],"none");
	}
}
$hxClasses["JsonParser_178"] = JsonParser_$178;
JsonParser_$178.__name__ = "JsonParser_178";
JsonParser_$178.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$178.prototype, {
	__class__: JsonParser_$178
});
class JsonParser_$18 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?existingBetweenFields : Null<formatter.config.KeepEmptyLinesPolicy>, ?endType : Null<Int>, ?betweenFields : Null<Int>, ?beginType : Null<Int> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["beginType","betweenFields","endType","existingBetweenFields"],[true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "beginType":
				this.value.beginType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beginType",assigned,this.value.beginType);
				break;
			case "betweenFields":
				this.value.betweenFields = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenFields",assigned,this.value.betweenFields);
				break;
			case "endType":
				this.value.endType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"endType",assigned,this.value.endType);
				break;
			case "existingBetweenFields":
				this.value.existingBetweenFields = this.loadObjectField(($_=new JsonParser_$196(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"existingBetweenFields",assigned,this.value.existingBetweenFields);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { beginType : 0, betweenFields : 0, endType : 0, existingBetweenFields : "keep"};
	}
}
$hxClasses["JsonParser_18"] = JsonParser_$18;
JsonParser_$18.__name__ = "JsonParser_18";
JsonParser_$18.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$18.prototype, {
	__class__: JsonParser_$18
});
class JsonParser_$180 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "none";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.AtLineEndPolicy",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["none","after","afterLast","forceAfterLast"],"none");
	}
}
$hxClasses["JsonParser_180"] = JsonParser_$180;
JsonParser_$180.__name__ = "JsonParser_180";
JsonParser_$180.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$180.prototype, {
	__class__: JsonParser_$180
});
class JsonParser_$184 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "none";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.RightCurlyLineEndPolicy",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["none","before","after","both"],"none");
	}
}
$hxClasses["JsonParser_184"] = JsonParser_$184;
JsonParser_$184.__name__ = "JsonParser_184";
JsonParser_$184.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$184.prototype, {
	__class__: JsonParser_$184
});
class JsonParser_$186 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "none";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.SharpLineEndPolicy",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["none","after"],"none");
	}
}
$hxClasses["JsonParser_186"] = JsonParser_$186;
JsonParser_$186.__name__ = "JsonParser_186";
JsonParser_$186.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$186.prototype, {
	__class__: JsonParser_$186
});
class JsonParser_$190 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"String",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = s;
	}
}
$hxClasses["JsonParser_190"] = JsonParser_$190;
JsonParser_$190.__name__ = "JsonParser_190";
JsonParser_$190.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$190.prototype, {
	__class__: JsonParser_$190
});
class JsonParser_$192 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "fixedZero";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.ConditionalIndentationPolicy",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["fixedZero","fixedZeroIncrease","fixedZeroIncreaseBlocks","aligned","alignedNestedIncrease","alignedIncrease","alignedDecrease"],"fixedZero");
	}
}
$hxClasses["JsonParser_192"] = JsonParser_$192;
JsonParser_$192.__name__ = "JsonParser_192";
JsonParser_$192.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$192.prototype, {
	__class__: JsonParser_$192
});
class JsonParser_$194 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "all";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.BetweenImportsEmptyLinesLevel",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["all","firstLevelPackage","secondLevelPackage","thirdLevelPackage","fourthLevelPackage","fifthLevelPackage","fullPackage"],"all");
	}
}
$hxClasses["JsonParser_194"] = JsonParser_$194;
JsonParser_$194.__name__ = "JsonParser_194";
JsonParser_$194.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$194.prototype, {
	__class__: JsonParser_$194
});
class JsonParser_$196 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "keep";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.KeepEmptyLinesPolicy",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["keep","remove"],"keep");
	}
}
$hxClasses["JsonParser_196"] = JsonParser_$196;
JsonParser_$196.__name__ = "JsonParser_196";
JsonParser_$196.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$196.prototype, {
	__class__: JsonParser_$196
});
class JsonParser_$200 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "ignore";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.CommentEmptyLinesPolicy",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["ignore","none","one"],"ignore");
	}
}
$hxClasses["JsonParser_200"] = JsonParser_$200;
JsonParser_$200.__name__ = "JsonParser_200";
JsonParser_$200.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$200.prototype, {
	__class__: JsonParser_$200
});
class JsonParser_$21 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?existingBetweenFields : Null<formatter.config.KeepEmptyLinesPolicy>, ?endType : Null<Int>, ?betweenVars : Null<Int>, ?betweenFunctions : Null<Int>, ?beginType : Null<Int>, ?afterVars : Null<Int> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["afterVars","beginType","betweenFunctions","betweenVars","endType","existingBetweenFields"],[true,true,true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "afterVars":
				this.value.afterVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterVars",assigned,this.value.afterVars);
				break;
			case "beginType":
				this.value.beginType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beginType",assigned,this.value.beginType);
				break;
			case "betweenFunctions":
				this.value.betweenFunctions = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenFunctions",assigned,this.value.betweenFunctions);
				break;
			case "betweenVars":
				this.value.betweenVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenVars",assigned,this.value.betweenVars);
				break;
			case "endType":
				this.value.endType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"endType",assigned,this.value.endType);
				break;
			case "existingBetweenFields":
				this.value.existingBetweenFields = this.loadObjectField(($_=new JsonParser_$196(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"existingBetweenFields",assigned,this.value.existingBetweenFields);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { afterVars : 0, beginType : 0, betweenFunctions : 0, betweenVars : 0, endType : 0, existingBetweenFields : "keep"};
	}
}
$hxClasses["JsonParser_21"] = JsonParser_$21;
JsonParser_$21.__name__ = "JsonParser_21";
JsonParser_$21.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$21.prototype, {
	__class__: JsonParser_$21
});
class JsonParser_$216 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "keep";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.LineCommentEmptyLinePolicy",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["keep","one","none"],"keep");
	}
}
$hxClasses["JsonParser_216"] = JsonParser_$216;
JsonParser_$216.__name__ = "JsonParser_216";
JsonParser_$216.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$216.prototype, {
	__class__: JsonParser_$216
});
class JsonParser_$24 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?betweenImportsLevel : Null<formatter.config.BetweenImportsEmptyLinesLevel>, ?betweenImports : Null<Int>, ?beforeUsing : Null<Int>, ?beforeType : Null<Int> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["beforeType","beforeUsing","betweenImports","betweenImportsLevel"],[true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "beforeType":
				this.value.beforeType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeType",assigned,this.value.beforeType);
				break;
			case "beforeUsing":
				this.value.beforeUsing = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeUsing",assigned,this.value.beforeUsing);
				break;
			case "betweenImports":
				this.value.betweenImports = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenImports",assigned,this.value.betweenImports);
				break;
			case "betweenImportsLevel":
				this.value.betweenImportsLevel = this.loadObjectField(($_=new JsonParser_$194(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenImportsLevel",assigned,this.value.betweenImportsLevel);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { beforeType : 1, beforeUsing : 1, betweenImports : 0, betweenImportsLevel : "all"};
	}
}
$hxClasses["JsonParser_24"] = JsonParser_$24;
JsonParser_$24.__name__ = "JsonParser_24";
JsonParser_$24.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$24.prototype, {
	__class__: JsonParser_$24
});
class JsonParser_$33 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?trailingWhitespace : Null<Bool>, ?tabWidth : Null<Int>, ?indentObjectLiteral : Null<Bool>, ?indentComplexValueExpressions : Null<Bool>, ?indentCaseLabels : Null<Bool>, ?conditionalPolicy : Null<formatter.config.ConditionalIndentationPolicy>, ?character : Null<String> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["character","conditionalPolicy","indentCaseLabels","indentComplexValueExpressions","indentObjectLiteral","tabWidth","trailingWhitespace"],[true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "character":
				this.value.character = this.loadObjectField(($_=new JsonParser_$190(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"character",assigned,this.value.character);
				break;
			case "conditionalPolicy":
				this.value.conditionalPolicy = this.loadObjectField(($_=new JsonParser_$192(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"conditionalPolicy",assigned,this.value.conditionalPolicy);
				break;
			case "indentCaseLabels":
				this.value.indentCaseLabels = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"indentCaseLabels",assigned,this.value.indentCaseLabels);
				break;
			case "indentComplexValueExpressions":
				this.value.indentComplexValueExpressions = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"indentComplexValueExpressions",assigned,this.value.indentComplexValueExpressions);
				break;
			case "indentObjectLiteral":
				this.value.indentObjectLiteral = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"indentObjectLiteral",assigned,this.value.indentObjectLiteral);
				break;
			case "tabWidth":
				this.value.tabWidth = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"tabWidth",assigned,this.value.tabWidth);
				break;
			case "trailingWhitespace":
				this.value.trailingWhitespace = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"trailingWhitespace",assigned,this.value.trailingWhitespace);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { character : "tab", conditionalPolicy : "aligned", indentCaseLabels : true, indentComplexValueExpressions : false, indentObjectLiteral : true, tabWidth : 4, trailingWhitespace : false};
	}
}
$hxClasses["JsonParser_33"] = JsonParser_$33;
JsonParser_$33.__name__ = "JsonParser_33";
JsonParser_$33.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$33.prototype, {
	__class__: JsonParser_$33
});
class JsonParser_$36 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?typedefCurly : Null<formatter.config.CurlyLineEndPolicy>, ?sharp : Null<formatter.config.SharpLineEndPolicy>, ?rightCurly : Null<formatter.config.RightCurlyLineEndPolicy>, ?objectLiteralCurly : Null<formatter.config.CurlyLineEndPolicy>, ?metadataVar : Null<formatter.config.AtLineEndPolicy>, ?metadataType : Null<formatter.config.AtLineEndPolicy>, ?metadataOther : Null<formatter.config.AtLineEndPolicy>, ?metadataFunction : Null<formatter.config.AtLineEndPolicy>, ?leftCurly : Null<formatter.config.LeftCurlyLineEndPolicy>, ?emptyCurly : Null<formatter.config.EmptyCurlyPolicy>, ?caseColon : Null<formatter.config.CaseColonLineEndPolicy>, ?blockCurly : Null<formatter.config.CurlyLineEndPolicy>, ?anonTypeCurly : Null<formatter.config.CurlyLineEndPolicy>, ?anonFunctionCurly : Null<formatter.config.CurlyLineEndPolicy> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["anonFunctionCurly","anonTypeCurly","blockCurly","caseColon","emptyCurly","leftCurly","metadataFunction","metadataOther","metadataType","metadataVar","objectLiteralCurly","rightCurly","sharp","typedefCurly"],[true,true,true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "anonFunctionCurly":
				this.value.anonFunctionCurly = this.loadObjectField(($_=new JsonParser_$168(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonFunctionCurly",assigned,this.value.anonFunctionCurly);
				break;
			case "anonTypeCurly":
				this.value.anonTypeCurly = this.loadObjectField(($_=new JsonParser_$168(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonTypeCurly",assigned,this.value.anonTypeCurly);
				break;
			case "blockCurly":
				this.value.blockCurly = this.loadObjectField(($_=new JsonParser_$168(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"blockCurly",assigned,this.value.blockCurly);
				break;
			case "caseColon":
				this.value.caseColon = this.loadObjectField(($_=new JsonParser_$174(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"caseColon",assigned,this.value.caseColon);
				break;
			case "emptyCurly":
				this.value.emptyCurly = this.loadObjectField(($_=new JsonParser_$176(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"emptyCurly",assigned,this.value.emptyCurly);
				break;
			case "leftCurly":
				this.value.leftCurly = this.loadObjectField(($_=new JsonParser_$178(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"leftCurly",assigned,this.value.leftCurly);
				break;
			case "metadataFunction":
				this.value.metadataFunction = this.loadObjectField(($_=new JsonParser_$180(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"metadataFunction",assigned,this.value.metadataFunction);
				break;
			case "metadataOther":
				this.value.metadataOther = this.loadObjectField(($_=new JsonParser_$180(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"metadataOther",assigned,this.value.metadataOther);
				break;
			case "metadataType":
				this.value.metadataType = this.loadObjectField(($_=new JsonParser_$180(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"metadataType",assigned,this.value.metadataType);
				break;
			case "metadataVar":
				this.value.metadataVar = this.loadObjectField(($_=new JsonParser_$180(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"metadataVar",assigned,this.value.metadataVar);
				break;
			case "objectLiteralCurly":
				this.value.objectLiteralCurly = this.loadObjectField(($_=new JsonParser_$168(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"objectLiteralCurly",assigned,this.value.objectLiteralCurly);
				break;
			case "rightCurly":
				this.value.rightCurly = this.loadObjectField(($_=new JsonParser_$184(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"rightCurly",assigned,this.value.rightCurly);
				break;
			case "sharp":
				this.value.sharp = this.loadObjectField(($_=new JsonParser_$186(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"sharp",assigned,this.value.sharp);
				break;
			case "typedefCurly":
				this.value.typedefCurly = this.loadObjectField(($_=new JsonParser_$168(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typedefCurly",assigned,this.value.typedefCurly);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { anonFunctionCurly : null, anonTypeCurly : null, blockCurly : null, caseColon : "after", emptyCurly : "noBreak", leftCurly : "after", metadataFunction : "none", metadataOther : "none", metadataType : "none", metadataVar : "none", objectLiteralCurly : null, rightCurly : "both", sharp : "after", typedefCurly : null};
	}
}
$hxClasses["JsonParser_36"] = JsonParser_$36;
JsonParser_$36.__name__ = "JsonParser_36";
JsonParser_$36.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$36.prototype, {
	__class__: JsonParser_$36
});
class JsonParser_$39 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?whileBody : Null<formatter.config.SameLinePolicy>, ?untypedBody : Null<formatter.config.SameLinePolicy>, ?tryCatch : Null<formatter.config.SameLinePolicy>, ?tryBody : Null<formatter.config.SameLinePolicy>, ?returnBodySingleLine : Null<formatter.config.SameLinePolicy>, ?returnBody : Null<formatter.config.SameLinePolicy>, ?ifElse : Null<formatter.config.SameLinePolicy>, ?ifBody : Null<formatter.config.SameLinePolicy>, ?functionBody : Null<formatter.config.SameLinePolicy>, ?forBody : Null<formatter.config.SameLinePolicy>, ?expressionTry : Null<formatter.config.SameLinePolicy>, ?expressionIfWithBlocks : Null<Bool>, ?expressionIf : Null<formatter.config.SameLinePolicy>, ?expressionCase : Null<formatter.config.SameLinePolicy>, ?elseIf : Null<formatter.config.SameLinePolicy>, ?elseBody : Null<formatter.config.SameLinePolicy>, ?doWhileBody : Null<formatter.config.SameLinePolicy>, ?doWhile : Null<formatter.config.SameLinePolicy>, ?comprehensionFor : Null<formatter.config.SameLinePolicy>, ?catchBody : Null<formatter.config.SameLinePolicy>, ?caseBody : Null<formatter.config.SameLinePolicy>, ?anonFunctionBody : Null<formatter.config.SameLinePolicy> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["anonFunctionBody","caseBody","catchBody","comprehensionFor","doWhile","doWhileBody","elseBody","elseIf","expressionCase","expressionIf","expressionIfWithBlocks","expressionTry","forBody","functionBody","ifBody","ifElse","returnBody","returnBodySingleLine","tryBody","tryCatch","untypedBody","whileBody"],[true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "anonFunctionBody":
				this.value.anonFunctionBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonFunctionBody",assigned,this.value.anonFunctionBody);
				break;
			case "caseBody":
				this.value.caseBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"caseBody",assigned,this.value.caseBody);
				break;
			case "catchBody":
				this.value.catchBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"catchBody",assigned,this.value.catchBody);
				break;
			case "comprehensionFor":
				this.value.comprehensionFor = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"comprehensionFor",assigned,this.value.comprehensionFor);
				break;
			case "doWhile":
				this.value.doWhile = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"doWhile",assigned,this.value.doWhile);
				break;
			case "doWhileBody":
				this.value.doWhileBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"doWhileBody",assigned,this.value.doWhileBody);
				break;
			case "elseBody":
				this.value.elseBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"elseBody",assigned,this.value.elseBody);
				break;
			case "elseIf":
				this.value.elseIf = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"elseIf",assigned,this.value.elseIf);
				break;
			case "expressionCase":
				this.value.expressionCase = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"expressionCase",assigned,this.value.expressionCase);
				break;
			case "expressionIf":
				this.value.expressionIf = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"expressionIf",assigned,this.value.expressionIf);
				break;
			case "expressionIfWithBlocks":
				this.value.expressionIfWithBlocks = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"expressionIfWithBlocks",assigned,this.value.expressionIfWithBlocks);
				break;
			case "expressionTry":
				this.value.expressionTry = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"expressionTry",assigned,this.value.expressionTry);
				break;
			case "forBody":
				this.value.forBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"forBody",assigned,this.value.forBody);
				break;
			case "functionBody":
				this.value.functionBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"functionBody",assigned,this.value.functionBody);
				break;
			case "ifBody":
				this.value.ifBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"ifBody",assigned,this.value.ifBody);
				break;
			case "ifElse":
				this.value.ifElse = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"ifElse",assigned,this.value.ifElse);
				break;
			case "returnBody":
				this.value.returnBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"returnBody",assigned,this.value.returnBody);
				break;
			case "returnBodySingleLine":
				this.value.returnBodySingleLine = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"returnBodySingleLine",assigned,this.value.returnBodySingleLine);
				break;
			case "tryBody":
				this.value.tryBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"tryBody",assigned,this.value.tryBody);
				break;
			case "tryCatch":
				this.value.tryCatch = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"tryCatch",assigned,this.value.tryCatch);
				break;
			case "untypedBody":
				this.value.untypedBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"untypedBody",assigned,this.value.untypedBody);
				break;
			case "whileBody":
				this.value.whileBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"whileBody",assigned,this.value.whileBody);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { anonFunctionBody : "same", caseBody : "next", catchBody : "next", comprehensionFor : "same", doWhile : "same", doWhileBody : "next", elseBody : "next", elseIf : "same", expressionCase : "keep", expressionIf : "same", expressionIfWithBlocks : false, expressionTry : "same", forBody : "next", functionBody : "next", ifBody : "next", ifElse : "same", returnBody : "same", returnBodySingleLine : "same", tryBody : "next", tryCatch : "same", untypedBody : "same", whileBody : "next"};
	}
}
$hxClasses["JsonParser_39"] = JsonParser_$39;
JsonParser_$39.__name__ = "JsonParser_39";
JsonParser_$39.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$39.prototype, {
	__class__: JsonParser_$39
});
class JsonParser_$4 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?typedefEmptyLines : Null<formatter.config.TypedefFieldsEmptyLinesConfig>, ?maxAnywhereInFile : Null<Int>, ?macroClassEmptyLines : Null<formatter.config.ClassFieldsEmptyLinesConfig>, ?lineCommentsBetweenTypes : Null<formatter.config.LineCommentEmptyLinePolicy>, ?lineCommentsBetweenFunctions : Null<formatter.config.LineCommentEmptyLinePolicy>, ?interfaceEmptyLines : Null<formatter.config.InterfaceFieldsEmptyLinesConfig>, ?importAndUsing : Null<formatter.config.ImportsEmptyLinesConfig>, ?finalNewline : Null<Bool>, ?externClassEmptyLines : Null<formatter.config.InterfaceFieldsEmptyLinesConfig>, ?enumEmptyLines : Null<formatter.config.TypedefFieldsEmptyLinesConfig>, ?enumAbstractEmptyLines : Null<formatter.config.EnumAbstractFieldsEmptyLinesConfig>, ?conditionalsEmptyLines : Null<formatter.config.ConditionalEmptyLinesConfig>, ?classEmptyLines : Null<formatter.config.ClassFieldsEmptyLinesConfig>, ?betweenTypes : Null<Int>, ?betweenSingleLineTypes : Null<Int>, ?betweenMultilineComments : Null<Int>, ?beforeRightCurly : Null<formatter.config.KeepEmptyLinesPolicy>, ?beforePackage : Null<Int>, ?beforeDocCommentEmptyLines : Null<formatter.config.CommentEmptyLinesPolicy>, ?beforeBlocks : Null<formatter.config.KeepEmptyLinesPolicy>, ?afterReturn : Null<formatter.config.KeepEmptyLinesPolicy>, ?afterPackage : Null<Int>, ?afterLeftCurly : Null<formatter.config.KeepEmptyLinesPolicy>, ?afterFileHeaderComment : Null<Int>, ?afterFieldsWithDocComments : Null<formatter.config.CommentEmptyLinesPolicy>, ?afterBlocks : Null<formatter.config.KeepEmptyLinesPolicy>, ?abstractEmptyLines : Null<formatter.config.ClassFieldsEmptyLinesConfig> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["abstractEmptyLines","afterBlocks","afterFieldsWithDocComments","afterFileHeaderComment","afterLeftCurly","afterPackage","afterReturn","beforeBlocks","beforeDocCommentEmptyLines","beforePackage","beforeRightCurly","betweenMultilineComments","betweenSingleLineTypes","betweenTypes","classEmptyLines","conditionalsEmptyLines","enumAbstractEmptyLines","enumEmptyLines","externClassEmptyLines","finalNewline","importAndUsing","interfaceEmptyLines","lineCommentsBetweenFunctions","lineCommentsBetweenTypes","macroClassEmptyLines","maxAnywhereInFile","typedefEmptyLines"],[true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "abstractEmptyLines":
				this.value.abstractEmptyLines = this.loadObjectField(($_=new JsonParser_$7(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"abstractEmptyLines",assigned,this.value.abstractEmptyLines);
				break;
			case "afterBlocks":
				this.value.afterBlocks = this.loadObjectField(($_=new JsonParser_$196(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterBlocks",assigned,this.value.afterBlocks);
				break;
			case "afterFieldsWithDocComments":
				this.value.afterFieldsWithDocComments = this.loadObjectField(($_=new JsonParser_$200(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterFieldsWithDocComments",assigned,this.value.afterFieldsWithDocComments);
				break;
			case "afterFileHeaderComment":
				this.value.afterFileHeaderComment = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterFileHeaderComment",assigned,this.value.afterFileHeaderComment);
				break;
			case "afterLeftCurly":
				this.value.afterLeftCurly = this.loadObjectField(($_=new JsonParser_$196(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterLeftCurly",assigned,this.value.afterLeftCurly);
				break;
			case "afterPackage":
				this.value.afterPackage = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterPackage",assigned,this.value.afterPackage);
				break;
			case "afterReturn":
				this.value.afterReturn = this.loadObjectField(($_=new JsonParser_$196(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterReturn",assigned,this.value.afterReturn);
				break;
			case "beforeBlocks":
				this.value.beforeBlocks = this.loadObjectField(($_=new JsonParser_$196(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeBlocks",assigned,this.value.beforeBlocks);
				break;
			case "beforeDocCommentEmptyLines":
				this.value.beforeDocCommentEmptyLines = this.loadObjectField(($_=new JsonParser_$200(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeDocCommentEmptyLines",assigned,this.value.beforeDocCommentEmptyLines);
				break;
			case "beforePackage":
				this.value.beforePackage = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforePackage",assigned,this.value.beforePackage);
				break;
			case "beforeRightCurly":
				this.value.beforeRightCurly = this.loadObjectField(($_=new JsonParser_$196(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeRightCurly",assigned,this.value.beforeRightCurly);
				break;
			case "betweenMultilineComments":
				this.value.betweenMultilineComments = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenMultilineComments",assigned,this.value.betweenMultilineComments);
				break;
			case "betweenSingleLineTypes":
				this.value.betweenSingleLineTypes = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenSingleLineTypes",assigned,this.value.betweenSingleLineTypes);
				break;
			case "betweenTypes":
				this.value.betweenTypes = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenTypes",assigned,this.value.betweenTypes);
				break;
			case "classEmptyLines":
				this.value.classEmptyLines = this.loadObjectField(($_=new JsonParser_$7(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"classEmptyLines",assigned,this.value.classEmptyLines);
				break;
			case "conditionalsEmptyLines":
				this.value.conditionalsEmptyLines = this.loadObjectField(($_=new JsonParser_$12(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"conditionalsEmptyLines",assigned,this.value.conditionalsEmptyLines);
				break;
			case "enumAbstractEmptyLines":
				this.value.enumAbstractEmptyLines = this.loadObjectField(($_=new JsonParser_$15(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"enumAbstractEmptyLines",assigned,this.value.enumAbstractEmptyLines);
				break;
			case "enumEmptyLines":
				this.value.enumEmptyLines = this.loadObjectField(($_=new JsonParser_$18(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"enumEmptyLines",assigned,this.value.enumEmptyLines);
				break;
			case "externClassEmptyLines":
				this.value.externClassEmptyLines = this.loadObjectField(($_=new JsonParser_$21(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"externClassEmptyLines",assigned,this.value.externClassEmptyLines);
				break;
			case "finalNewline":
				this.value.finalNewline = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"finalNewline",assigned,this.value.finalNewline);
				break;
			case "importAndUsing":
				this.value.importAndUsing = this.loadObjectField(($_=new JsonParser_$24(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"importAndUsing",assigned,this.value.importAndUsing);
				break;
			case "interfaceEmptyLines":
				this.value.interfaceEmptyLines = this.loadObjectField(($_=new JsonParser_$21(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"interfaceEmptyLines",assigned,this.value.interfaceEmptyLines);
				break;
			case "lineCommentsBetweenFunctions":
				this.value.lineCommentsBetweenFunctions = this.loadObjectField(($_=new JsonParser_$216(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"lineCommentsBetweenFunctions",assigned,this.value.lineCommentsBetweenFunctions);
				break;
			case "lineCommentsBetweenTypes":
				this.value.lineCommentsBetweenTypes = this.loadObjectField(($_=new JsonParser_$216(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"lineCommentsBetweenTypes",assigned,this.value.lineCommentsBetweenTypes);
				break;
			case "macroClassEmptyLines":
				this.value.macroClassEmptyLines = this.loadObjectField(($_=new JsonParser_$7(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"macroClassEmptyLines",assigned,this.value.macroClassEmptyLines);
				break;
			case "maxAnywhereInFile":
				this.value.maxAnywhereInFile = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"maxAnywhereInFile",assigned,this.value.maxAnywhereInFile);
				break;
			case "typedefEmptyLines":
				this.value.typedefEmptyLines = this.loadObjectField(($_=new JsonParser_$18(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typedefEmptyLines",assigned,this.value.typedefEmptyLines);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { abstractEmptyLines : new JsonParser_$7([],this.putils,0).getAuto(), afterBlocks : "remove", afterFieldsWithDocComments : "one", afterFileHeaderComment : 1, afterLeftCurly : "remove", afterPackage : 1, afterReturn : "remove", beforeBlocks : "remove", beforeDocCommentEmptyLines : "one", beforePackage : 0, beforeRightCurly : "remove", betweenMultilineComments : 0, betweenSingleLineTypes : 0, betweenTypes : 1, classEmptyLines : new JsonParser_$7([],this.putils,0).getAuto(), conditionalsEmptyLines : new JsonParser_$12([],this.putils,0).getAuto(), enumAbstractEmptyLines : new JsonParser_$15([],this.putils,0).getAuto(), enumEmptyLines : new JsonParser_$18([],this.putils,0).getAuto(), externClassEmptyLines : new JsonParser_$21([],this.putils,0).getAuto(), finalNewline : true, importAndUsing : new JsonParser_$24([],this.putils,0).getAuto(), interfaceEmptyLines : new JsonParser_$21([],this.putils,0).getAuto(), lineCommentsBetweenFunctions : "keep", lineCommentsBetweenTypes : "keep", macroClassEmptyLines : new JsonParser_$7([],this.putils,0).getAuto(), maxAnywhereInFile : 1, typedefEmptyLines : new JsonParser_$18([],this.putils,0).getAuto()};
	}
}
$hxClasses["JsonParser_4"] = JsonParser_$4;
JsonParser_$4.__name__ = "JsonParser_4";
JsonParser_$4.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$4.prototype, {
	__class__: JsonParser_$4
});
class JsonParser_$42 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?whilePolicy : Null<formatter.config.WhitespacePolicy>, ?typeParamOpenPolicy : Null<formatter.config.WhitespacePolicy>, ?typeParamClosePolicy : Null<formatter.config.WhitespacePolicy>, ?typeHintColonPolicy : Null<formatter.config.WhitespacePolicy>, ?typeExtensionPolicy : Null<formatter.config.WhitespacePolicy>, ?typeCheckColonPolicy : Null<formatter.config.WhitespacePolicy>, ?tryPolicy : Null<formatter.config.WhitespacePolicy>, ?ternaryPolicy : Null<formatter.config.WhitespacePolicy>, ?switchPolicy : Null<formatter.config.WhitespacePolicy>, ?semicolonPolicy : Null<formatter.config.WhitespacePolicy>, ?parenConfig : Null<formatter.config.ParenWhitespaceConfig>, ?openingBracketPolicy : Null<formatter.config.WhitespacePolicy>, ?objectFieldColonPolicy : Null<formatter.config.WhitespacePolicy>, ?intervalPolicy : Null<formatter.config.WhitespacePolicy>, ?ifPolicy : Null<formatter.config.WhitespacePolicy>, ?functionTypeHaxe4Policy : Null<formatter.config.WhitespacePolicy>, ?functionTypeHaxe3Policy : Null<formatter.config.WhitespacePolicy>, ?formatStringInterpolation : Null<Bool>, ?forPolicy : Null<formatter.config.WhitespacePolicy>, ?dotPolicy : Null<formatter.config.WhitespacePolicy>, ?doPolicy : Null<formatter.config.WhitespacePolicy>, ?compressSuccessiveParenthesis : Null<Bool>, ?commaPolicy : Null<formatter.config.WhitespacePolicy>, ?colonPolicy : Null<formatter.config.WhitespacePolicy>, ?closingBracketPolicy : Null<formatter.config.WhitespacePolicy>, ?catchPolicy : Null<formatter.config.WhitespacePolicy>, ?caseColonPolicy : Null<formatter.config.WhitespacePolicy>, ?bracesConfig : Null<formatter.config.BracesWhitespaceConfig>, ?binopPolicy : Null<formatter.config.WhitespacePolicy>, ?arrowFunctionsPolicy : Null<formatter.config.WhitespacePolicy>, ?addLineCommentSpace : Null<Bool> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["addLineCommentSpace","arrowFunctionsPolicy","binopPolicy","bracesConfig","caseColonPolicy","catchPolicy","closingBracketPolicy","colonPolicy","commaPolicy","compressSuccessiveParenthesis","doPolicy","dotPolicy","forPolicy","formatStringInterpolation","functionTypeHaxe3Policy","functionTypeHaxe4Policy","ifPolicy","intervalPolicy","objectFieldColonPolicy","openingBracketPolicy","parenConfig","semicolonPolicy","switchPolicy","ternaryPolicy","tryPolicy","typeCheckColonPolicy","typeExtensionPolicy","typeHintColonPolicy","typeParamClosePolicy","typeParamOpenPolicy","whilePolicy"],[true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "addLineCommentSpace":
				this.value.addLineCommentSpace = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"addLineCommentSpace",assigned,this.value.addLineCommentSpace);
				break;
			case "arrowFunctionsPolicy":
				this.value.arrowFunctionsPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"arrowFunctionsPolicy",assigned,this.value.arrowFunctionsPolicy);
				break;
			case "binopPolicy":
				this.value.binopPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"binopPolicy",assigned,this.value.binopPolicy);
				break;
			case "bracesConfig":
				this.value.bracesConfig = this.loadObjectField(($_=new JsonParser_$45(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"bracesConfig",assigned,this.value.bracesConfig);
				break;
			case "caseColonPolicy":
				this.value.caseColonPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"caseColonPolicy",assigned,this.value.caseColonPolicy);
				break;
			case "catchPolicy":
				this.value.catchPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"catchPolicy",assigned,this.value.catchPolicy);
				break;
			case "closingBracketPolicy":
				this.value.closingBracketPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"closingBracketPolicy",assigned,this.value.closingBracketPolicy);
				break;
			case "colonPolicy":
				this.value.colonPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"colonPolicy",assigned,this.value.colonPolicy);
				break;
			case "commaPolicy":
				this.value.commaPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"commaPolicy",assigned,this.value.commaPolicy);
				break;
			case "compressSuccessiveParenthesis":
				this.value.compressSuccessiveParenthesis = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"compressSuccessiveParenthesis",assigned,this.value.compressSuccessiveParenthesis);
				break;
			case "doPolicy":
				this.value.doPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"doPolicy",assigned,this.value.doPolicy);
				break;
			case "dotPolicy":
				this.value.dotPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"dotPolicy",assigned,this.value.dotPolicy);
				break;
			case "forPolicy":
				this.value.forPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"forPolicy",assigned,this.value.forPolicy);
				break;
			case "formatStringInterpolation":
				this.value.formatStringInterpolation = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"formatStringInterpolation",assigned,this.value.formatStringInterpolation);
				break;
			case "functionTypeHaxe3Policy":
				this.value.functionTypeHaxe3Policy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"functionTypeHaxe3Policy",assigned,this.value.functionTypeHaxe3Policy);
				break;
			case "functionTypeHaxe4Policy":
				this.value.functionTypeHaxe4Policy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"functionTypeHaxe4Policy",assigned,this.value.functionTypeHaxe4Policy);
				break;
			case "ifPolicy":
				this.value.ifPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"ifPolicy",assigned,this.value.ifPolicy);
				break;
			case "intervalPolicy":
				this.value.intervalPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"intervalPolicy",assigned,this.value.intervalPolicy);
				break;
			case "objectFieldColonPolicy":
				this.value.objectFieldColonPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"objectFieldColonPolicy",assigned,this.value.objectFieldColonPolicy);
				break;
			case "openingBracketPolicy":
				this.value.openingBracketPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"openingBracketPolicy",assigned,this.value.openingBracketPolicy);
				break;
			case "parenConfig":
				this.value.parenConfig = this.loadObjectField(($_=new JsonParser_$48(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"parenConfig",assigned,this.value.parenConfig);
				break;
			case "semicolonPolicy":
				this.value.semicolonPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"semicolonPolicy",assigned,this.value.semicolonPolicy);
				break;
			case "switchPolicy":
				this.value.switchPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"switchPolicy",assigned,this.value.switchPolicy);
				break;
			case "ternaryPolicy":
				this.value.ternaryPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"ternaryPolicy",assigned,this.value.ternaryPolicy);
				break;
			case "tryPolicy":
				this.value.tryPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"tryPolicy",assigned,this.value.tryPolicy);
				break;
			case "typeCheckColonPolicy":
				this.value.typeCheckColonPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typeCheckColonPolicy",assigned,this.value.typeCheckColonPolicy);
				break;
			case "typeExtensionPolicy":
				this.value.typeExtensionPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typeExtensionPolicy",assigned,this.value.typeExtensionPolicy);
				break;
			case "typeHintColonPolicy":
				this.value.typeHintColonPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typeHintColonPolicy",assigned,this.value.typeHintColonPolicy);
				break;
			case "typeParamClosePolicy":
				this.value.typeParamClosePolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typeParamClosePolicy",assigned,this.value.typeParamClosePolicy);
				break;
			case "typeParamOpenPolicy":
				this.value.typeParamOpenPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typeParamOpenPolicy",assigned,this.value.typeParamOpenPolicy);
				break;
			case "whilePolicy":
				this.value.whilePolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"whilePolicy",assigned,this.value.whilePolicy);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { addLineCommentSpace : true, arrowFunctionsPolicy : "around", binopPolicy : "around", bracesConfig : new JsonParser_$45([],this.putils,0).getAuto(), caseColonPolicy : "onlyAfter", catchPolicy : "after", closingBracketPolicy : "none", colonPolicy : "none", commaPolicy : "onlyAfter", compressSuccessiveParenthesis : true, doPolicy : "after", dotPolicy : "none", forPolicy : "after", formatStringInterpolation : true, functionTypeHaxe3Policy : "none", functionTypeHaxe4Policy : "around", ifPolicy : "after", intervalPolicy : "none", objectFieldColonPolicy : "after", openingBracketPolicy : "noneAfter", parenConfig : new JsonParser_$48([],this.putils,0).getAuto(), semicolonPolicy : "onlyAfter", switchPolicy : "after", ternaryPolicy : "around", tryPolicy : "after", typeCheckColonPolicy : "around", typeExtensionPolicy : "after", typeHintColonPolicy : "none", typeParamClosePolicy : "none", typeParamOpenPolicy : "none", whilePolicy : "after"};
	}
}
$hxClasses["JsonParser_42"] = JsonParser_$42;
JsonParser_$42.__name__ = "JsonParser_42";
JsonParser_$42.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$42.prototype, {
	__class__: JsonParser_$42
});
class JsonParser_$45 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?unknownBraces : Null<formatter.config.OpenClosePolicy>, ?typedefBraces : Null<formatter.config.OpenClosePolicy>, ?objectLiteralBraces : Null<formatter.config.OpenClosePolicy>, ?blockBraces : Null<formatter.config.OpenClosePolicy>, ?anonTypeBraces : Null<formatter.config.OpenClosePolicy> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["anonTypeBraces","blockBraces","objectLiteralBraces","typedefBraces","unknownBraces"],[true,true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "anonTypeBraces":
				this.value.anonTypeBraces = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonTypeBraces",assigned,this.value.anonTypeBraces);
				break;
			case "blockBraces":
				this.value.blockBraces = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"blockBraces",assigned,this.value.blockBraces);
				break;
			case "objectLiteralBraces":
				this.value.objectLiteralBraces = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"objectLiteralBraces",assigned,this.value.objectLiteralBraces);
				break;
			case "typedefBraces":
				this.value.typedefBraces = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typedefBraces",assigned,this.value.typedefBraces);
				break;
			case "unknownBraces":
				this.value.unknownBraces = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"unknownBraces",assigned,this.value.unknownBraces);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { anonTypeBraces : { openingPolicy : "before", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, blockBraces : { openingPolicy : "before", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, objectLiteralBraces : { openingPolicy : "before", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, typedefBraces : { openingPolicy : "before", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, unknownBraces : { openingPolicy : "before", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}};
	}
}
$hxClasses["JsonParser_45"] = JsonParser_$45;
JsonParser_$45.__name__ = "JsonParser_45";
JsonParser_$45.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$45.prototype, {
	__class__: JsonParser_$45
});
class JsonParser_$48 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?whileConditionParens : Null<formatter.config.OpenClosePolicy>, ?switchConditionParens : Null<formatter.config.OpenClosePolicy>, ?sharpConditionParens : Null<formatter.config.OpenClosePolicy>, ?metadataParens : Null<formatter.config.OpenClosePolicy>, ?ifConditionParens : Null<formatter.config.OpenClosePolicy>, ?funcParamParens : Null<formatter.config.OpenClosePolicy>, ?forLoopParens : Null<formatter.config.OpenClosePolicy>, ?expressionParens : Null<formatter.config.OpenClosePolicy>, ?conditionParens : Null<formatter.config.OpenClosePolicy>, ?catchParens : Null<formatter.config.OpenClosePolicy>, ?callParens : Null<formatter.config.OpenClosePolicy>, ?anonFuncParamParens : Null<formatter.config.OpenClosePolicy> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["anonFuncParamParens","callParens","catchParens","conditionParens","expressionParens","forLoopParens","funcParamParens","ifConditionParens","metadataParens","sharpConditionParens","switchConditionParens","whileConditionParens"],[true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "anonFuncParamParens":
				this.value.anonFuncParamParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonFuncParamParens",assigned,this.value.anonFuncParamParens);
				break;
			case "callParens":
				this.value.callParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"callParens",assigned,this.value.callParens);
				break;
			case "catchParens":
				this.value.catchParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"catchParens",assigned,this.value.catchParens);
				break;
			case "conditionParens":
				this.value.conditionParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"conditionParens",assigned,this.value.conditionParens);
				break;
			case "expressionParens":
				this.value.expressionParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"expressionParens",assigned,this.value.expressionParens);
				break;
			case "forLoopParens":
				this.value.forLoopParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"forLoopParens",assigned,this.value.forLoopParens);
				break;
			case "funcParamParens":
				this.value.funcParamParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"funcParamParens",assigned,this.value.funcParamParens);
				break;
			case "ifConditionParens":
				this.value.ifConditionParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"ifConditionParens",assigned,this.value.ifConditionParens);
				break;
			case "metadataParens":
				this.value.metadataParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"metadataParens",assigned,this.value.metadataParens);
				break;
			case "sharpConditionParens":
				this.value.sharpConditionParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"sharpConditionParens",assigned,this.value.sharpConditionParens);
				break;
			case "switchConditionParens":
				this.value.switchConditionParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"switchConditionParens",assigned,this.value.switchConditionParens);
				break;
			case "whileConditionParens":
				this.value.whileConditionParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"whileConditionParens",assigned,this.value.whileConditionParens);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		let tmp = new JsonParser_$51([],this.putils,0).getAuto();
		let tmp1 = new JsonParser_$51([],this.putils,0).getAuto();
		let tmp2 = new JsonParser_$51([],this.putils,0).getAuto();
		let tmp3 = new JsonParser_$51([],this.putils,0).getAuto();
		return { anonFuncParamParens : tmp, callParens : tmp1, catchParens : null, conditionParens : { openingPolicy : "noneAfter", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, expressionParens : { openingPolicy : "noneAfter", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, forLoopParens : { openingPolicy : "noneAfter", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, funcParamParens : tmp2, ifConditionParens : null, metadataParens : tmp3, sharpConditionParens : null, switchConditionParens : null, whileConditionParens : null};
	}
}
$hxClasses["JsonParser_48"] = JsonParser_$48;
JsonParser_$48.__name__ = "JsonParser_48";
JsonParser_$48.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$48.prototype, {
	__class__: JsonParser_$48
});
class JsonParser_$51 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?removeInnerWhenEmpty : Null<Bool>, ?openingPolicy : Null<formatter.config.WhitespacePolicy>, ?closingPolicy : Null<formatter.config.WhitespacePolicy> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["closingPolicy","openingPolicy","removeInnerWhenEmpty"],[true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "closingPolicy":
				this.value.closingPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"closingPolicy",assigned,this.value.closingPolicy);
				break;
			case "openingPolicy":
				this.value.openingPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"openingPolicy",assigned,this.value.openingPolicy);
				break;
			case "removeInnerWhenEmpty":
				this.value.removeInnerWhenEmpty = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"removeInnerWhenEmpty",assigned,this.value.removeInnerWhenEmpty);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { closingPolicy : "onlyAfter", openingPolicy : "none", removeInnerWhenEmpty : true};
	}
}
$hxClasses["JsonParser_51"] = JsonParser_$51;
JsonParser_$51.__name__ = "JsonParser_51";
JsonParser_$51.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$51.prototype, {
	__class__: JsonParser_$51
});
class JsonParser_$60 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?typeParameter : Null<formatter.config.WrapRules>, ?opBoolChain : Null<formatter.config.WrapRules>, ?opAddSubChain : Null<formatter.config.WrapRules>, ?objectLiteral : Null<formatter.config.WrapRules>, ?multiVar : Null<formatter.config.WrapRules>, ?methodChain : Null<formatter.config.WrapRules>, ?metadataCallParameter : Null<formatter.config.WrapRules>, ?maxLineLength : Null<Int>, ?implementsExtends : Null<formatter.config.WrapRules>, ?functionSignature : Null<formatter.config.WrapRules>, ?casePattern : Null<formatter.config.WrapRules>, ?callParameter : Null<formatter.config.WrapRules>, ?arrayWrap : Null<formatter.config.WrapRules>, ?arrayMatrixWrap : Null<formatter.config.ArrayMatrixWrap>, ?anonType : Null<formatter.config.WrapRules>, ?anonFunctionSignature : Null<formatter.config.WrapRules> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["anonFunctionSignature","anonType","arrayMatrixWrap","arrayWrap","callParameter","casePattern","functionSignature","implementsExtends","maxLineLength","metadataCallParameter","methodChain","multiVar","objectLiteral","opAddSubChain","opBoolChain","typeParameter"],[true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "anonFunctionSignature":
				this.value.anonFunctionSignature = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonFunctionSignature",assigned,this.value.anonFunctionSignature);
				break;
			case "anonType":
				this.value.anonType = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonType",assigned,this.value.anonType);
				break;
			case "arrayMatrixWrap":
				this.value.arrayMatrixWrap = this.loadObjectField(($_=new JsonParser_$84(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"arrayMatrixWrap",assigned,this.value.arrayMatrixWrap);
				break;
			case "arrayWrap":
				this.value.arrayWrap = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"arrayWrap",assigned,this.value.arrayWrap);
				break;
			case "callParameter":
				this.value.callParameter = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"callParameter",assigned,this.value.callParameter);
				break;
			case "casePattern":
				this.value.casePattern = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"casePattern",assigned,this.value.casePattern);
				break;
			case "functionSignature":
				this.value.functionSignature = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"functionSignature",assigned,this.value.functionSignature);
				break;
			case "implementsExtends":
				this.value.implementsExtends = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"implementsExtends",assigned,this.value.implementsExtends);
				break;
			case "maxLineLength":
				this.value.maxLineLength = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"maxLineLength",assigned,this.value.maxLineLength);
				break;
			case "metadataCallParameter":
				this.value.metadataCallParameter = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"metadataCallParameter",assigned,this.value.metadataCallParameter);
				break;
			case "methodChain":
				this.value.methodChain = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"methodChain",assigned,this.value.methodChain);
				break;
			case "multiVar":
				this.value.multiVar = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"multiVar",assigned,this.value.multiVar);
				break;
			case "objectLiteral":
				this.value.objectLiteral = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"objectLiteral",assigned,this.value.objectLiteral);
				break;
			case "opAddSubChain":
				this.value.opAddSubChain = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"opAddSubChain",assigned,this.value.opAddSubChain);
				break;
			case "opBoolChain":
				this.value.opBoolChain = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"opBoolChain",assigned,this.value.opBoolChain);
				break;
			case "typeParameter":
				this.value.typeParameter = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typeParameter",assigned,this.value.typeParameter);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { anonFunctionSignature : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "itemCount >= n", value : 7}], type : "fillLine", additionalIndent : 1},{ conditions : [{ cond : "totalItemLength >= n", value : 80}], type : "fillLine", additionalIndent : 1},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "fillLine", additionalIndent : 1}]}, anonType : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "itemCount <= n", value : 3},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "anyItemLength >= n", value : 30}], type : "onePerLine"},{ conditions : [{ cond : "totalItemLength >= n", value : 60}], type : "onePerLine"},{ conditions : [{ cond : "itemCount >= n", value : 4}], type : "onePerLine"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "fillLine"}]}, arrayMatrixWrap : "matrixWrapWithAlign", arrayWrap : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "hasMultilineItems", value : 1}], type : "onePerLine"},{ conditions : [{ cond : "totalItemLength <= n", value : 80}], type : "noWrap"},{ conditions : [{ cond : "itemCount >= n", value : 10}], type : "fillLineWithLeadingBreak"},{ conditions : [{ cond : "anyItemLength >= n", value : 30}], type : "onePerLine"},{ conditions : [{ cond : "itemCount >= n", value : 4}], type : "onePerLine"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "onePerLine"}]}, callParameter : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "itemCount >= n", value : 7}], type : "fillLine"},{ conditions : [{ cond : "totalItemLength >= n", value : 140}], type : "fillLine"},{ conditions : [{ cond : "anyItemLength >= n", value : 80}], type : "fillLine"},{ conditions : [{ cond : "lineLength >= n", value : 160}], type : "fillLine"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "fillLine"}]}, casePattern : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "itemCount >= n", value : 2}], type : "fillLine"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "fillLine"}]}, functionSignature : { defaultWrap : "fillLine", defaultAdditionalIndent : 1, rules : []}, implementsExtends : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "lineLength >= n", value : 140}], type : "fillLine", additionalIndent : 2},{ conditions : [{ cond : "itemCount >= n", value : 4}], type : "fillLine", additionalIndent : 2},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "fillLine", additionalIndent : 2}]}, maxLineLength : 160, metadataCallParameter : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "totalItemLength >= n", value : 140}], type : "fillLine"},{ conditions : [{ cond : "lineLength >= n", value : 160}], type : "fillLine"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "fillLine"}]}, methodChain : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "lineLength >= n", value : 160}], type : "onePerLineAfterFirst"},{ conditions : [{ cond : "itemCount <= n", value : 3},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "totalItemLength <= n", value : 80},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "anyItemLength >= n", value : 30},{ cond : "itemCount >= n", value : 4}], type : "onePerLineAfterFirst"},{ conditions : [{ cond : "itemCount >= n", value : 7}], type : "onePerLineAfterFirst"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "onePerLineAfterFirst"}]}, multiVar : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "anyItemLength <= n", value : 15}], type : "fillLine"},{ conditions : [{ cond : "lineLength >= n", value : 80}], type : "onePerLineAfterFirst"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "onePerLineAfterFirst"}]}, objectLiteral : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "itemCount <= n", value : 3},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "anyItemLength >= n", value : 30}], type : "onePerLine"},{ conditions : [{ cond : "totalItemLength >= n", value : 60}], type : "onePerLine"},{ conditions : [{ cond : "itemCount >= n", value : 4}], type : "onePerLine"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "onePerLine"}]}, opAddSubChain : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "lineLength >= n", value : 160},{ cond : "anyItemLength >= n", value : 60}], location : "beforeLast", type : "onePerLineAfterFirst"},{ conditions : [{ cond : "lineLength >= n", value : 160}], location : "beforeLast", type : "fillLine"},{ conditions : [{ cond : "itemCount <= n", value : 3},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "totalItemLength <= n", value : 120},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "itemCount >= n", value : 4}], location : "beforeLast", type : "onePerLineAfterFirst"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], location : "beforeLast", type : "onePerLineAfterFirst"}]}, opBoolChain : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "lineLength >= n", value : 140},{ cond : "anyItemLength >= n", value : 40}], location : "beforeLast", type : "onePerLineAfterFirst"},{ conditions : [{ cond : "lineLength >= n", value : 140}], location : "beforeLast", type : "fillLine"},{ conditions : [{ cond : "itemCount <= n", value : 3},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "totalItemLength <= n", value : 120},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "itemCount >= n", value : 4}], location : "beforeLast", type : "onePerLineAfterFirst"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], location : "beforeLast", type : "fillLine"}]}, typeParameter : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "anyItemLength >= n", value : 50}], type : "fillLine"},{ conditions : [{ cond : "totalItemLength >= n", value : 70}], type : "fillLine"}]}};
	}
}
$hxClasses["JsonParser_60"] = JsonParser_$60;
JsonParser_$60.__name__ = "JsonParser_60";
JsonParser_$60.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$60.prototype, {
	__class__: JsonParser_$60
});
class JsonParser_$62 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"Bool",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonBool(b,pos,variable) {
		this.value = b;
	}
}
$hxClasses["JsonParser_62"] = JsonParser_$62;
JsonParser_$62.__name__ = "JsonParser_62";
JsonParser_$62.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$62.prototype, {
	__class__: JsonParser_$62
});
class JsonParser_$66 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"Array<String>",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonArray(a,pos,variable) {
		this.value = this.loadJsonArrayValue(a,($_=new JsonParser_$77(this.errors,this.putils,2),$bind($_,$_.loadJson)),variable);
	}
}
$hxClasses["JsonParser_66"] = JsonParser_$66;
JsonParser_$66.__name__ = "JsonParser_66";
JsonParser_$66.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$66.prototype, {
	__class__: JsonParser_$66
});
class JsonParser_$7 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?existingBetweenFields : Null<formatter.config.KeepEmptyLinesPolicy>, ?endType : Null<Int>, ?betweenVars : Null<Int>, ?betweenStaticVars : Null<Int>, ?betweenStaticFunctions : Null<Int>, ?betweenFunctions : Null<Int>, ?beginType : Null<Int>, ?afterVars : Null<Int>, ?afterStaticVars : Null<Int>, ?afterStaticFunctions : Null<Int>, ?afterPrivateVars : Null<Int>, ?afterPrivateFunctions : Null<Int> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["afterPrivateFunctions","afterPrivateVars","afterStaticFunctions","afterStaticVars","afterVars","beginType","betweenFunctions","betweenStaticFunctions","betweenStaticVars","betweenVars","endType","existingBetweenFields"],[true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "afterPrivateFunctions":
				this.value.afterPrivateFunctions = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterPrivateFunctions",assigned,this.value.afterPrivateFunctions);
				break;
			case "afterPrivateVars":
				this.value.afterPrivateVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterPrivateVars",assigned,this.value.afterPrivateVars);
				break;
			case "afterStaticFunctions":
				this.value.afterStaticFunctions = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterStaticFunctions",assigned,this.value.afterStaticFunctions);
				break;
			case "afterStaticVars":
				this.value.afterStaticVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterStaticVars",assigned,this.value.afterStaticVars);
				break;
			case "afterVars":
				this.value.afterVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterVars",assigned,this.value.afterVars);
				break;
			case "beginType":
				this.value.beginType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beginType",assigned,this.value.beginType);
				break;
			case "betweenFunctions":
				this.value.betweenFunctions = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenFunctions",assigned,this.value.betweenFunctions);
				break;
			case "betweenStaticFunctions":
				this.value.betweenStaticFunctions = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenStaticFunctions",assigned,this.value.betweenStaticFunctions);
				break;
			case "betweenStaticVars":
				this.value.betweenStaticVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenStaticVars",assigned,this.value.betweenStaticVars);
				break;
			case "betweenVars":
				this.value.betweenVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenVars",assigned,this.value.betweenVars);
				break;
			case "endType":
				this.value.endType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"endType",assigned,this.value.endType);
				break;
			case "existingBetweenFields":
				this.value.existingBetweenFields = this.loadObjectField(($_=new JsonParser_$196(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"existingBetweenFields",assigned,this.value.existingBetweenFields);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { afterPrivateFunctions : 1, afterPrivateVars : 1, afterStaticFunctions : 1, afterStaticVars : 1, afterVars : 1, beginType : 0, betweenFunctions : 1, betweenStaticFunctions : 1, betweenStaticVars : 0, betweenVars : 0, endType : 0, existingBetweenFields : "keep"};
	}
}
$hxClasses["JsonParser_7"] = JsonParser_$7;
JsonParser_$7.__name__ = "JsonParser_7";
JsonParser_$7.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$7.prototype, {
	__class__: JsonParser_$7
});
class JsonParser_$77 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"String",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = s;
	}
}
$hxClasses["JsonParser_77"] = JsonParser_$77;
JsonParser_$77.__name__ = "JsonParser_77";
JsonParser_$77.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$77.prototype, {
	__class__: JsonParser_$77
});
class JsonParser_$80 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?rules : Null<Array<formatter.config.WrapRule>>, ?defaultWrap : Null<formatter.config.WrappingType>, ?defaultLocation : Null<formatter.config.WrappingLocation>, ?defaultAdditionalIndent : Null<Int> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["defaultAdditionalIndent","defaultLocation","defaultWrap","rules"],[true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "defaultAdditionalIndent":
				this.value.defaultAdditionalIndent = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"defaultAdditionalIndent",assigned,this.value.defaultAdditionalIndent);
				break;
			case "defaultLocation":
				this.value.defaultLocation = this.loadObjectField(($_=new JsonParser_$112(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"defaultLocation",assigned,this.value.defaultLocation);
				break;
			case "defaultWrap":
				this.value.defaultWrap = this.loadObjectField(($_=new JsonParser_$114(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"defaultWrap",assigned,this.value.defaultWrap);
				break;
			case "rules":
				this.value.rules = this.loadObjectField(($_=new JsonParser_$116(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"rules",assigned,this.value.rules);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { defaultAdditionalIndent : 0, defaultLocation : "afterLast", defaultWrap : "noWrap", rules : []};
	}
}
$hxClasses["JsonParser_80"] = JsonParser_$80;
JsonParser_$80.__name__ = "JsonParser_80";
JsonParser_$80.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$80.prototype, {
	__class__: JsonParser_$80
});
class JsonParser_$84 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "noMatrixWrap";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.ArrayMatrixWrap",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["noMatrixWrap","matrixWrapNoAlign","matrixWrapWithAlign"],"noMatrixWrap");
	}
}
$hxClasses["JsonParser_84"] = JsonParser_$84;
JsonParser_$84.__name__ = "JsonParser_84";
JsonParser_$84.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$84.prototype, {
	__class__: JsonParser_$84
});
class JsonParser_$96 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"Int",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonNumber(f,pos,variable) {
		this.value = this.loadJsonInt(f,pos,variable,this.value);
	}
}
$hxClasses["JsonParser_96"] = JsonParser_$96;
JsonParser_$96.__name__ = "JsonParser_96";
JsonParser_$96.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$96.prototype, {
	__class__: JsonParser_$96
});
class Keywords {
	constructor() {
		this.words = new haxe_ds_StringMap();
		this.names = new haxe_ds_StringMap();
		this.pageKeywords = new haxe_ds_StringMap();
	}
	addKeywords(hash,name,keywords) {
		this.pageKeywords.h[hash] = keywords;
		this.names.h[hash] = name;
		let _g = 0;
		while(_g < keywords.length) {
			let word = keywords[_g];
			++_g;
			let pageList = this.words.h[word];
			if(pageList == null) {
				pageList = [];
				this.words.h[word] = pageList;
			}
			pageList.push(hash);
		}
	}
	getKeywordList() {
		let keywords = [];
		let word = haxe_ds_StringMap.keysIterator(this.words.h);
		while(word.hasNext()) {
			let word1 = word.next();
			keywords.push(word1);
		}
		haxe_ds_ArraySort.sort(keywords,function(s1,s2) {
			if(s1 == s2) {
				return 0;
			} else if(s1 < s2) {
				return -1;
			} else {
				return 1;
			}
		});
		return keywords;
	}
	getSearchResults(keyword) {
		let results = [];
		keyword = keyword.toLowerCase();
		let pageList = this.words.h[keyword];
		if(pageList == null) {
			pageList = [];
		}
		let pages = [];
		let word = haxe_ds_StringMap.keysIterator(this.words.h);
		while(word.hasNext()) {
			let word1 = word.next();
			if(word1.indexOf(keyword) == -1) {
				continue;
			}
			pages = pages.concat(this.words.h[word1]);
		}
		let _g = 0;
		while(_g < pages.length) {
			let page = pages[_g];
			++_g;
			if(pageList.indexOf(page) >= 0) {
				continue;
			}
			pageList.push(page);
		}
		let _g1 = 0;
		while(_g1 < pageList.length) {
			let page = pageList[_g1];
			++_g1;
			let name = this.names.h[page];
			results.push({ name : name, hash : page});
		}
		return results;
	}
}
$hxClasses["Keywords"] = Keywords;
Keywords.__name__ = "Keywords";
Object.assign(Keywords.prototype, {
	__class__: Keywords
	,words: null
	,pageKeywords: null
	,names: null
});
class Main {
	static main() {
		new Navigation();
	}
}
$hxClasses["Main"] = Main;
Main.__name__ = "Main";
class Markdown {
	static markdownToHtml(markdown) {
		let document = new Document();
		try {
			let _this_r = new RegExp("(\r\n|\r)","g".split("u").join(""));
			let lines = markdown.replace(_this_r,"\n").split("\n");
			document.parseRefLinks(lines);
			let blocks = document.parseLines(lines);
			return Markdown.renderHtml(blocks);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			let e = haxe_Exception.caught(_g).unwrap();
			return "<pre>" + Std.string(e) + "</pre>";
		}
	}
	static renderHtml(blocks) {
		return new markdown_HtmlRenderer().render(blocks);
	}
}
$hxClasses["Markdown"] = Markdown;
Markdown.__name__ = "Markdown";
class Document {
	constructor() {
		this.refLinks = new haxe_ds_StringMap();
		this.codeBlockSyntaxes = new haxe_ds_StringMap();
		this.inlineSyntaxes = [];
	}
	parseRefLinks(lines) {
		let indent = "^[ ]{0,3}";
		let id = "\\[([^\\]]+)\\]";
		let quote = "\"[^\"]+\"";
		let apos = "'[^']+'";
		let paren = "\\([^)]+\\)";
		let titles = new EReg("(" + quote + "|" + apos + "|" + paren + ")","");
		let link = new EReg("" + indent + id + ":\\s+(\\S+)\\s*(" + quote + "|" + apos + "|" + paren + "|)\\s*$","");
		let _g = 0;
		let _g1 = lines.length;
		while(_g < _g1) {
			let i = _g++;
			if(!link.match(lines[i])) {
				continue;
			}
			let id = link.matched(1);
			let url = link.matched(2);
			let title = link.matched(3);
			if(StringTools.startsWith(url,"<") && StringTools.endsWith(url,">")) {
				url = HxOverrides.substr(url,1,url.length - 2);
			}
			if(title == "" && lines[i + 1] != null && titles.match(lines[i + 1])) {
				title = titles.matched(1);
				lines[i + 1] = "";
			}
			if(title == "") {
				title = null;
			} else {
				title = title.substring(1,title.length - 1);
			}
			id = id.toLowerCase();
			let this1 = this.refLinks;
			let value = new Link(id,url,title);
			this1.h[id] = value;
			lines[i] = "";
		}
	}
	parseLines(lines) {
		let parser = new markdown_BlockParser(lines,this);
		let blocks = [];
		while(parser.pos < parser.lines.length) {
			let _g = 0;
			let _g1 = markdown_BlockSyntax.get_syntaxes();
			while(_g < _g1.length) {
				let syntax = _g1[_g];
				++_g;
				if(syntax.canParse(parser)) {
					let block = syntax.parse(parser);
					if(block != null) {
						blocks.push(block);
					}
					break;
				}
			}
		}
		return blocks;
	}
	parseInline(text) {
		return new markdown_InlineParser(text,this).parse();
	}
}
$hxClasses["Document"] = Document;
Document.__name__ = "Document";
Object.assign(Document.prototype, {
	__class__: Document
	,refLinks: null
	,inlineSyntaxes: null
	,linkResolver: null
	,codeBlockSyntaxes: null
});
class Link {
	constructor(id,url,title) {
		this.id = id;
		this.url = url;
		this.title = title;
	}
}
$hxClasses["Link"] = Link;
Link.__name__ = "Link";
Object.assign(Link.prototype, {
	__class__: Link
	,id: null
	,url: null
	,title: null
});
Math.__name__ = "Math";
class Navigation {
	constructor() {
		this.configFieldRegistry = new codesamples_config_ConfigFieldRegistry();
		this.keywords = new Keywords();
		this.buildNavigation();
	}
	buildNavigation() {
		let content = "";
		content += "<div id=\"searchContainer\"><input type=\"text\" placeholder=\"search\" id=\"searchBox\" /><button id=\"searchBtn\">Go</button></div>\n";
		content += "<ul class=\"sections\">\n";
		content += this.buildNavigationsection(doc_Docs);
		content += this.buildNavigationsection(codesamples_CommonSamples);
		content += this.buildNavigationsection(codesamples_EmptylinesSamples);
		content += this.buildNavigationsection(codesamples_IndentationSamples);
		content += this.buildNavigationsection(codesamples_LineendsSamples);
		content += this.buildNavigationsection(codesamples_SamelineSamples);
		content += this.buildNavigationsection(codesamples_WhitespaceSamples);
		content += this.buildNavigationsection(codesamples_WrappingSamples);
		content += "</ul>\n";
		$("#navigation").html(content);
		$(window).on("hashchange",null,$bind(this,this.onHashChange));
		$("#searchBox").autocomplete({ source : this.keywords.getKeywordList()});
		$("#searchBtn").click($bind(this,this.onClickSearch));
		if(window.location.hash.length > 1) {
			this.onHashChange(null);
		}
	}
	buildNavigationsection(c) {
		let sectioName = haxe_rtti_Meta.getType(c).sectionName[0];
		let className = c.__name__;
		let content = "<li class=\"section\">" + sectioName + "\n<ul class=\"sectionEntries\">\n";
		let _g = 0;
		let _g1 = Type.getInstanceFields(c);
		while(_g < _g1.length) {
			let field = _g1[_g];
			++_g;
			let fieldMeta = Reflect.field(haxe_rtti_Meta.getFields(c),field);
			if(fieldMeta == null) {
				continue;
			}
			let name = Reflect.field(fieldMeta,"codeSampleName");
			if(name == null) {
				name = Reflect.field(fieldMeta,"docName");
			}
			if(name == null) {
				continue;
			}
			let words = Reflect.field(fieldMeta,"keywords");
			if(words.length > 0) {
				this.keywords.addKeywords("" + className + "." + field,name[0],words[0]);
			}
			content += "<li data-class-name=\"" + className + "\" data-field-name=\"" + field + "\">" + ("<a href=\"#" + className + "." + field + "\" data-class-name=\"" + className + "\" data-field-name=\"" + field + "\">" + StringTools.replace(name[0],"."," ") + "</a></li>");
		}
		content += "</ul>\n</li>\n";
		return content;
	}
	onHashChange(event) {
		let name = window.location.hash;
		if(StringTools.startsWith(name,"#")) {
			name = HxOverrides.substr(name,1,null);
		}
		if(StringTools.startsWith(name,"search=")) {
			this.showSearchResults(HxOverrides.substr(name,7,null));
			return;
		}
		let parts = name.split(".");
		let fieldName = parts.pop();
		let className = parts.join(".");
		let instance = Type.createInstance($hxClasses[className],[]);
		if(instance == null) {
			$("#content").html("");
			return;
		}
		let field = Reflect.field(instance,fieldName);
		if(field == null) {
			$("#content").html("");
			return;
		}
		field.apply(instance,["#content",this.configFieldRegistry]);
		$(".sectionEntries li").removeClass("active");
		$(".sectionEntries li").filter("[data-class-name=\"" + className + "\"]").filter("[data-field-name=\"" + fieldName + "\"]").addClass("active");
	}
	onClickSearch(event) {
		let tmp = Std.string($("#searchBox").val());
		window.location.hash = "#search=" + tmp;
	}
	showSearchResults(search) {
		let content = "<h1>search results</h1>\n";
		let results = this.keywords.getSearchResults(search);
		if(results.length <= 0) {
			return;
		}
		content += "<ul id=\"searchResultContainer\">\n";
		let _g = 0;
		while(_g < results.length) {
			let result = results[_g];
			++_g;
			content += "<li><a href=\"#" + result.hash + "\">" + StringTools.replace(result.name,"."," ") + "</a></li>\n";
		}
		content += "</ul>\n";
		$("#content").html(content);
	}
}
$hxClasses["Navigation"] = Navigation;
Navigation.__name__ = "Navigation";
Object.assign(Navigation.prototype, {
	__class__: Navigation
	,configFieldRegistry: null
	,keywords: null
});
class Reflect {
	static field(o,field) {
		try {
			return o[field];
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			return null;
		}
	}
	static fields(o) {
		let a = [];
		if(o != null) {
			let hasOwnProperty = Object.prototype.hasOwnProperty;
			for( var f in o ) {
			if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
				a.push(f);
			}
			}
		}
		return a;
	}
	static compare(a,b) {
		if(a == b) {
			return 0;
		} else if(a > b) {
			return 1;
		} else {
			return -1;
		}
	}
}
$hxClasses["Reflect"] = Reflect;
Reflect.__name__ = "Reflect";
class Std {
	static string(s) {
		return js_Boot.__string_rec(s,"");
	}
	static parseInt(x) {
		if(x != null) {
			let _g = 0;
			let _g1 = x.length;
			while(_g < _g1) {
				let i = _g++;
				let c = x.charCodeAt(i);
				if(c <= 8 || c >= 14 && c != 32 && c != 45) {
					let nc = x.charCodeAt(i + 1);
					let v = parseInt(x,nc == 120 || nc == 88 ? 16 : 10);
					if(isNaN(v)) {
						return null;
					} else {
						return v;
					}
				}
			}
		}
		return null;
	}
}
$hxClasses["Std"] = Std;
Std.__name__ = "Std";
class StringBuf {
	constructor() {
		this.b = "";
	}
}
$hxClasses["StringBuf"] = StringBuf;
StringBuf.__name__ = "StringBuf";
Object.assign(StringBuf.prototype, {
	__class__: StringBuf
	,b: null
});
class StringTools {
	static htmlEscape(s,quotes) {
		let buf_b = "";
		let _g_offset = 0;
		let _g_s = s;
		while(_g_offset < _g_s.length) {
			let s = _g_s;
			let index = _g_offset++;
			let c = s.charCodeAt(index);
			if(c >= 55296 && c <= 56319) {
				c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
			}
			let c1 = c;
			if(c1 >= 65536) {
				++_g_offset;
			}
			let code = c1;
			switch(code) {
			case 34:
				if(quotes) {
					buf_b += "&quot;";
				} else {
					buf_b += String.fromCodePoint(code);
				}
				break;
			case 38:
				buf_b += "&amp;";
				break;
			case 39:
				if(quotes) {
					buf_b += "&#039;";
				} else {
					buf_b += String.fromCodePoint(code);
				}
				break;
			case 60:
				buf_b += "&lt;";
				break;
			case 62:
				buf_b += "&gt;";
				break;
			default:
				buf_b += String.fromCodePoint(code);
			}
		}
		return buf_b;
	}
	static startsWith(s,start) {
		if(s.length >= start.length) {
			return s.lastIndexOf(start,0) == 0;
		} else {
			return false;
		}
	}
	static endsWith(s,end) {
		let elen = end.length;
		let slen = s.length;
		if(slen >= elen) {
			return s.indexOf(end,slen - elen) == slen - elen;
		} else {
			return false;
		}
	}
	static isSpace(s,pos) {
		let c = HxOverrides.cca(s,pos);
		if(!(c > 8 && c < 14)) {
			return c == 32;
		} else {
			return true;
		}
	}
	static ltrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,r)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,r,l - r);
		} else {
			return s;
		}
	}
	static rtrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,0,l - r);
		} else {
			return s;
		}
	}
	static trim(s) {
		return StringTools.ltrim(StringTools.rtrim(s));
	}
	static lpad(s,c,l) {
		if(c.length <= 0) {
			return s;
		}
		let buf_b = "";
		l -= s.length;
		while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
		buf_b += s == null ? "null" : "" + s;
		return buf_b;
	}
	static replace(s,sub,by) {
		return s.split(sub).join(by);
	}
}
$hxClasses["StringTools"] = StringTools;
StringTools.__name__ = "StringTools";
var ValueType = $hxEnums["ValueType"] = { __ename__ : true, __constructs__ : ["TNull","TInt","TFloat","TBool","TObject","TFunction","TClass","TEnum","TUnknown"]
	,TNull: {_hx_index:0,__enum__:"ValueType",toString:$estr}
	,TInt: {_hx_index:1,__enum__:"ValueType",toString:$estr}
	,TFloat: {_hx_index:2,__enum__:"ValueType",toString:$estr}
	,TBool: {_hx_index:3,__enum__:"ValueType",toString:$estr}
	,TObject: {_hx_index:4,__enum__:"ValueType",toString:$estr}
	,TFunction: {_hx_index:5,__enum__:"ValueType",toString:$estr}
	,TClass: ($_=function(c) { return {_hx_index:6,c:c,__enum__:"ValueType",toString:$estr}; },$_.__params__ = ["c"],$_)
	,TEnum: ($_=function(e) { return {_hx_index:7,e:e,__enum__:"ValueType",toString:$estr}; },$_.__params__ = ["e"],$_)
	,TUnknown: {_hx_index:8,__enum__:"ValueType",toString:$estr}
};
class Type {
	static createInstance(cl,args) {
		let ctor = Function.prototype.bind.apply(cl,[null].concat(args));
		return new (ctor);
	}
	static getInstanceFields(c) {
		let result = [];
		while(c != null) {
			let _g = 0;
			let _g1 = Object.getOwnPropertyNames(c.prototype);
			while(_g < _g1.length) {
				let name = _g1[_g];
				++_g;
				switch(name) {
				case "__class__":case "__properties__":case "constructor":
					break;
				default:
					if(result.indexOf(name) == -1) {
						result.push(name);
					}
				}
			}
			c = c.__super__;
		}
		return result;
	}
	static typeof(v) {
		switch(typeof(v)) {
		case "boolean":
			return ValueType.TBool;
		case "function":
			if(v.__name__ || v.__ename__) {
				return ValueType.TObject;
			}
			return ValueType.TFunction;
		case "number":
			if(Math.ceil(v) == v % 2147483648.0) {
				return ValueType.TInt;
			}
			return ValueType.TFloat;
		case "object":
			if(v == null) {
				return ValueType.TNull;
			}
			let e = v.__enum__;
			if(e != null) {
				return ValueType.TEnum($hxEnums[e]);
			}
			let c = js_Boot.getClass(v);
			if(c != null) {
				return ValueType.TClass(c);
			}
			return ValueType.TObject;
		case "string":
			return ValueType.TClass(String);
		case "undefined":
			return ValueType.TNull;
		default:
			return ValueType.TUnknown;
		}
	}
	static enumEq(a,b) {
		if(a == b) {
			return true;
		}
		try {
			let e = a.__enum__;
			if(e == null || e != b.__enum__) {
				return false;
			}
			if(a._hx_index != b._hx_index) {
				return false;
			}
			let enm = $hxEnums[e];
			let ctorName = enm.__constructs__[a._hx_index];
			let params = enm[ctorName].__params__;
			let _g = 0;
			while(_g < params.length) {
				let f = params[_g];
				++_g;
				if(!Type.enumEq(a[f],b[f])) {
					return false;
				}
			}
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			return false;
		}
		return true;
	}
}
$hxClasses["Type"] = Type;
Type.__name__ = "Type";
class codesamples_SampleBase {
	buildDocSamplePage(container,codeSampleName,docText,configText,fieldDef,codeSample,registry) {
		let content = "<h1>" + StringTools.replace(codeSampleName,"."," ") + "</h1>\n";
		this.configFieldRegistry = registry;
		this.configFieldRegistry.setCurrentSampleConfig(configText);
		content += "<div id=\"configWrapper\">";
		content += "<div id=\"docContainer\">" + Markdown.markdownToHtml(docText) + "</div>";
		content += "<div id=\"configContainer\"><div id=\"configHeader\">hxformat.json" + "<div id=\"configButtons\"><button id=\"btnApply\">Apply</button>" + "<button id=\"btnEdit\">Edit</button><button id=\"btnDownload\">Download</button></div></div>" + ("<pre id=\"config\">" + this.configFieldRegistry.buildConfigHtml() + "</pre>") + ("<textarea id=\"configText\">" + this.configFieldRegistry.makeCustomConfig() + "</textarea></div>");
		content += "</div>";
		this.currentCodeSample = codeSample;
		this.codeWasModified = false;
		let result = formatter_Formatter.format(formatter_FormatterInput.Code(codeSample),this.configFieldRegistry.currentConfig);
		switch(result._hx_index) {
		case 0:
			let formattedCode = result.formattedCode;
			content += "<div id=\"codeSampleContainer\"><textarea id=\"codeSample\">" + formattedCode + "</textarea></div>";
			break;
		case 1:
			let _g = result.errorMessage;
			break;
		case 2:
			break;
		}
		$(container).html(content);
		this.installConfigEventHandler();
		$("#codeSample").change($bind(this,this.onChangeCodeSample));
		$("#btnDownload").click($bind(this,this.onDownloadConfig));
		$("#btnApply").click($bind(this,this.onApplyConfig));
		$("#btnEdit").click($bind(this,this.onEditConfig));
		$("#configText").change($bind(this,this.onChangeConfig));
	}
	installConfigEventHandler() {
		$(".config-field-combo").change($bind(this,this.onChangeCombo));
		$(".config-field-bool").change($bind(this,this.onChangeBool));
		$(".config-field-bool-label").click($bind(this,this.onClickBoolLabel));
		$(".config-field-number").change($bind(this,this.onChangeNumber));
		$(".config-field-text").change($bind(this,this.onChangeText));
	}
	onChangeCombo(event) {
		let element = $(event.target);
		let fieldPath = element.data("field-path");
		let value = element.val();
		this.applyConfigValue(fieldPath,value);
		this.updateFormat();
	}
	onClickBoolLabel(event) {
		let element = $(event.target);
		let fieldPath = element.data("field-path");
		element = $("input[data-field-path=\"" + fieldPath + "\"]");
		element.prop("checked",!element.prop("checked"));
		let value = false;
		if(element.is(":checked")) {
			value = true;
		}
		$("label[data-field-path=\"" + fieldPath + "\"]").text(value);
		this.applyConfigValue(fieldPath,value);
		this.updateFormat();
	}
	onChangeBool(event) {
		let element = $(event.target);
		let fieldPath = element.data("field-path");
		let value = false;
		if(element.is(":checked")) {
			value = true;
		}
		$("label[data-field-path=\"" + fieldPath + "\"]").text(value);
		this.applyConfigValue(fieldPath,value);
		this.updateFormat();
	}
	onChangeNumber(event) {
		let element = $(event.target);
		let fieldPath = element.data("field-path");
		let value = element.val();
		this.applyConfigValue(fieldPath,value);
		this.updateFormat();
	}
	onChangeText(event) {
		let element = $(event.target);
		let fieldPath = element.data("field-path");
		let value = element.val();
		this.applyConfigValue(fieldPath,value);
		this.updateFormat();
	}
	onChangeCodeSample(event) {
		this.codeWasModified = true;
		this.updateFormat();
	}
	onDownloadConfig(event) {
		let jsonText = this.configFieldRegistry.makeCustomConfig();
		let blob = new Blob([jsonText],{ type : "application/json;charset=utf-8"});
		let hxformatUrl = URL.createObjectURL(blob);
		$("#downloadLink").attr({ "download" : "hxformat.json", "href" : hxformatUrl})[0].click();
		URL.revokeObjectURL(hxformatUrl);
	}
	onEditConfig(event) {
		$("#config").hide();
		let textElement = $("#configText");
		textElement.show();
		textElement.val(this.configFieldRegistry.makeCustomConfig());
		$("#btnEdit").hide();
		$("#btnApply").show();
	}
	onApplyConfig(event) {
		$("#config").show();
		$("#configText").hide();
		this.onChangeConfig(event);
		$("#config").html(this.configFieldRegistry.buildConfigHtml());
		$("#btnEdit").show();
		$("#btnApply").hide();
		this.updateFormat();
		this.installConfigEventHandler();
	}
	onChangeConfig(event) {
		let textElement = $("#configText");
		let newConfigText = textElement.val();
		try {
			this.configFieldRegistry.setCurrentSampleConfig(newConfigText);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
		}
		this.updateFormat();
		textElement.val(this.configFieldRegistry.makeCustomConfig());
	}
	applyConfigValue(fieldPath,value) {
		this.configFieldRegistry.setFieldValue(fieldPath,value);
		$global.console.info("setting " + fieldPath + " = " + (value == null ? "null" : Std.string(value)));
	}
	updateFormat() {
		let codeElement = $("#codeSample");
		let codeSample = codeElement.val();
		if(!this.codeWasModified) {
			codeSample = this.currentCodeSample;
		}
		let result = formatter_Formatter.format(formatter_FormatterInput.Code(codeSample),this.configFieldRegistry.currentConfig);
		switch(result._hx_index) {
		case 0:
			let formattedCode = result.formattedCode;
			codeElement.val(formattedCode);
			break;
		case 1:
			let errorMessage = result.errorMessage;
			$global.console.info("format failed: " + errorMessage);
			break;
		case 2:
			break;
		}
	}
}
$hxClasses["codesamples.SampleBase"] = codesamples_SampleBase;
codesamples_SampleBase.__name__ = "codesamples.SampleBase";
Object.assign(codesamples_SampleBase.prototype, {
	__class__: codesamples_SampleBase
	,currentCodeSample: null
	,codeWasModified: null
	,configFieldRegistry: null
});
class codesamples_CommonSamples extends codesamples_SampleBase {
	constructor() {
		super();
	}
	allman_curlies(container,configFieldRegistry) {
		this.buildDocSamplePage(container,"allman.curlies","probably the most searched for option of formatter :)\n\n> **Note**: `lineEnds.leftCurly` affects all left curlies, there are specialised options for\n> different curly places (e.g. `lineEnds.blockCurly`, `lineEnds.objectLiteralCurly`, etc.)\n> see [haxeflixel style sample](#codesamples.CommonSamples.haxeflixel_style)","{\n    \"lineEnds\": {\n        \"leftCurly\": \"both\",\n\t\t\"emptyCurly\": \"break\"\n    }\n}","","class Main {\n    public function new () {}\n\n    public function foo (param1:Int) {\n\t\ttrace(param1);\n\t\tvar obj = {\n\t\t\tx:100,\n\t\t\ty:100,\n\t\t\tz:100\n\t\t\t};\n\t}\n}\n",configFieldRegistry);
	}
	haxeflixel_style(container,configFieldRegistry) {
		this.buildDocSamplePage(container,"haxeflixel.style","formatter configuration used by HaxeFlixel\n","\n{\n\t\"lineEnds\": {\n\t\t\"leftCurly\": \"both\",\n\t\t\"rightCurly\": \"both\",\n\t\t\"objectLiteralCurly\": {\n\t\t\t\"leftCurly\": \"after\"\n\t\t}\n\t},\n\t\"sameLine\": {\n\t\t\"ifElse\": \"next\",\n\t\t\"doWhile\": \"next\",\n\t\t\"tryBody\": \"next\",\n\t\t\"tryCatch\": \"next\"\n\t}\n}","","class Main {\n    public function new () {}\n\n    public function foo (param1:Int) {\n\t\tvar obj = {\n\t\t\tx:100,\n\t\t\ty:100\n\t\t\t};\n\n\t\tdo {\n\t\t\tsomething();\n\t\t} while (true);\n\n\t\tif (true) {\n\t\t\tsomething();\n\t\t} else {\n\t\t\tdoNothing();\n\t\t}\n\n\t\ttry\tsomethingRisky(); catch (e:Excpetion)\n\t}\n}\n",configFieldRegistry);
	}
	indentation_with_space(container,configFieldRegistry) {
		this.buildDocSamplePage(container,"indentation.with.space","indentation character takes a string that is either any number of (literal) spaces (e.g. `␣␣`, `␣␣␣␣`, etc.) or the text `tab` for indentation with tabs","{\n    \"indentation\": {\n        \"character\": \"    \"\n    }\n}","","class Main {\n    public function new () {}\n\n    public function foo (param1:Int) {\n\t\ttrace(param1);\n\t}\n}\n",configFieldRegistry);
	}
}
$hxClasses["codesamples.CommonSamples"] = codesamples_CommonSamples;
codesamples_CommonSamples.__name__ = "codesamples.CommonSamples";
codesamples_CommonSamples.__super__ = codesamples_SampleBase;
Object.assign(codesamples_CommonSamples.prototype, {
	__class__: codesamples_CommonSamples
});
class codesamples_EmptylinesSamples extends codesamples_SampleBase {
	constructor() {
		super();
	}
	enum_abstract_emptylines(container,configFieldRegistry) {
		this.buildDocSamplePage(container,"enum_abstract_emptylines","","{\n\t\"emptyLines\" : {\n\t\t\"enumAbstractEmptyLines\": {\n\t\t\t\"beginType\": 0,\n\t\t\t\"endType\": 0,\n\t\t\t\"betweenVars\": 0,\n\t\t\t\"afterVars\": 1,\n\t\t\t\"betweenFunctions\": 1,\n\t\t\t\"existingBetweenFields\": \"keep\"\n\t\t},\n\t\t\"maxAnywhereInFile\": 1\n\t}\n}","","enum abstract EnumAbstract(String) {\n\tvar A;\n\tvar B;\n\tvar C;\n\n\tfunction new(s)\n\t\tthis = s;\n}\n\nenum abstract EnumAbstract(String) {\n\tfinal A;\n\tfinal B;\n\tfinal C;\n\n\tfunction new(s)\n\t\tthis = s;\n}\n",configFieldRegistry);
	}
	import_and_using_emptylines(container,configFieldRegistry) {
		this.buildDocSamplePage(container,"import.and.using.emptylines","showcases different empty lines settings for imports and using\n\ngoes great with VSCode's organise imports code action","{\n\t\"emptyLines\" : {\n\t\t\"importAndUsing\": {\n\t\t\t\"betweenImportsLevel\": \"firstLevelPackage\",\n\t\t\t\"betweenImports\": 1,\n\t\t\t\"beforeUsing\": 1\n\t\t},\n\t\t\"maxAnywhereInFile\": 1\n\t}\n}","","package formatter.marker;\n\nimport haxe.Int64;\nimport haxe.Json;\nimport haxe.macro.Expr;\nimport haxe.macro.ExprTools;\nimport formatter.codedata.CodeLine;\nimport formatter.codedata.CodeLines;\nimport formatter.codedata.data.Data;\nimport formatter.config.EmptyLinesConfig;\nimport formatter.marker.wrapping.marker.warpping.WrapBase;\nimport formatter.marker.wrapping.marker.warpping.WrapDefault;\nimport formatter.marker.wrapping.marker.indentation.Indenter;\nimport tokentree.utils.FieldUtils;\nusing haxe.Int64;\nusing haxe.Json;\nusing formatter.codedata.CodeLine;\nusing formatter.codedata.CodeLines;\nusing formatter.codedata.data.Data;\nusing formatter.config.EmptyLinesConfig;\nusing tokentree.utils.FieldUtils;\n#if php\nimport php.Lib;\nimport php.Web;\n#else\nimport sys.Lib;\n#end\nimport sys.FileSystem;\n#if !php\nimport sys.Lib;\n#else\nimport php.Lib;\nimport php.Web;\n#end\nimport sys.FileSystem;\n#if !php\nimport String;\n#end\n",configFieldRegistry);
	}
}
$hxClasses["codesamples.EmptylinesSamples"] = codesamples_EmptylinesSamples;
codesamples_EmptylinesSamples.__name__ = "codesamples.EmptylinesSamples";
codesamples_EmptylinesSamples.__super__ = codesamples_SampleBase;
Object.assign(codesamples_EmptylinesSamples.prototype, {
	__class__: codesamples_EmptylinesSamples
});
class codesamples_IndentationSamples extends codesamples_SampleBase {
	constructor() {
		super();
	}
	trailing_whitespace(container,configFieldRegistry) {
		this.buildDocSamplePage(container,"trailing.whitespace","adds whitespace to empty lines by copying indentation from previous line","{\n\t\"indentation\": {\n\t\t\"trailingWhitespace\": true\n\t}\n}","","package my.pack;\nimport haxe.Json;\nusing StringTools;\n\nclass Main {\n\tpublic static function test1() {\n\t\ttrace(i);\n\n\t\tif (true) {\n\t\t\ttrace(\"true\");\n\n\t\t\ttrace(\"true\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttrace(\"false\");\n\n\t\t\ttrace(\"false\");\n\t\t}\n\n\t\ttrace(i);\n\t}\n\n\tpublic static function test2()\n\t\ttrace(i);\n}\n\ntypedef MyType = Array<Main>;\n",configFieldRegistry);
	}
}
$hxClasses["codesamples.IndentationSamples"] = codesamples_IndentationSamples;
codesamples_IndentationSamples.__name__ = "codesamples.IndentationSamples";
codesamples_IndentationSamples.__super__ = codesamples_SampleBase;
Object.assign(codesamples_IndentationSamples.prototype, {
	__class__: codesamples_IndentationSamples
});
class codesamples_LineendsSamples extends codesamples_SampleBase {
	constructor() {
		super();
	}
}
$hxClasses["codesamples.LineendsSamples"] = codesamples_LineendsSamples;
codesamples_LineendsSamples.__name__ = "codesamples.LineendsSamples";
codesamples_LineendsSamples.__super__ = codesamples_SampleBase;
Object.assign(codesamples_LineendsSamples.prototype, {
	__class__: codesamples_LineendsSamples
});
class codesamples_SamelineSamples extends codesamples_SampleBase {
	constructor() {
		super();
	}
	blockless_function_body(container,configFieldRegistry) {
		this.buildDocSamplePage(container,"blockless.function.body","`keep` tries to keep linebreaks from input source","{\n\t\"sameLine\": {\n\t\t\"functionBody\": \"same\",\n\t\t\"anonFunctionBody\": \"same\"\n\t}\n}","","class Main {\n\tpublic static function test1() {\n\t\t// input has linebreaks\n\t\t[1, 2, 3].map(function()\n\t\t\ttrace(i));\n\t}\n\n\t// input has linebreaks\n\tpublic static function test2()\n\t\t[1, 2, 3].map(function()\n\t\t\ttrace(i));\n\n\tpublic static function test3() {\n\t\t// input has no linebreaks\n\t\t[1, 2, 3].map(function() trace(i));\n\t}\n\n\t// input has no linebreaks\n\tpublic static function test4() [1, 2, 3].map(function() trace(i))\n}\n",configFieldRegistry);
	}
}
$hxClasses["codesamples.SamelineSamples"] = codesamples_SamelineSamples;
codesamples_SamelineSamples.__name__ = "codesamples.SamelineSamples";
codesamples_SamelineSamples.__super__ = codesamples_SampleBase;
Object.assign(codesamples_SamelineSamples.prototype, {
	__class__: codesamples_SamelineSamples
});
class codesamples_WhitespaceSamples extends codesamples_SampleBase {
	constructor() {
		super();
	}
	colon_whitespace(container,configFieldRegistry) {
		this.buildDocSamplePage(container,"colon.whitespace","\n> **Note**: whitespace policies can be overruled by code parts preceeding or following a whitespace location,\n> because these code parts might have whitespace policies that contradict their neighbours.","{\n    \"whitespace\": {\n\t\t\"colonPolicy\": \"none\",\n\t\t\"caseColonPolicy\": \"onlyAfter\",\n\t\t\"objectFieldColonPolicy\": \"after\",\n\t\t\"typeHintColonPolicy\": \"none\",\n\t\t\"typeCheckColonPolicy\": \"around\",\n\t\t\"ternaryPolicy\": \"around\"\n    }\n}","","class Main {\n\tfunction test(param1:Int,param2:Array<String>, callback:(index:Int)->String) {\n\n\t\tswitch((param1:Float)) {\n\t\t\tcase _: doSomething();\n\t\t}\n\t\treturn {x:10, y:20, z:30}\n\t}\n\tfunction test2(param1:Int) {\n\t\treturn (param1 < 100)?true:false;\n\t}\n\tfunction foo():Void {\n\t\tfinal test:Void->Void = () -> trace(1);\n\t\tfinal test:() -> Void = () -> trace(1);\n\t\tfinal obj:{f: Int} = {f: 1};\n\t\tfinal obj:{f: {f: Int}} = {f: {f: 1}};\n\t\tfinal int:Int = 1;\n\t}\n}\n\nextern class TouchEvent extends Event {\n\tpublic function new(isTouchPointCanceled:Bool = false\n\t\t#if air, commandKey:Bool = false, controlKey:Bool = false, ?timestamp:Float,\n\t\t?touchIntent:TouchEventIntent, ?samples:flash.utils.ByteArray,\n\t\tisTouchPointCanceled:Bool = false #end);\n}\n\ntypedef Type = {f:Int}\ntypedef Type = {f:{f:Int}}\n\n",configFieldRegistry);
	}
	conditional_parens_detailed(container,configFieldRegistry) {
		this.buildDocSamplePage(container,"conditional.parens.detailed","The following whitespace settings were added in version 1.11.0 (all childs of `whitespace.parenConfig`):\n\n- `catchParens` - for `catch (expr)`\n- `ifConditionParens` - for `if (expr)`\n- `sharpConditionParens` - for `#if (expr)`\n- `switchConditionParens` - for `switch (expr)`\n- `whileConditionParens` - for `while (expr)`\n\nAll use the same structure as `whitespace.parenConfig.conditionParens` (see [conditional parens short](#codesamples.WhitespaceSamples.conditional_parens_short))\nand allow a finer control over whitespace settings for each location.\nThe new settings default to `null` which means `conditionParens` applies to all locations.\nIt also means you only have to set values for those locations where you want formatter to behave differently.\n\n> **Note**: Using `removeInnerWhenEmpty` is technically possible, but since code with an empty condtion expression\n> doesn't make sense and probably won't compile there isn't much use to it.","{\n\t\"whitespace\": {\n\t\t\"parenConfig\": {\n\t\t\t\"catchParens\": {\n\t\t\t\t\"openingPolicy\": \"onlyAfter\",\n\t\t\t\t\"closingPolicy\": \"before\"\n\t\t\t},\n\t\t\t\"ifConditionParens\": {\n\t\t\t\t\"openingPolicy\": \"onlyAfter\",\n\t\t\t\t\"closingPolicy\": \"before\"\n\t\t\t},\n\t\t\t\"sharpConditionParens\": {\n\t\t\t\t\"openingPolicy\": \"onlyAfter\",\n\t\t\t\t\"closingPolicy\": \"before\"\n\t\t\t},\n\t\t\t\"switchConditionParens\": {\n\t\t\t\t\"openingPolicy\": \"onlyAfter\",\n\t\t\t\t\"closingPolicy\": \"before\"\n\t\t\t},\n\t\t\t\"whileConditionParens\": {\n\t\t\t\t\"openingPolicy\": \"onlyAfter\",\n\t\t\t\t\"closingPolicy\": \"before\"\n\t\t\t}\n\t\t}\n\t}\n}","","class Main {\n\tstatic function main() {\n\t\ttry {\n\t\t\t#if (haxe_ver > 4.0)\n\t\t\t#end\n\n\t\t\tswitch (a) {\n\t\t\t\tdefault:\n\t\t\t\t\tv = (a + b);\n\t\t\t}\n\n\t\t\tif (a) {\n\t\t\t\tv = (a + b);\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tv = (a + b);\n\t\t\t}\n\n\t\t\tdo {\n\t\t\t\tv = (a + b);\n\t\t\t} while (true);\n\t\t} catch (e:Any)\n\t}\n}\n",configFieldRegistry);
	}
	conditional_parens_short(container,configFieldRegistry) {
		this.buildDocSamplePage(container,"conditional.parens.short","Whitespace policies for parens in `whitespace.parenConfig` as well as `whitespace.bracesConfig` for curly braces\nuse a data structure that has three fields for each of their locations:\n\n- `openingPolicy` - whitespace policy for opening parens or curly\n- `closingPolicy` - whitespace policy for closing parens or curly\n- `removeInnerWhenEmpty` - true when you want to remove inner whitespace when parens / curlies are empty\n\npolicy can be one of the following (element being either an opening or a closing parens / curly):\n\n- `none` - no whitespace before or after element\n- `before` - add whitespace before element\n- `noneBefore` - never add whitespace before element\n- `onlyBefore` - only add whitespace before element\n- `after` - add whitespace after element\n- `noneAfter` - never add whitespace after element\n- `onlyAfter` - only add whitespace after element\n- `around` - add whitespace before and after element\n\n> **Note**: whitespace policies can be overruled by code parts preceeding or following a whitespace location,\n> because these code parts might have whitespace policies that contradict their neighbours.","{\n\t\"whitespace\": {\n\t\t\"parenConfig\": {\n\t\t\t\"conditionParens\": {\n\t\t\t\t\"openingPolicy\": \"onlyAfter\",\n\t\t\t\t\"closingPolicy\": \"before\"\n\t\t\t}\n\t\t}\n\t}\n}","","class Main {\n\tstatic function main() {\n\t\ttry {\n\t\t\t#if (haxe_ver > 4.0)\n\t\t\t#end\n\n\t\t\tswitch (a) {\n\t\t\t\tdefault:\n\t\t\t\t\tv = (a + b);\n\t\t\t}\n\n\t\t\tif (a) {\n\t\t\t\tv = (a + b);\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tv = (a + b);\n\t\t\t}\n\n\t\t\tdo {\n\t\t\t\tv = (a + b);\n\t\t\t} while (true);\n\t\t} catch (e:Any)\n\t}\n}\n",configFieldRegistry);
	}
	function_parens(container,configFieldRegistry) {
		this.buildDocSamplePage(container,"function.parens","See [conditional parens short](#codesamples.WhitespaceSamples.conditional_parens_short) for details about structure and values.\n\n> **Note**: whitespace policies can be overruled by code parts preceeding or following a whitespace location,\n> because these code parts might have whitespace policies that contradict their neighbours.","{\n    \"whitespace\": {\n        \"parenConfig\": {\n            \"funcParamParens\": {\n                \"openingPolicy\": \"before\",\n                \"closingPolicy\": \"none\",\n                \"removeInnerWhenEmpty\": true\n            },\n\t\t\t\"anonFuncParamParens\": {\n                \"openingPolicy\": \"none\",\n                \"closingPolicy\": \"onlyAfter\",\n                \"removeInnerWhenEmpty\": true\n\t\t\t}\n        }\n    }\n}","","class Main {\n    function new () {}\n\n\tfunction test(param1:Int,param2:Array<String>, callback:(index:Int)->String, callback2:()->String) {\n\t\tparam2.push(callback(param1));\n\t}\n}\n",configFieldRegistry);
	}
	function_types_and_arrows(container,configFieldRegistry) {
		this.buildDocSamplePage(container,"function.types.and.arrows","\n> **Note**: whitespace policies can be overruled by code parts preceeding or following a whitespace location,\n> because these code parts might have whitespace policies that contradict their neighbours.","{\n    \"whitespace\": {\n\t\t\"arrowFunctionsPolicy\": \"around\",\n\t\t\"functionTypeHaxe3Policy\": \"none\",\n\t\t\"functionTypeHaxe4Policy\": \"around\"\n    }\n}","","typedef MyType = Bool->Void;\n\nclass Main {\n\tvar f = () -> if (false) 1 else 0;\n\tvar f = () ->trace(\"\");\n\tvar f = () -> {};\n\tvar f = arg-> {};\n\tvar f = (arg) -> {};\n\tvar f = (arg1:Int, arg2:String) -> {};\n\tfinal test:Void->Void = () -> trace(1);\n\tfinal test:() -> Void = () -> trace(1);\n\n\t// old function type syntax\n\tvar f:Void->Void;\n\tvar f:Int->String->Void;\n\tvar f:(Int->Int) ->Int->Int;\n\n\t// new function type syntax\n\tvar f:() ->Void;\n\tvar f:(Int) ->Int;\n\tvar f:(name:String) ->Void;\n\tvar f:(Int, String) ->Bool;\n\tvar f:(resolve:(value:Dynamic) ->Void, reject:(reason:Dynamic) ->Void) ->Void;\n}\n",configFieldRegistry);
	}
	type_parameter(container,configFieldRegistry) {
		this.buildDocSamplePage(container,"type.parameter","See [conditional parens short](#codesamples.WhitespaceSamples.conditional_parens_short) for details about values.\n\n> **Note**: whitespace policies can be overruled by code parts preceeding or following a whitespace location,\n> because these code parts might have whitespace policies that contradict their neighbours.","{\n  \"whitespace\": {\n    \"typeParamOpenPolicy\": \"after\",\n    \"typeParamClosePolicy\": \"before\"\n  }\n}","","typedef Type = Array< {key:Int} >;\n",configFieldRegistry);
	}
}
$hxClasses["codesamples.WhitespaceSamples"] = codesamples_WhitespaceSamples;
codesamples_WhitespaceSamples.__name__ = "codesamples.WhitespaceSamples";
codesamples_WhitespaceSamples.__super__ = codesamples_SampleBase;
Object.assign(codesamples_WhitespaceSamples.prototype, {
	__class__: codesamples_WhitespaceSamples
});
class codesamples_WrappingSamples extends codesamples_SampleBase {
	constructor() {
		super();
	}
	array_matrix_wrapping(container,configFieldRegistry) {
		this.buildDocSamplePage(container,"array.matrix.wrapping","wrapping arrays in matrix layout\n\narray wrapping only works on arrays that have an equal number of elements per line, so your input source code should already have a matrix shape\n\n> **Note**: `equalNumber` is not implemented yet","{\n\t\"wrapping\": {\n\t\t\"arrayMatrixWrap\": \"matrixWrapWithAlign\",\n\t\t\"arrayWrap\":  {\n\t\t\t\"defaultWrap\": \"fillLine\",\n\t\t\t\"defaultLocation\": \"afterLast\"\n\t\t},\n\t\t\"maxLineLength\": 100\n\t}\n}","","class Main {\n\tstatic function main() {\n\t\tsampleMapArray = [\n\t\t\t0, 1, 0, 1,\n\t\t\t1, 1, 1, 1,\n\t\t\t1, 0, 0, 1\n\t\t];\n\t\treturn [\n\t\t\t-1.0, -1.0, 0, 0,\n\t\t\t1.0, -1.0, 1, 0,\n\t\t\t-1.0,  1.0, 0, 1,\n\t\t\t1.0, -1.0, 1, 0,\n\t\t\t1.0,  1.0, 1, 1,\n\t\t\t-1.0,  1.0, 0, 1\n\t\t];\n\n\t\treturn [xAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t0,       0,       0,       1];\n\n\t\trotation =  [1, 0, 0, 0,\n\t\t\t0, Math.cos(alpha), -Math.sin(alpha),  0,\n\t\t\t0, Math.sin(alpha), Math.cos(alpha),   0,\n\t\t\t0, 0, 0, 1];\n\n\t\trotation =  [Math.cos(alpha), 0, Math.sin(alpha), 0,\n\t\t\t0, 1, 0,  0,\n\t\t\t-Math.sin(alpha), 0, Math.cos(alpha),   0,\n\t\t\t0, 0, 0, 1];\n\t}\n\n\tstatic var offsetAutoTile:Array<Int> =\n\t\t[\n\t\t\t0, 0, 0, 0, 2, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t11, 11, 0, 0, 13, 13, 0, 14, 0, 0, 0, 0, 18, 18, 0, 19,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t51, 51, 0, 0, 53, 53, 0, 54, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t62, 62, 0, 0, 64, 64, 0, 65, 0, 0, 0, 0, 69, 69, 0, 70,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t86, 86, 0, 0, 88, 88, 0, 89, 0, 0, 0, 0, 93, 93, 0, 94,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 159, 0, 0, 0, 162, 0, 163, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 172, 0, 0, 0, 175, 0, 176, 0, 0, 0, 0, 0, 181, 0, 182,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 199, 0, 0, 0, 202, 0, 203, 0, 0, 0, 0, 0, 208, 0, 209\n\t\t];\n}\n",configFieldRegistry);
	}
	case_pattern_wrapping(container,configFieldRegistry) {
		this.buildDocSamplePage(container,"case.pattern.wrapping","wrapping large amounts of case patterns\n\n> **Note**: `equalNumber` is not implemented yet","{\n\t\"wrapping\": {\n\t\t\"casePattern\": {\n\t\t\t\"defaultWrap\": \"fillLine\",\n\t\t\t\"defaultLocation\": \"beforeLast\"\n\t\t},\n\t\t\"maxLineLength\": 100\n\t}\n}","","class Main {\n\tstatic function main() {\n\t\tswitch (part.toLowerCase()) {\n\t\t\tcase \"__halt_compiler\" | \"abstract\" | \"and\" | \"array\" | \"as\" | \"break\" | \"callable\" | \"case\" | \"catch\" | \"class\" | \"clone\" | \"const\"\n\t\t\t\t| \"continue\" | \"declare\" | \"default\" | \"die\" | \"do\" | \"echo\" | \"else\" | \"elseif\" | \"empty\" | \"enddeclare\" | \"endfor\" | \"endforeach\" | \"endif\"\n\t\t\t\t| \"endswitch\" | \"endwhile\" | \"eval\" | \"exit\" | \"extends\" | \"final\" | \"finally\" | \"for\" | \"foreach\" | \"function\" | \"global\" | \"goto\" | \"if\"\n\t\t\t\t| \"implements\" | \"include\" | \"include_once\" | \"instanceof\" | \"insteadof\" | \"interface\" | \"isset\" | \"list\" | \"namespace\" | \"new\" | \"or\"\n\t\t\t\t| \"print\" | \"private\" | \"protected\" | \"public\" | \"require\" | \"require_once\" | \"return\" | \"static\" | \"switch\" | \"throw\" | \"trait\" | \"try\"\n\t\t\t\t| \"unset\" | \"use\" | \"var\" | \"while\" | \"xor\" | \"yield\" | \"__class__\" | \"__dir__\" | \"__file__\" | \"__function__\" | \"__line__\" | \"__method__\"\n\t\t\t\t| \"__trait__\" | \"__namespace__\" | \"int\" | \"float\" | \"bool\" | \"string\" | \"true\" | \"false\" | \"null\" | \"parent\" | \"void\" | \"iterable\" | \"object\":\n\t\t\t\tpart += '_hx';\n\t\t\tcase \"__halt_compiler\", \"abstract\", \"and\", \"array\", \"as\", \"break\", \"callable\", \"case\", \"catch\", \"class\", \"clone\", \"const\", \"continue\", \"declare\"\n\t\t\t\t, \"default\", \"die\", \"do\", \"echo\", \"else\", \"elseif\", \"empty\", \"enddeclare\", \"endfor\", \"endforeach\", \"endif\", \"endswitch\", \"endwhile\", \"eval\"\n\t\t\t\t, \"exit\", \"extends\", \"final\", \"finally\", \"for\", \"foreach\", \"function\", \"global\", \"goto\", \"if\", \"implements\", \"include\", \"include_once\"\n\t\t\t\t, \"instanceof\", \"insteadof\", \"interface\", \"isset\", \"list\", \"namespace\", \"new\", \"or\", \"print\", \"private\", \"protected\", \"public\", \"require\"\n\t\t\t\t, \"require_once\", \"return\", \"static\", \"switch\", \"throw\", \"trait\", \"try\", \"unset\", \"use\", \"var\", \"while\", \"xor\", \"yield\", \"__class__\"\n\t\t\t\t, \"__dir__\", \"__file__\", \"__function__\", \"__line__\", \"__method__\", \"__trait__\", \"__namespace__\", \"int\", \"float\", \"bool\", \"string\", \"true\"\n\t\t\t\t, \"false\", \"null\", \"parent\", \"void\", \"iterable\", \"object\":\n\t\t\t\tpart += '_hx';\n\t\t\tcase \"__halt_compiler\", \"abstract\" | \"and\", \"array\" | \"as\", \"break\" | \"callable\", \"case\" | \"catch\", \"class\" | \"clone\", \"const\" | \"continue\"\n\t\t\t\t, \"declare\" | \"default\", \"die\" | \"do\", \"echo\" | \"else\", \"elseif\" | \"empty\", \"enddeclare\" | \"endfor\", \"endforeach\" | \"endif\", \"endswitch\"\n\t\t\t\t| \"endwhile\", \"eval\" | \"exit\", \"extends\" | \"final\", \"finally\" | \"for\", \"foreach\" | \"function\", \"global\" | \"goto\", \"if\" | \"implements\"\n\t\t\t\t, \"include\" | \"include_once\", \"instanceof\" | \"insteadof\", \"interface\" | \"isset\", \"list\" | \"namespace\", \"new\" | \"or\", \"print\" | \"private\"\n\t\t\t\t, \"protected\" | \"public\", \"require\" | \"require_once\", \"return\" | \"static\", \"switch\" | \"throw\", \"trait\" | \"try\", \"unset\" | \"use\", \"var\"\n\t\t\t\t| \"while\", \"xor\" | \"yield\", \"__class__\" | \"__dir__\", \"__file__\" | \"__function__\", \"__line__\" | \"__method__\", \"__trait__\" | \"__namespace__\"\n\t\t\t\t, \"int\" | \"float\", \"bool\" | \"string\", \"true\" | \"false\", \"null\" | \"parent\", \"void\" | \"iterable\", \"object\":\n\t\t\t\tpart += '_hx';\n\t\t\tcase _:\n\t\t}\n\t}\n}\n",configFieldRegistry);
	}
	method_chain_wrapping(container,configFieldRegistry) {
		this.buildDocSamplePage(container,"method.chain.wrapping","wrapping chains of method calls\n\n> **Note**: `equalNumber` is not implemented yet","{\n\t\"wrapping\": {\n\t\t\"methodChain\": {\n\t\t\t\"defaultWrap\": \"onePerLine\",\n\t\t\t\"defaultLocation\": \"afterLast\",\n\t\t\t\"rules\": []\n\t\t},\n\t\t\"maxLineLength\": 110\n\t}\n}","","class Main {\n\tfunction main() {\n\t\towner.addEntity().addEntity().addEntity().addEntity().addEntity();\n\t\towner.addEntity() // test\n\t\t\t.addEntity().addEntity().addEntity().addEntity();\n\t\towner // test\n\t\t\t.addEntity().addEntity().addEntity().addEntity().addEntity();\n\t\towner.addEntity().addEntity().addEntity().addEntity().addEntity(); // test\n\t\towner.addEntity() // test\n\t\t\t.addEntity() // test\n\t\t\t.addEntity() // test\n\t\t\t.addEntity() // test\n\t\t\t.addEntity(); // test\n\n\t\tnew Entity() // test\n\t\t\t.addComponent(new PointerTap()) // test\n\t\t\t.addComponent(_sprite = FlumpAssets.getMovieSprite(\"mute_button\", LibraryName.INTERFACE))\n\t\t\t.addComponent(_sprite = FlumpAssets.getMovieSprite(\"mute_button\", LibraryName.INTERFACE))\n\t\t\t.addComponent(_sprite = FlumpAssets.getMovieSprite(\"mute_button\", LibraryName.INTERFACE))\n\t\t\t.addComponent(new PointerTap()); // test\n\t\tnew Entity().addComponent(new PointerTap()) // test\n\t\t\t.addComponent(_sprite = FlumpAssets.getMovieSprite(\"mute_button\", LibraryName.INTERFACE))\n\t\t\t.addComponent(_sprite = FlumpAssets.getMovieSprite(\"mute_button\", LibraryName.INTERFACE))\n\t\t\t.addComponent(_sprite = FlumpAssets.getMovieSprite(\"mute_button\", LibraryName.INTERFACE))\n\t\t\t.addComponent(new PointerTap()); // test\n\t\tnew Entity().addComponent(new PointerTap()) // test\n\t\t\t.addComponent(_sprite = FlumpAssets.getMovieSprite(\"mute_button\", LibraryName.INTERFACE))\n\t\t\t.addComponent(_sprite = FlumpAssets.getMovieSprite(\"mute_button\", LibraryName.INTERFACE))\n\t\t\t.addComponent(_sprite = FlumpAssets.getMovieSprite(\"mute_button\", LibraryName.INTERFACE))\n\t\t\t.addComponent(new PointerTap());\n\t\tnew Entity() // test\n\t\t\t.addComponent(new PointerTap()) // test\n\t\t\t.addComponent(_sprite = FlumpAssets.getMovieSprite(\"mute_button\", LibraryName.INTERFACE)) // test\n\t\t\t.addComponent(_sprite = FlumpAssets.getMovieSprite(\"mute_button\", LibraryName.INTERFACE)) // test\n\t\t\t.addComponent(_sprite = FlumpAssets.getMovieSprite(\"mute_button\", LibraryName.INTERFACE)) // test\n\t\t\t.addComponent(new PointerTap()); // test\n\t}\n}\n",configFieldRegistry);
	}
	operator_add_chain_wrapping(container,configFieldRegistry) {
		this.buildDocSamplePage(container,"operator.add.chain.wrapping","wrapping of +/- chains\n\n> **Note**: `equalNumber` is not implemented yet","{\n\t\"wrapping\": {\n\t\t\"opAddSubChain\": {\n\t\t\t\"defaultWrap\": \"fillLine\",\n\t\t\t\"defaultLocation\": \"beforeLast\",\n\t\t\t\"rules\": []\n\t\t},\n\t\t\"maxLineLength\": 100\n\t}\n}","","class Main {\n\tstatic function main() {\n\t\t\t\treturn\n                       1 * ((this[0] * this[5] - this[4] * this[1]) * (this[10] * this[15] - this[14] * this[11]) - (this[0] * this[9] - this[8] * this[1]) * (this[6] * this[15] - this[14] * this[7]) +\n                               (this[0] * this[13] - this[12] * this[1]) * (this[6] * this[11] - this[10] * this[7]) + (this[4] * this[9] - this[8] * this[5]) * (this[2] * this[15] - this[14] * this[3]) - (this[4] * this[13] - this[12] * this[5]) * (this[2] * this[11] - this[10] * this[3]) +\n                                       (this[8] * this[13] - this[12] * this[9]) * (this[2] * this[7] - this[6] * this[3]));\n\t}\n}\n",configFieldRegistry);
	}
}
$hxClasses["codesamples.WrappingSamples"] = codesamples_WrappingSamples;
codesamples_WrappingSamples.__name__ = "codesamples.WrappingSamples";
codesamples_WrappingSamples.__super__ = codesamples_SampleBase;
Object.assign(codesamples_WrappingSamples.prototype, {
	__class__: codesamples_WrappingSamples
});
class codesamples_config_ConfigFieldRegistry {
	constructor() {
		let _g = new haxe_ds_StringMap();
		_g.h["emptyLines.finalNewline"] = codesamples_config_ConfigFieldType.Bool;
		_g.h["emptyLines.maxAnywhereInFile"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.beforePackage"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.afterPackage"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.betweenTypes"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.betweenSingleLineTypes"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.afterFileHeaderComment"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.betweenMultilineComments"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.lineCommentsBetweenTypes"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("keep" , String),js_Boot.__cast("one" , String),js_Boot.__cast("none" , String)]);
		_g.h["emptyLines.lineCommentsBetweenFunctions"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("keep" , String),js_Boot.__cast("one" , String),js_Boot.__cast("none" , String)]);
		_g.h["emptyLines.beforeRightCurly"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("keep" , String),js_Boot.__cast("remove" , String)]);
		_g.h["emptyLines.afterLeftCurly"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("keep" , String),js_Boot.__cast("remove" , String)]);
		_g.h["emptyLines.afterReturn"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("keep" , String),js_Boot.__cast("remove" , String)]);
		_g.h["emptyLines.beforeBlocks"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("keep" , String),js_Boot.__cast("remove" , String)]);
		_g.h["emptyLines.afterBlocks"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("keep" , String),js_Boot.__cast("remove" , String)]);
		_g.h["emptyLines.importAndUsing.betweenImports"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.importAndUsing.betweenImportsLevel"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("all" , String),js_Boot.__cast("firstLevelPackage" , String),js_Boot.__cast("secondLevelPackage" , String),js_Boot.__cast("thirdLevelPackage" , String),js_Boot.__cast("fourthLevelPackage" , String),js_Boot.__cast("fifthLevelPackage" , String),js_Boot.__cast("fullPackage" , String)]);
		_g.h["emptyLines.importAndUsing.beforeUsing"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.importAndUsing.beforeType"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.enumAbstractEmptyLines.beginType"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.enumAbstractEmptyLines.endType"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.enumAbstractEmptyLines.betweenVars"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.enumAbstractEmptyLines.afterVars"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.enumAbstractEmptyLines.betweenFunctions"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.enumAbstractEmptyLines.existingBetweenFields"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("keep" , String),js_Boot.__cast("remove" , String)]);
		_g.h["emptyLines.classEmptyLines.beginType"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.classEmptyLines.endType"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.classEmptyLines.betweenStaticVars"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.classEmptyLines.afterStaticVars"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.classEmptyLines.afterPrivateVars"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.classEmptyLines.betweenVars"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.classEmptyLines.afterVars"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.classEmptyLines.afterStaticFunctions"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.classEmptyLines.betweenStaticFunctions"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.classEmptyLines.afterPrivateFunctions"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.classEmptyLines.betweenFunctions"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.classEmptyLines.existingBetweenFields"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("keep" , String),js_Boot.__cast("remove" , String)]);
		_g.h["emptyLines.macroClassEmptyLines.beginType"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.macroClassEmptyLines.endType"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.macroClassEmptyLines.betweenStaticVars"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.macroClassEmptyLines.afterStaticVars"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.macroClassEmptyLines.afterPrivateVars"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.macroClassEmptyLines.betweenVars"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.macroClassEmptyLines.afterVars"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.macroClassEmptyLines.afterStaticFunctions"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.macroClassEmptyLines.betweenStaticFunctions"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.macroClassEmptyLines.afterPrivateFunctions"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.macroClassEmptyLines.betweenFunctions"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.macroClassEmptyLines.existingBetweenFields"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("keep" , String),js_Boot.__cast("remove" , String)]);
		_g.h["emptyLines.abstractEmptyLines.beginType"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.abstractEmptyLines.endType"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.abstractEmptyLines.betweenStaticVars"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.abstractEmptyLines.afterStaticVars"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.abstractEmptyLines.afterPrivateVars"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.abstractEmptyLines.betweenVars"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.abstractEmptyLines.afterVars"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.abstractEmptyLines.afterStaticFunctions"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.abstractEmptyLines.betweenStaticFunctions"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.abstractEmptyLines.afterPrivateFunctions"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.abstractEmptyLines.betweenFunctions"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.abstractEmptyLines.existingBetweenFields"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("keep" , String),js_Boot.__cast("remove" , String)]);
		_g.h["emptyLines.externClassEmptyLines.beginType"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.externClassEmptyLines.endType"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.externClassEmptyLines.betweenVars"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.externClassEmptyLines.afterVars"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.externClassEmptyLines.betweenFunctions"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.externClassEmptyLines.existingBetweenFields"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("keep" , String),js_Boot.__cast("remove" , String)]);
		_g.h["emptyLines.interfaceEmptyLines.beginType"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.interfaceEmptyLines.endType"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.interfaceEmptyLines.betweenVars"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.interfaceEmptyLines.afterVars"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.interfaceEmptyLines.betweenFunctions"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.interfaceEmptyLines.existingBetweenFields"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("keep" , String),js_Boot.__cast("remove" , String)]);
		_g.h["emptyLines.enumEmptyLines.beginType"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.enumEmptyLines.endType"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.enumEmptyLines.betweenFields"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.enumEmptyLines.existingBetweenFields"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("keep" , String),js_Boot.__cast("remove" , String)]);
		_g.h["emptyLines.typedefEmptyLines.beginType"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.typedefEmptyLines.endType"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.typedefEmptyLines.betweenFields"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.typedefEmptyLines.existingBetweenFields"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("keep" , String),js_Boot.__cast("remove" , String)]);
		_g.h["emptyLines.conditionalsEmptyLines.afterIf"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.conditionalsEmptyLines.beforeElse"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.conditionalsEmptyLines.afterElse"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.conditionalsEmptyLines.beforeEnd"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.conditionalsEmptyLines.beforeError"] = codesamples_config_ConfigFieldType.Number;
		_g.h["emptyLines.conditionalsEmptyLines.afterError"] = codesamples_config_ConfigFieldType.Number;
		_g.h["indentation.conditionalPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("fixedZero" , String),js_Boot.__cast("fixedZeroIncrease" , String),js_Boot.__cast("fixedZeroIncreaseBlocks" , String),js_Boot.__cast("aligned" , String),js_Boot.__cast("alignedNestedIncrease" , String),js_Boot.__cast("alignedIncrease" , String),js_Boot.__cast("alignedDecrease" , String)]);
		_g.h["indentation.character"] = codesamples_config_ConfigFieldType.Text;
		_g.h["indentation.tabWidth"] = codesamples_config_ConfigFieldType.Number;
		_g.h["indentation.trailingWhitespace"] = codesamples_config_ConfigFieldType.Bool;
		_g.h["indentation.indentObjectLiteral"] = codesamples_config_ConfigFieldType.Bool;
		_g.h["indentation.indentComplexValueExpressions"] = codesamples_config_ConfigFieldType.Bool;
		_g.h["indentation.indentCaseLabels"] = codesamples_config_ConfigFieldType.Bool;
		_g.h["lineEnds.leftCurly"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("after" , String),js_Boot.__cast("before" , String),js_Boot.__cast("both" , String)]);
		_g.h["lineEnds.rightCurly"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("after" , String),js_Boot.__cast("both" , String)]);
		_g.h["lineEnds.emptyCurly"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("noBreak" , String),js_Boot.__cast("break" , String)]);
		_g.h["lineEnds.blockCurly.leftCurly"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("after" , String),js_Boot.__cast("before" , String),js_Boot.__cast("both" , String)]);
		_g.h["lineEnds.blockCurly.rightCurly"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("after" , String),js_Boot.__cast("both" , String)]);
		_g.h["lineEnds.blockCurly.emptyCurly"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("noBreak" , String),js_Boot.__cast("break" , String)]);
		_g.h["lineEnds.anonFunctionCurly.leftCurly"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("after" , String),js_Boot.__cast("before" , String),js_Boot.__cast("both" , String)]);
		_g.h["lineEnds.anonFunctionCurly.rightCurly"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("after" , String),js_Boot.__cast("both" , String)]);
		_g.h["lineEnds.anonFunctionCurly.emptyCurly"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("noBreak" , String),js_Boot.__cast("break" , String)]);
		_g.h["lineEnds.anonTypeCurly.leftCurly"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("after" , String),js_Boot.__cast("before" , String),js_Boot.__cast("both" , String)]);
		_g.h["lineEnds.anonTypeCurly.rightCurly"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("after" , String),js_Boot.__cast("both" , String)]);
		_g.h["lineEnds.anonTypeCurly.emptyCurly"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("noBreak" , String),js_Boot.__cast("break" , String)]);
		_g.h["lineEnds.objectLiteralCurly.leftCurly"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("after" , String),js_Boot.__cast("before" , String),js_Boot.__cast("both" , String)]);
		_g.h["lineEnds.objectLiteralCurly.rightCurly"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("after" , String),js_Boot.__cast("both" , String)]);
		_g.h["lineEnds.objectLiteralCurly.emptyCurly"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("noBreak" , String),js_Boot.__cast("break" , String)]);
		_g.h["lineEnds.typedefCurly.leftCurly"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("after" , String),js_Boot.__cast("before" , String),js_Boot.__cast("both" , String)]);
		_g.h["lineEnds.typedefCurly.rightCurly"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("after" , String),js_Boot.__cast("both" , String)]);
		_g.h["lineEnds.typedefCurly.emptyCurly"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("noBreak" , String),js_Boot.__cast("break" , String)]);
		_g.h["sameLine.ifBody"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("same" , String),js_Boot.__cast("next" , String),js_Boot.__cast("keep" , String)]);
		_g.h["sameLine.elseBody"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("same" , String),js_Boot.__cast("next" , String),js_Boot.__cast("keep" , String)]);
		_g.h["sameLine.ifElse"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("same" , String),js_Boot.__cast("next" , String),js_Boot.__cast("keep" , String)]);
		_g.h["sameLine.elseIf"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("same" , String),js_Boot.__cast("next" , String),js_Boot.__cast("keep" , String)]);
		_g.h["sameLine.expressionIf"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("same" , String),js_Boot.__cast("next" , String),js_Boot.__cast("keep" , String)]);
		_g.h["sameLine.expressionIfWithBlocks"] = codesamples_config_ConfigFieldType.Bool;
		_g.h["sameLine.forBody"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("same" , String),js_Boot.__cast("next" , String),js_Boot.__cast("keep" , String)]);
		_g.h["sameLine.whileBody"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("same" , String),js_Boot.__cast("next" , String),js_Boot.__cast("keep" , String)]);
		_g.h["sameLine.doWhileBody"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("same" , String),js_Boot.__cast("next" , String),js_Boot.__cast("keep" , String)]);
		_g.h["sameLine.doWhile"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("same" , String),js_Boot.__cast("next" , String),js_Boot.__cast("keep" , String)]);
		_g.h["sameLine.tryBody"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("same" , String),js_Boot.__cast("next" , String),js_Boot.__cast("keep" , String)]);
		_g.h["sameLine.catchBody"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("same" , String),js_Boot.__cast("next" , String),js_Boot.__cast("keep" , String)]);
		_g.h["sameLine.caseBody"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("same" , String),js_Boot.__cast("next" , String),js_Boot.__cast("keep" , String)]);
		_g.h["sameLine.tryCatch"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("same" , String),js_Boot.__cast("next" , String),js_Boot.__cast("keep" , String)]);
		_g.h["sameLine.expressionCase"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("same" , String),js_Boot.__cast("next" , String),js_Boot.__cast("keep" , String)]);
		_g.h["sameLine.expressionTry"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("same" , String),js_Boot.__cast("next" , String),js_Boot.__cast("keep" , String)]);
		_g.h["sameLine.functionBody"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("same" , String),js_Boot.__cast("next" , String),js_Boot.__cast("keep" , String)]);
		_g.h["sameLine.anonFunctionBody"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("same" , String),js_Boot.__cast("next" , String),js_Boot.__cast("keep" , String)]);
		_g.h["sameLine.returnBody"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("same" , String),js_Boot.__cast("next" , String),js_Boot.__cast("keep" , String)]);
		_g.h["sameLine.returnBodySingleLine"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("same" , String),js_Boot.__cast("next" , String),js_Boot.__cast("keep" , String)]);
		_g.h["sameLine.untypedBody"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("same" , String),js_Boot.__cast("next" , String),js_Boot.__cast("keep" , String)]);
		_g.h["whitespace.parenConfig.metadataParens.openingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.parenConfig.metadataParens.closingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.parenConfig.metadataParens.removeInnerWhenEmpty"] = codesamples_config_ConfigFieldType.Bool;
		_g.h["whitespace.parenConfig.funcParamParens.openingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.parenConfig.funcParamParens.closingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.parenConfig.funcParamParens.removeInnerWhenEmpty"] = codesamples_config_ConfigFieldType.Bool;
		_g.h["whitespace.parenConfig.anonFuncParamParens.openingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.parenConfig.anonFuncParamParens.closingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.parenConfig.anonFuncParamParens.removeInnerWhenEmpty"] = codesamples_config_ConfigFieldType.Bool;
		_g.h["whitespace.parenConfig.callParens.openingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.parenConfig.callParens.closingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.parenConfig.callParens.removeInnerWhenEmpty"] = codesamples_config_ConfigFieldType.Bool;
		_g.h["whitespace.parenConfig.conditionParens.openingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.parenConfig.conditionParens.closingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.parenConfig.conditionParens.removeInnerWhenEmpty"] = codesamples_config_ConfigFieldType.Bool;
		_g.h["whitespace.parenConfig.ifConditionParens.openingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.parenConfig.ifConditionParens.closingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.parenConfig.ifConditionParens.removeInnerWhenEmpty"] = codesamples_config_ConfigFieldType.Bool;
		_g.h["whitespace.parenConfig.switchConditionParens.openingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.parenConfig.switchConditionParens.closingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.parenConfig.switchConditionParens.removeInnerWhenEmpty"] = codesamples_config_ConfigFieldType.Bool;
		_g.h["whitespace.parenConfig.whileConditionParens.openingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.parenConfig.whileConditionParens.closingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.parenConfig.whileConditionParens.removeInnerWhenEmpty"] = codesamples_config_ConfigFieldType.Bool;
		_g.h["whitespace.parenConfig.sharpConditionParens.openingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.parenConfig.sharpConditionParens.closingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.parenConfig.sharpConditionParens.removeInnerWhenEmpty"] = codesamples_config_ConfigFieldType.Bool;
		_g.h["whitespace.parenConfig.catchParens.openingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.parenConfig.catchParens.closingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.parenConfig.catchParens.removeInnerWhenEmpty"] = codesamples_config_ConfigFieldType.Bool;
		_g.h["whitespace.parenConfig.forLoopParens.openingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.parenConfig.forLoopParens.closingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.parenConfig.forLoopParens.removeInnerWhenEmpty"] = codesamples_config_ConfigFieldType.Bool;
		_g.h["whitespace.parenConfig.expressionParens.openingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.parenConfig.expressionParens.closingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.parenConfig.expressionParens.removeInnerWhenEmpty"] = codesamples_config_ConfigFieldType.Bool;
		_g.h["whitespace.bracesConfig.blockBraces.openingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.bracesConfig.blockBraces.closingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.bracesConfig.blockBraces.removeInnerWhenEmpty"] = codesamples_config_ConfigFieldType.Bool;
		_g.h["whitespace.bracesConfig.typedefBraces.openingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.bracesConfig.typedefBraces.closingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.bracesConfig.typedefBraces.removeInnerWhenEmpty"] = codesamples_config_ConfigFieldType.Bool;
		_g.h["whitespace.bracesConfig.anonTypeBraces.openingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.bracesConfig.anonTypeBraces.closingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.bracesConfig.anonTypeBraces.removeInnerWhenEmpty"] = codesamples_config_ConfigFieldType.Bool;
		_g.h["whitespace.bracesConfig.objectLiteralBraces.openingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.bracesConfig.objectLiteralBraces.closingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.bracesConfig.objectLiteralBraces.removeInnerWhenEmpty"] = codesamples_config_ConfigFieldType.Bool;
		_g.h["whitespace.bracesConfig.unknownBraces.openingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.bracesConfig.unknownBraces.closingPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.bracesConfig.unknownBraces.removeInnerWhenEmpty"] = codesamples_config_ConfigFieldType.Bool;
		_g.h["whitespace.openingBracketPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.closingBracketPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.typeParamOpenPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.typeParamClosePolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.typeExtensionPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.commaPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.dotPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.colonPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.caseColonPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.objectFieldColonPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.typeHintColonPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.typeCheckColonPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.ternaryPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.semicolonPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.ifPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.doPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.whilePolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.forPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.switchPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.tryPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.catchPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.binopPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.intervalPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.arrowFunctionsPolicy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.functionTypeHaxe3Policy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.functionTypeHaxe4Policy"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("none" , String),js_Boot.__cast("before" , String),js_Boot.__cast("noneBefore" , String),js_Boot.__cast("onlyBefore" , String),js_Boot.__cast("after" , String),js_Boot.__cast("onlyAfter" , String),js_Boot.__cast("noneAfter" , String),js_Boot.__cast("around" , String)]);
		_g.h["whitespace.compressSuccessiveParenthesis"] = codesamples_config_ConfigFieldType.Bool;
		_g.h["whitespace.formatStringInterpolation"] = codesamples_config_ConfigFieldType.Bool;
		_g.h["whitespace.addLineCommentSpace"] = codesamples_config_ConfigFieldType.Bool;
		_g.h["wrapping.maxLineLength"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.arrayMatrixWrap"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("noMatrixWrap" , String),js_Boot.__cast("matrixWrapNoAlign" , String),js_Boot.__cast("matrixWrapWithAlign" , String)]);
		_g.h["wrapping.arrayWrap.defaultWrap"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.arrayWrap.defaultLocation"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.arrayWrap.defaultAdditionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.arrayWrap.rules[0].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.arrayWrap.rules[0].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.arrayWrap.rules[0].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.arrayWrap.rules[0].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.arrayWrap.rules[0].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.arrayWrap.rules[0].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.arrayWrap.rules[0].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.arrayWrap.rules[1].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.arrayWrap.rules[1].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.arrayWrap.rules[1].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.arrayWrap.rules[1].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.arrayWrap.rules[1].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.arrayWrap.rules[1].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.arrayWrap.rules[1].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.arrayWrap.rules[2].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.arrayWrap.rules[2].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.arrayWrap.rules[2].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.arrayWrap.rules[2].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.arrayWrap.rules[2].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.arrayWrap.rules[2].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.arrayWrap.rules[2].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.arrayWrap.rules[3].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.arrayWrap.rules[3].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.arrayWrap.rules[3].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.arrayWrap.rules[3].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.arrayWrap.rules[3].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.arrayWrap.rules[3].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.arrayWrap.rules[3].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.arrayWrap.rules[4].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.arrayWrap.rules[4].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.arrayWrap.rules[4].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.arrayWrap.rules[4].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.arrayWrap.rules[4].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.arrayWrap.rules[4].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.arrayWrap.rules[4].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.arrayWrap.rules[5].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.arrayWrap.rules[5].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.arrayWrap.rules[5].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.arrayWrap.rules[5].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.arrayWrap.rules[5].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.arrayWrap.rules[5].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.arrayWrap.rules[5].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.typeParameter.defaultWrap"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.typeParameter.defaultLocation"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.typeParameter.defaultAdditionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.typeParameter.rules[0].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.typeParameter.rules[0].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.typeParameter.rules[0].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.typeParameter.rules[0].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.typeParameter.rules[0].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.typeParameter.rules[0].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.typeParameter.rules[0].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.typeParameter.rules[1].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.typeParameter.rules[1].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.typeParameter.rules[1].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.typeParameter.rules[1].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.typeParameter.rules[1].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.typeParameter.rules[1].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.typeParameter.rules[1].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.typeParameter.rules[2].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.typeParameter.rules[2].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.typeParameter.rules[2].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.typeParameter.rules[2].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.typeParameter.rules[2].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.typeParameter.rules[2].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.typeParameter.rules[2].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.typeParameter.rules[3].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.typeParameter.rules[3].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.typeParameter.rules[3].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.typeParameter.rules[3].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.typeParameter.rules[3].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.typeParameter.rules[3].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.typeParameter.rules[3].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.typeParameter.rules[4].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.typeParameter.rules[4].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.typeParameter.rules[4].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.typeParameter.rules[4].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.typeParameter.rules[4].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.typeParameter.rules[4].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.typeParameter.rules[4].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.typeParameter.rules[5].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.typeParameter.rules[5].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.typeParameter.rules[5].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.typeParameter.rules[5].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.typeParameter.rules[5].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.typeParameter.rules[5].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.typeParameter.rules[5].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.functionSignature.defaultWrap"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.functionSignature.defaultLocation"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.functionSignature.defaultAdditionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.functionSignature.rules[0].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.functionSignature.rules[0].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.functionSignature.rules[0].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.functionSignature.rules[0].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.functionSignature.rules[0].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.functionSignature.rules[0].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.functionSignature.rules[0].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.functionSignature.rules[1].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.functionSignature.rules[1].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.functionSignature.rules[1].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.functionSignature.rules[1].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.functionSignature.rules[1].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.functionSignature.rules[1].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.functionSignature.rules[1].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.functionSignature.rules[2].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.functionSignature.rules[2].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.functionSignature.rules[2].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.functionSignature.rules[2].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.functionSignature.rules[2].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.functionSignature.rules[2].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.functionSignature.rules[2].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.functionSignature.rules[3].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.functionSignature.rules[3].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.functionSignature.rules[3].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.functionSignature.rules[3].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.functionSignature.rules[3].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.functionSignature.rules[3].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.functionSignature.rules[3].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.functionSignature.rules[4].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.functionSignature.rules[4].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.functionSignature.rules[4].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.functionSignature.rules[4].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.functionSignature.rules[4].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.functionSignature.rules[4].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.functionSignature.rules[4].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.functionSignature.rules[5].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.functionSignature.rules[5].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.functionSignature.rules[5].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.functionSignature.rules[5].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.functionSignature.rules[5].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.functionSignature.rules[5].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.functionSignature.rules[5].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonFunctionSignature.defaultWrap"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.anonFunctionSignature.defaultLocation"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.anonFunctionSignature.defaultAdditionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonFunctionSignature.rules[0].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.anonFunctionSignature.rules[0].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonFunctionSignature.rules[0].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.anonFunctionSignature.rules[0].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonFunctionSignature.rules[0].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.anonFunctionSignature.rules[0].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.anonFunctionSignature.rules[0].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonFunctionSignature.rules[1].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.anonFunctionSignature.rules[1].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonFunctionSignature.rules[1].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.anonFunctionSignature.rules[1].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonFunctionSignature.rules[1].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.anonFunctionSignature.rules[1].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.anonFunctionSignature.rules[1].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonFunctionSignature.rules[2].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.anonFunctionSignature.rules[2].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonFunctionSignature.rules[2].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.anonFunctionSignature.rules[2].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonFunctionSignature.rules[2].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.anonFunctionSignature.rules[2].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.anonFunctionSignature.rules[2].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonFunctionSignature.rules[3].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.anonFunctionSignature.rules[3].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonFunctionSignature.rules[3].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.anonFunctionSignature.rules[3].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonFunctionSignature.rules[3].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.anonFunctionSignature.rules[3].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.anonFunctionSignature.rules[3].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonFunctionSignature.rules[4].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.anonFunctionSignature.rules[4].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonFunctionSignature.rules[4].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.anonFunctionSignature.rules[4].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonFunctionSignature.rules[4].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.anonFunctionSignature.rules[4].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.anonFunctionSignature.rules[4].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonFunctionSignature.rules[5].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.anonFunctionSignature.rules[5].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonFunctionSignature.rules[5].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.anonFunctionSignature.rules[5].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonFunctionSignature.rules[5].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.anonFunctionSignature.rules[5].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.anonFunctionSignature.rules[5].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.callParameter.defaultWrap"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.callParameter.defaultLocation"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.callParameter.defaultAdditionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.callParameter.rules[0].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.callParameter.rules[0].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.callParameter.rules[0].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.callParameter.rules[0].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.callParameter.rules[0].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.callParameter.rules[0].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.callParameter.rules[0].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.callParameter.rules[1].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.callParameter.rules[1].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.callParameter.rules[1].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.callParameter.rules[1].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.callParameter.rules[1].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.callParameter.rules[1].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.callParameter.rules[1].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.callParameter.rules[2].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.callParameter.rules[2].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.callParameter.rules[2].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.callParameter.rules[2].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.callParameter.rules[2].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.callParameter.rules[2].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.callParameter.rules[2].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.callParameter.rules[3].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.callParameter.rules[3].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.callParameter.rules[3].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.callParameter.rules[3].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.callParameter.rules[3].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.callParameter.rules[3].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.callParameter.rules[3].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.callParameter.rules[4].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.callParameter.rules[4].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.callParameter.rules[4].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.callParameter.rules[4].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.callParameter.rules[4].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.callParameter.rules[4].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.callParameter.rules[4].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.callParameter.rules[5].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.callParameter.rules[5].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.callParameter.rules[5].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.callParameter.rules[5].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.callParameter.rules[5].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.callParameter.rules[5].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.callParameter.rules[5].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.metadataCallParameter.defaultWrap"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.metadataCallParameter.defaultLocation"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.metadataCallParameter.defaultAdditionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.metadataCallParameter.rules[0].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.metadataCallParameter.rules[0].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.metadataCallParameter.rules[0].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.metadataCallParameter.rules[0].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.metadataCallParameter.rules[0].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.metadataCallParameter.rules[0].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.metadataCallParameter.rules[0].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.metadataCallParameter.rules[1].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.metadataCallParameter.rules[1].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.metadataCallParameter.rules[1].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.metadataCallParameter.rules[1].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.metadataCallParameter.rules[1].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.metadataCallParameter.rules[1].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.metadataCallParameter.rules[1].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.metadataCallParameter.rules[2].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.metadataCallParameter.rules[2].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.metadataCallParameter.rules[2].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.metadataCallParameter.rules[2].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.metadataCallParameter.rules[2].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.metadataCallParameter.rules[2].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.metadataCallParameter.rules[2].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.metadataCallParameter.rules[3].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.metadataCallParameter.rules[3].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.metadataCallParameter.rules[3].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.metadataCallParameter.rules[3].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.metadataCallParameter.rules[3].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.metadataCallParameter.rules[3].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.metadataCallParameter.rules[3].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.metadataCallParameter.rules[4].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.metadataCallParameter.rules[4].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.metadataCallParameter.rules[4].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.metadataCallParameter.rules[4].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.metadataCallParameter.rules[4].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.metadataCallParameter.rules[4].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.metadataCallParameter.rules[4].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.metadataCallParameter.rules[5].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.metadataCallParameter.rules[5].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.metadataCallParameter.rules[5].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.metadataCallParameter.rules[5].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.metadataCallParameter.rules[5].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.metadataCallParameter.rules[5].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.metadataCallParameter.rules[5].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.objectLiteral.defaultWrap"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.objectLiteral.defaultLocation"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.objectLiteral.defaultAdditionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.objectLiteral.rules[0].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.objectLiteral.rules[0].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.objectLiteral.rules[0].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.objectLiteral.rules[0].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.objectLiteral.rules[0].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.objectLiteral.rules[0].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.objectLiteral.rules[0].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.objectLiteral.rules[1].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.objectLiteral.rules[1].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.objectLiteral.rules[1].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.objectLiteral.rules[1].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.objectLiteral.rules[1].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.objectLiteral.rules[1].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.objectLiteral.rules[1].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.objectLiteral.rules[2].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.objectLiteral.rules[2].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.objectLiteral.rules[2].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.objectLiteral.rules[2].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.objectLiteral.rules[2].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.objectLiteral.rules[2].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.objectLiteral.rules[2].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.objectLiteral.rules[3].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.objectLiteral.rules[3].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.objectLiteral.rules[3].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.objectLiteral.rules[3].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.objectLiteral.rules[3].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.objectLiteral.rules[3].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.objectLiteral.rules[3].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.objectLiteral.rules[4].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.objectLiteral.rules[4].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.objectLiteral.rules[4].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.objectLiteral.rules[4].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.objectLiteral.rules[4].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.objectLiteral.rules[4].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.objectLiteral.rules[4].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.objectLiteral.rules[5].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.objectLiteral.rules[5].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.objectLiteral.rules[5].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.objectLiteral.rules[5].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.objectLiteral.rules[5].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.objectLiteral.rules[5].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.objectLiteral.rules[5].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonType.defaultWrap"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.anonType.defaultLocation"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.anonType.defaultAdditionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonType.rules[0].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.anonType.rules[0].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonType.rules[0].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.anonType.rules[0].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonType.rules[0].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.anonType.rules[0].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.anonType.rules[0].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonType.rules[1].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.anonType.rules[1].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonType.rules[1].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.anonType.rules[1].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonType.rules[1].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.anonType.rules[1].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.anonType.rules[1].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonType.rules[2].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.anonType.rules[2].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonType.rules[2].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.anonType.rules[2].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonType.rules[2].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.anonType.rules[2].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.anonType.rules[2].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonType.rules[3].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.anonType.rules[3].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonType.rules[3].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.anonType.rules[3].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonType.rules[3].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.anonType.rules[3].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.anonType.rules[3].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonType.rules[4].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.anonType.rules[4].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonType.rules[4].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.anonType.rules[4].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonType.rules[4].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.anonType.rules[4].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.anonType.rules[4].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonType.rules[5].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.anonType.rules[5].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonType.rules[5].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.anonType.rules[5].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.anonType.rules[5].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.anonType.rules[5].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.anonType.rules[5].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.methodChain.defaultWrap"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.methodChain.defaultLocation"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.methodChain.defaultAdditionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.methodChain.rules[0].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.methodChain.rules[0].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.methodChain.rules[0].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.methodChain.rules[0].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.methodChain.rules[0].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.methodChain.rules[0].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.methodChain.rules[0].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.methodChain.rules[1].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.methodChain.rules[1].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.methodChain.rules[1].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.methodChain.rules[1].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.methodChain.rules[1].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.methodChain.rules[1].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.methodChain.rules[1].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.methodChain.rules[2].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.methodChain.rules[2].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.methodChain.rules[2].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.methodChain.rules[2].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.methodChain.rules[2].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.methodChain.rules[2].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.methodChain.rules[2].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.methodChain.rules[3].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.methodChain.rules[3].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.methodChain.rules[3].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.methodChain.rules[3].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.methodChain.rules[3].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.methodChain.rules[3].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.methodChain.rules[3].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.methodChain.rules[4].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.methodChain.rules[4].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.methodChain.rules[4].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.methodChain.rules[4].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.methodChain.rules[4].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.methodChain.rules[4].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.methodChain.rules[4].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.methodChain.rules[5].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.methodChain.rules[5].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.methodChain.rules[5].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.methodChain.rules[5].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.methodChain.rules[5].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.methodChain.rules[5].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.methodChain.rules[5].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opBoolChain.defaultWrap"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.opBoolChain.defaultLocation"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.opBoolChain.defaultAdditionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opBoolChain.rules[0].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.opBoolChain.rules[0].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opBoolChain.rules[0].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.opBoolChain.rules[0].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opBoolChain.rules[0].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.opBoolChain.rules[0].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.opBoolChain.rules[0].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opBoolChain.rules[1].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.opBoolChain.rules[1].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opBoolChain.rules[1].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.opBoolChain.rules[1].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opBoolChain.rules[1].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.opBoolChain.rules[1].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.opBoolChain.rules[1].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opBoolChain.rules[2].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.opBoolChain.rules[2].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opBoolChain.rules[2].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.opBoolChain.rules[2].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opBoolChain.rules[2].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.opBoolChain.rules[2].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.opBoolChain.rules[2].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opBoolChain.rules[3].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.opBoolChain.rules[3].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opBoolChain.rules[3].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.opBoolChain.rules[3].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opBoolChain.rules[3].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.opBoolChain.rules[3].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.opBoolChain.rules[3].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opBoolChain.rules[4].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.opBoolChain.rules[4].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opBoolChain.rules[4].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.opBoolChain.rules[4].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opBoolChain.rules[4].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.opBoolChain.rules[4].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.opBoolChain.rules[4].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opBoolChain.rules[5].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.opBoolChain.rules[5].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opBoolChain.rules[5].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.opBoolChain.rules[5].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opBoolChain.rules[5].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.opBoolChain.rules[5].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.opBoolChain.rules[5].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.implementsExtends.defaultWrap"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.implementsExtends.defaultLocation"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.implementsExtends.defaultAdditionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.implementsExtends.rules[0].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.implementsExtends.rules[0].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.implementsExtends.rules[0].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.implementsExtends.rules[0].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.implementsExtends.rules[0].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.implementsExtends.rules[0].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.implementsExtends.rules[0].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.implementsExtends.rules[1].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.implementsExtends.rules[1].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.implementsExtends.rules[1].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.implementsExtends.rules[1].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.implementsExtends.rules[1].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.implementsExtends.rules[1].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.implementsExtends.rules[1].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.implementsExtends.rules[2].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.implementsExtends.rules[2].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.implementsExtends.rules[2].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.implementsExtends.rules[2].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.implementsExtends.rules[2].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.implementsExtends.rules[2].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.implementsExtends.rules[2].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.implementsExtends.rules[3].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.implementsExtends.rules[3].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.implementsExtends.rules[3].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.implementsExtends.rules[3].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.implementsExtends.rules[3].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.implementsExtends.rules[3].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.implementsExtends.rules[3].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.implementsExtends.rules[4].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.implementsExtends.rules[4].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.implementsExtends.rules[4].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.implementsExtends.rules[4].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.implementsExtends.rules[4].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.implementsExtends.rules[4].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.implementsExtends.rules[4].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.implementsExtends.rules[5].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.implementsExtends.rules[5].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.implementsExtends.rules[5].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.implementsExtends.rules[5].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.implementsExtends.rules[5].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.implementsExtends.rules[5].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.implementsExtends.rules[5].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opAddSubChain.defaultWrap"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.opAddSubChain.defaultLocation"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.opAddSubChain.defaultAdditionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opAddSubChain.rules[0].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.opAddSubChain.rules[0].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opAddSubChain.rules[0].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.opAddSubChain.rules[0].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opAddSubChain.rules[0].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.opAddSubChain.rules[0].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.opAddSubChain.rules[0].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opAddSubChain.rules[1].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.opAddSubChain.rules[1].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opAddSubChain.rules[1].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.opAddSubChain.rules[1].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opAddSubChain.rules[1].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.opAddSubChain.rules[1].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.opAddSubChain.rules[1].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opAddSubChain.rules[2].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.opAddSubChain.rules[2].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opAddSubChain.rules[2].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.opAddSubChain.rules[2].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opAddSubChain.rules[2].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.opAddSubChain.rules[2].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.opAddSubChain.rules[2].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opAddSubChain.rules[3].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.opAddSubChain.rules[3].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opAddSubChain.rules[3].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.opAddSubChain.rules[3].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opAddSubChain.rules[3].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.opAddSubChain.rules[3].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.opAddSubChain.rules[3].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opAddSubChain.rules[4].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.opAddSubChain.rules[4].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opAddSubChain.rules[4].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.opAddSubChain.rules[4].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opAddSubChain.rules[4].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.opAddSubChain.rules[4].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.opAddSubChain.rules[4].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opAddSubChain.rules[5].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.opAddSubChain.rules[5].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opAddSubChain.rules[5].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.opAddSubChain.rules[5].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.opAddSubChain.rules[5].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.opAddSubChain.rules[5].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.opAddSubChain.rules[5].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.multiVar.defaultWrap"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.multiVar.defaultLocation"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.multiVar.defaultAdditionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.multiVar.rules[0].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.multiVar.rules[0].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.multiVar.rules[0].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.multiVar.rules[0].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.multiVar.rules[0].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.multiVar.rules[0].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.multiVar.rules[0].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.multiVar.rules[1].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.multiVar.rules[1].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.multiVar.rules[1].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.multiVar.rules[1].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.multiVar.rules[1].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.multiVar.rules[1].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.multiVar.rules[1].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.multiVar.rules[2].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.multiVar.rules[2].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.multiVar.rules[2].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.multiVar.rules[2].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.multiVar.rules[2].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.multiVar.rules[2].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.multiVar.rules[2].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.multiVar.rules[3].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.multiVar.rules[3].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.multiVar.rules[3].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.multiVar.rules[3].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.multiVar.rules[3].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.multiVar.rules[3].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.multiVar.rules[3].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.multiVar.rules[4].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.multiVar.rules[4].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.multiVar.rules[4].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.multiVar.rules[4].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.multiVar.rules[4].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.multiVar.rules[4].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.multiVar.rules[4].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.multiVar.rules[5].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.multiVar.rules[5].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.multiVar.rules[5].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.multiVar.rules[5].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.multiVar.rules[5].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.multiVar.rules[5].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.multiVar.rules[5].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.casePattern.defaultWrap"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.casePattern.defaultLocation"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.casePattern.defaultAdditionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.casePattern.rules[0].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.casePattern.rules[0].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.casePattern.rules[0].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.casePattern.rules[0].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.casePattern.rules[0].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.casePattern.rules[0].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.casePattern.rules[0].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.casePattern.rules[1].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.casePattern.rules[1].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.casePattern.rules[1].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.casePattern.rules[1].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.casePattern.rules[1].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.casePattern.rules[1].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.casePattern.rules[1].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.casePattern.rules[2].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.casePattern.rules[2].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.casePattern.rules[2].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.casePattern.rules[2].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.casePattern.rules[2].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.casePattern.rules[2].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.casePattern.rules[2].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.casePattern.rules[3].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.casePattern.rules[3].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.casePattern.rules[3].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.casePattern.rules[3].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.casePattern.rules[3].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.casePattern.rules[3].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.casePattern.rules[3].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.casePattern.rules[4].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.casePattern.rules[4].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.casePattern.rules[4].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.casePattern.rules[4].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.casePattern.rules[4].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.casePattern.rules[4].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.casePattern.rules[4].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.casePattern.rules[5].conditions[0].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.casePattern.rules[5].conditions[0].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.casePattern.rules[5].conditions[1].cond"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("itemCount >= n" , String),js_Boot.__cast("itemCount <= n" , String),js_Boot.__cast("anyItemLength >= n" , String),js_Boot.__cast("anyItemLength <= n" , String),js_Boot.__cast("totalItemLength >= n" , String),js_Boot.__cast("totalItemLength <= n" , String),js_Boot.__cast("lineLength >= n" , String),js_Boot.__cast("lineLength <= n" , String),js_Boot.__cast("hasMultilineItems" , String),js_Boot.__cast("exceedsMaxLineLength" , String)]);
		_g.h["wrapping.casePattern.rules[5].conditions[1].value"] = codesamples_config_ConfigFieldType.Number;
		_g.h["wrapping.casePattern.rules[5].type"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("onePerLine" , String),js_Boot.__cast("onePerLineAfterFirst" , String),js_Boot.__cast("equalNumber" , String),js_Boot.__cast("fillLine" , String),js_Boot.__cast("fillLineWithLeadingBreak" , String),js_Boot.__cast("noWrap" , String),js_Boot.__cast("keep" , String)]);
		_g.h["wrapping.casePattern.rules[5].location"] = codesamples_config_ConfigFieldType.Combo([js_Boot.__cast("beforeLast" , String),js_Boot.__cast("afterLast" , String)]);
		_g.h["wrapping.casePattern.rules[5].additionalIndent"] = codesamples_config_ConfigFieldType.Number;
		this.configFields = _g;
		this.currentConfig = new formatter_config_Config();
		this.configFieldValues = new haxe_ds_StringMap();
		let _g1 = haxe_ds_StringMap.kvIterator(this.configFields.h);
		while(_g1.hasNext()) {
			let _g11 = _g1.next();
			let fieldPath = _g11.key;
			let _ = _g11.value;
			let this1 = this.configFieldValues;
			let value = { defaultValue : this.getConfigFieldValue(this.currentConfig,fieldPath)};
			this1.h[fieldPath] = value;
		}
	}
	setCurrentSampleConfig(text) {
		if(text == null || text.length <= 0) {
			text = "{}";
		}
		this.sampleConfigText = text;
		this.sampleConfig = JSON.parse(text);
		this.currentConfig.readConfigFromString(this.sampleConfigText,"hxformat.json");
		let _g = haxe_ds_StringMap.kvIterator(this.configFields.h);
		while(_g.hasNext()) {
			let _g1 = _g.next();
			let fieldPath = _g1.key;
			let _ = _g1.value;
			this.configFieldValues.h[fieldPath].sampleValue = this.getConfigFieldValue(this.currentConfig,fieldPath);
		}
	}
	setFieldValue(fieldPath,value) {
		this.setConfigFieldValue(this.currentConfig,fieldPath,value);
	}
	setConfigFieldValue(object,fieldPath,value) {
		let parts = fieldPath.split(".");
		let fieldName = parts.pop();
		let _g = 0;
		while(_g < parts.length) {
			let part = parts[_g];
			++_g;
			object = Reflect.field(object,part);
		}
		if(object == null) {
			return;
		}
		object[fieldName] = value;
		this.configFieldValues.h[fieldPath].userValue = value;
	}
	getConfigFieldValue(object,fieldPath) {
		let parts = fieldPath.split(".");
		let fieldName = parts.pop();
		let _g = 0;
		while(_g < parts.length) {
			let part = parts[_g];
			++_g;
			object = Reflect.field(object,part);
		}
		return Reflect.field(object,fieldName);
	}
	makeCustomConfig() {
		let copyConfig = JSON.parse(JSON.stringify(this.sampleConfig));
		let _g = haxe_ds_StringMap.kvIterator(this.configFieldValues.h);
		while(_g.hasNext()) {
			let _g1 = _g.next();
			let fieldPath = _g1.key;
			let values = _g1.value;
			if(values.userValue == null) {
				continue;
			}
			this.setConfigFieldValue(copyConfig,fieldPath,values.userValue);
		}
		return JSON.stringify(copyConfig,null,"  ");
	}
	buildConfigHtml() {
		return "{\n" + this.buildConfigFields(this.sampleConfig,"    ","") + "\n}\n";
	}
	buildConfigFields(config,indent,fieldPath) {
		let lines = [];
		let _g = 0;
		let _g1 = Reflect.fields(config);
		while(_g < _g1.length) {
			let fieldName = _g1[_g];
			++_g;
			let field = Reflect.field(config,fieldName);
			let newPath = fieldName;
			if(fieldPath.length > 0) {
				newPath = fieldPath + "." + fieldName;
			}
			switch(typeof(field)) {
			case "boolean":case "number":case "string":
				lines.push(indent + fieldName + ": " + this.buildFieldValue(field,newPath) + ",");
				break;
			case "object":
				if(Array.isArray(field)) {
					lines.push(indent + fieldName + ": [");
					let arrayField = field;
					let _g = 0;
					let _g1 = arrayField.length;
					while(_g < _g1) {
						let index = _g++;
						lines.push(this.buildConfigFields(arrayField[index],indent + "    ",newPath + ("[" + index + "]")));
					}
					lines.push(indent + "],");
					continue;
				}
				lines.push(indent + fieldName + ": {");
				lines.push(this.buildConfigFields(field,indent + "    ",newPath));
				lines.push(indent + "},");
				break;
			default:
				console.log("src/codesamples/config/ConfigFieldRegistry.hx:116:","unhandled" + typeof(field));
			}
		}
		if(lines.length > 0) {
			let lastEntry = lines[lines.length - 1];
			if(StringTools.endsWith(lastEntry,",")) {
				lines[lines.length - 1] = HxOverrides.substr(lastEntry,0,lastEntry.length - 1);
			}
		}
		return lines.join("\n");
	}
	buildFieldValue(field,fieldPath) {
		if(Object.prototype.hasOwnProperty.call(this.configFields.h,fieldPath)) {
			return this.buildInputFieldValue(field,fieldPath);
		}
		let _g = Type.typeof(field);
		if(_g._hx_index == 6) {
			let s = _g.c;
			return "\"" + (field == null ? "null" : Std.string(field)) + "\"";
		} else {
			return "" + (field == null ? "null" : Std.string(field));
		}
	}
	buildInputFieldValue(field,fieldPath) {
		let _g = this.configFields.h[fieldPath];
		switch(_g._hx_index) {
		case 0:
			let abstractValues = _g.abstractValues;
			let combo = "<select class=\"config-field-combo\" data-field-path=\"" + fieldPath + "\">";
			let _g1 = 0;
			while(_g1 < abstractValues.length) {
				let option = abstractValues[_g1];
				++_g1;
				let selected = "";
				if(option == "" + (field == null ? "null" : Std.string(field))) {
					selected = " selected";
				}
				combo += "<option value=\"" + option + "\"" + selected + ">" + option + "</option>";
			}
			combo += "</select>";
			return combo;
		case 1:
			return "<input type=\"number\" value=\"" + (field == null ? "null" : Std.string(field)) + "\" class=\"config-field-number\" data-field-path=\"" + fieldPath + "\" />";
		case 2:
			let checked = "";
			let label = "false";
			if("" + (field == null ? "null" : Std.string(field)) == "true") {
				checked = "checked";
				label = "true";
			}
			return "<input type=\"checkbox\" value=\"1\" class=\"config-field-bool\" data-field-path=\"" + fieldPath + "\" " + checked + "/>" + ("<label class=\"config-field-bool-label\" data-field-path=\"" + fieldPath + "\">" + label + "</label>");
		case 3:
			return "<input type=\"text\" value=\"" + (field == null ? "null" : Std.string(field)) + "\" class=\"config-field-text\" data-field-path=\"" + fieldPath + "\" />";
		}
	}
}
$hxClasses["codesamples.config.ConfigFieldRegistry"] = codesamples_config_ConfigFieldRegistry;
codesamples_config_ConfigFieldRegistry.__name__ = "codesamples.config.ConfigFieldRegistry";
Object.assign(codesamples_config_ConfigFieldRegistry.prototype, {
	__class__: codesamples_config_ConfigFieldRegistry
	,configFields: null
	,configFieldValues: null
	,sampleConfig: null
	,sampleConfigText: null
	,currentConfig: null
});
var codesamples_config_ConfigFieldType = $hxEnums["codesamples.config.ConfigFieldType"] = { __ename__ : true, __constructs__ : ["Combo","Number","Bool","Text"]
	,Combo: ($_=function(abstractValues) { return {_hx_index:0,abstractValues:abstractValues,__enum__:"codesamples.config.ConfigFieldType",toString:$estr}; },$_.__params__ = ["abstractValues"],$_)
	,Number: {_hx_index:1,__enum__:"codesamples.config.ConfigFieldType",toString:$estr}
	,Bool: {_hx_index:2,__enum__:"codesamples.config.ConfigFieldType",toString:$estr}
	,Text: {_hx_index:3,__enum__:"codesamples.config.ConfigFieldType",toString:$estr}
};
class doc_DocBase {
	buildDocPage(container,docName,docText) {
		let content = "<h1>" + StringTools.replace(docName,"."," ") + "</h1>\n";
		content += "<div id=\"markdownContainer\">" + Markdown.markdownToHtml(docText) + "</div>";
		$(container).html(content);
	}
}
$hxClasses["doc.DocBase"] = doc_DocBase;
doc_DocBase.__name__ = "doc.DocBase";
Object.assign(doc_DocBase.prototype, {
	__class__: doc_DocBase
});
class doc_Docs extends doc_DocBase {
	constructor() {
		super();
	}
	compile_dev_version(container) {
		this.buildDocPage(container,"compile.dev.version","### compile command line version (Haxe 4)\n\n- `git clone https://github.com/HaxeCheckstyle/haxe-formatter.git`\n- `cd haxe-formatter`\n- `npm install`\n- `npx lix download`\n- `npx haxe buildAll.hxml` - for Neko, NodeJS and Java version + JSON schema\n- `npx haxe buildCpp.hxml` - for C++ version\n\n### compile command line version (Haxe 3)\n\n- `git clone https://github.com/HaxeCheckstyle/haxe-formatter.git`\n- `cd haxe-formatter`\n- `npm install`\n- `mv haxe_libraries haxe4_libraries`\n- `mv haxe3_libraries haxe_libraries`\n- `npx lix install haxe 3.4.7`\n- `npx lix download`\n- `npx haxe buildAll.hxml` - for Neko, NodeJS and Java version + JSON schema\n- `npx haxe buildCpp.hxml` - for C++ version\n\n### compile haxe-language server\n\n- `git clone https://github.com/vshaxe/haxe-languageserver.git`\n- `cd haxe-languageserver`\n- `npm install`\n- `npx lix download`\n- `npx lix install gh:HaxeCheckstyle/tokentree`\n- `npx lix install gh:HaxeCheckstyle/haxe-formatter`\n- `npx lix run vshaxe-build --target language-server`\n- `cp bin/server.js ~/.vscode/extensions/nadako.vshaxe-$VSHAXE_VERSION/server/bin/` - replace `$VSHAXE_VERSION` with actual version (assuming you have it installed)\n- restart Haxe language server or restart VSCode\n\n> **Note**: You will have to replace `server.js` whenever there is a new marketplace release, since it will wipe your `~/.vscode/extensions/nadako.vshaxe-$VSHAXE_VERSION` folder.\n");
	}
}
$hxClasses["doc.Docs"] = doc_Docs;
doc_Docs.__name__ = "doc.Docs";
doc_Docs.__super__ = doc_DocBase;
Object.assign(doc_Docs.prototype, {
	__class__: doc_Docs
});
class formatter_FormatStats {
}
$hxClasses["formatter.FormatStats"] = formatter_FormatStats;
formatter_FormatStats.__name__ = "formatter.FormatStats";
var formatter_Result = $hxEnums["formatter.Result"] = { __ename__ : true, __constructs__ : ["Success","Failure","Disabled"]
	,Success: ($_=function(formattedCode) { return {_hx_index:0,formattedCode:formattedCode,__enum__:"formatter.Result",toString:$estr}; },$_.__params__ = ["formattedCode"],$_)
	,Failure: ($_=function(errorMessage) { return {_hx_index:1,errorMessage:errorMessage,__enum__:"formatter.Result",toString:$estr}; },$_.__params__ = ["errorMessage"],$_)
	,Disabled: {_hx_index:2,__enum__:"formatter.Result",toString:$estr}
};
class formatter_Formatter {
	static format(input,config,lineSeparator,entryPoint,range) {
		if(config == null) {
			config = new formatter_config_Config();
		}
		let inputData;
		switch(input._hx_index) {
		case 0:
			let code = input.code;
			let content = haxe_io_Bytes.ofString(code);
			inputData = { fileName : "code snippet", content : content, config : config, lineSeparator : lineSeparator, entryPoint : entryPoint, range : range};
			return formatter_Formatter.formatInputData(inputData);
		case 1:
			let code1 = input.code;
			let tokenTree = input.tokenTree;
			let tokenList = input.tokenList;
			inputData = { fileName : "<unknown.hx>", content : code1, tokenList : tokenList, tokenTree : tokenTree, config : config, lineSeparator : lineSeparator, entryPoint : entryPoint, range : range};
			return formatter_Formatter.formatInputData(inputData);
		}
	}
	static formatInputData(inputData) {
		try {
			let config = inputData.config;
			if(config.disableFormatting) {
				return formatter_Result.Disabled;
			}
			if(config.isExcluded(inputData.fileName)) {
				return formatter_Result.Disabled;
			}
			tokentree_TokenStream.MODE = tokentree_TokenStreamMode.Relaxed;
			let parsedCode = new formatter_codedata_ParsedCode(inputData);
			formatter_FormatStats.totalLinesOrig += parsedCode.lines.length;
			let indenter = new formatter_marker_Indenter(config.indentation);
			indenter.setParsedCode(parsedCode);
			let markTokenText = new formatter_marker_MarkTokenText(config,parsedCode,indenter);
			let markWhitespace = new formatter_marker_MarkWhitespace(config,parsedCode,indenter);
			let markLineEnds = new formatter_marker_MarkLineEnds(config,parsedCode,indenter);
			let markSameLine = new formatter_marker_MarkSameLine(config,parsedCode,indenter);
			let markWrapping = new formatter_marker_wrapping_MarkWrapping(config,parsedCode,indenter);
			let markEmptyLines = new formatter_marker_MarkEmptyLines(config,parsedCode,indenter);
			let markAdditionalIndent = new formatter_marker_MarkAdditionalIndentation(config,parsedCode,indenter);
			markTokenText.run();
			markWhitespace.run();
			markLineEnds.run();
			markSameLine.run();
			markWrapping.run();
			markEmptyLines.run();
			markTokenText.finalRun();
			markAdditionalIndent.run();
			let lines = new formatter_codedata_CodeLines(parsedCode,indenter,inputData.range);
			lines.applyWrapping(config.wrapping);
			markEmptyLines.finalRun(lines);
			let formatted = lines.print(parsedCode.lineSeparator);
			formatter_FormatStats.totalLinesFormatted += formatted.split(parsedCode.lineSeparator).length;
			return formatter_Result.Success(formatted);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			let e = haxe_Exception.caught(_g).unwrap();
			let callstack = haxe_CallStack.toString(haxe_CallStack.exceptionStack());
			return formatter_Result.Failure((e == null ? "null" : Std.string(e)) + "\n" + callstack + "\n\n");
		}
	}
}
$hxClasses["formatter.Formatter"] = formatter_Formatter;
formatter_Formatter.__name__ = "formatter.Formatter";
var formatter_FormatterInput = $hxEnums["formatter.FormatterInput"] = { __ename__ : true, __constructs__ : ["Code","Tokens"]
	,Code: ($_=function(code) { return {_hx_index:0,code:code,__enum__:"formatter.FormatterInput",toString:$estr}; },$_.__params__ = ["code"],$_)
	,Tokens: ($_=function(tokenList,tokenTree,code) { return {_hx_index:1,tokenList:tokenList,tokenTree:tokenTree,code:code,__enum__:"formatter.FormatterInput",toString:$estr}; },$_.__params__ = ["tokenList","tokenTree","code"],$_)
};
class formatter_codedata_CodeLine {
	constructor(indent) {
		this.indent = indent;
		this.parts = [];
		this.emptyLinesAfter = 0;
		this.verbatim = false;
		this.partialLine = false;
	}
	addToken(tokenInfo,lineSeparator) {
		if(tokenInfo.emptyLinesAfter > this.emptyLinesAfter) {
			this.emptyLinesAfter = tokenInfo.emptyLinesAfter;
		}
		if(this.currentPart == null) {
			this.currentPart = { firstToken : tokenInfo.token, lastToken : tokenInfo.token, text : "", multiLine : false, firstLineLength : -1, lastLineLength : -1};
			this.parts.push(this.currentPart);
		}
		this.currentPart.lastToken = tokenInfo.token;
		if(tokenInfo.spacesBefore > 0) {
			this.currentPart.text += StringTools.lpad(""," ",tokenInfo.spacesBefore);
		}
		if(tokenInfo.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Space && tokenInfo.spacesAfter > 0) {
			this.currentPart.text += tokenInfo.text + StringTools.lpad(""," ",tokenInfo.spacesAfter);
		} else {
			this.currentPart.text += tokenInfo.text;
		}
		if(tokenInfo.wrapAfter) {
			this.currentPart = null;
		}
	}
	applyWrapping(config,parsedCode,indenter) {
		let lineLength = indenter.calcAbsoluteIndent(this.indent);
		let _g = 0;
		let _g1 = this.parts;
		while(_g < _g1.length) {
			let part = _g1[_g];
			++_g;
			this.calcLineLengths(part,parsedCode.lineSeparator);
		}
		let _g2 = 0;
		let _g3 = this.parts.length;
		while(_g2 < _g3) {
			let index = _g2++;
			let part = this.parts[index];
			if(part.multiLine) {
				if(lineLength + part.firstLineLength > config.maxLineLength) {
					return this.wrappedAt(index,config,parsedCode,indenter);
				}
				lineLength = part.lastLineLength;
				continue;
			}
			lineLength += part.text.length;
			if(lineLength > config.maxLineLength) {
				return this.wrappedAt(index,config,parsedCode,indenter);
			}
		}
		return [this];
	}
	calcLineLengths(part,lineSeparator) {
		let lines = part.text.split(lineSeparator);
		part.multiLine = lines.length > 1;
		if(part.multiLine) {
			part.firstLineLength = lines[0].length;
			part.lastLineLength = lines[lines.length - 1].length;
		} else {
			part.firstLineLength = part.text.length;
			part.lastLineLength = -1;
		}
	}
	wrappedAt(index,config,parsedCode,indenter) {
		return this.wrapNormal(config,parsedCode,indenter);
	}
	wrapNormal(config,parsedCode,indenter) {
		if(this.parts.length <= 0) {
			return [this];
		}
		let line = new formatter_codedata_CodeLine(this.indent);
		let part = this.parts.shift();
		line.parts = [part];
		let lineLength = indenter.calcAbsoluteIndent(this.indent) + part.text.length;
		let lines = [line];
		let lastPart = part;
		while(this.parts.length > 0) {
			let p = this.parts.shift();
			let partLength = p.firstLineLength;
			if(!p.multiLine) {
				partLength = StringTools.rtrim(p.text).length;
			}
			if(lineLength + partLength >= config.maxLineLength) {
				parsedCode.tokenList.lineEndAfter(lastPart.lastToken);
				let info = parsedCode.tokenList.getTokenAt(p.firstToken.index);
				let additionalIndent = 0;
				if(info != null) {
					additionalIndent = info.additionalIndent;
				}
				let newIndent = indenter.calcIndent(p.firstToken) + additionalIndent;
				line = new formatter_codedata_CodeLine(newIndent);
				lineLength = indenter.calcAbsoluteIndent(newIndent);
				lines.push(line);
			}
			line.parts.push(p);
			if(p.lastLineLength <= 0) {
				lineLength += p.firstLineLength;
			} else {
				lineLength += p.lastLineLength;
			}
			lastPart = p;
		}
		line.emptyLinesAfter = this.emptyLinesAfter;
		return lines;
	}
	print(indenter,lineSeparator) {
		let line = "";
		let _g = 0;
		let _g1 = this.parts;
		while(_g < _g1.length) {
			let part = _g1[_g];
			++_g;
			line += part.text;
		}
		if(this.partialLine) {
			line = indenter.makeIndentString(this.indent) + line;
		} else {
			line = indenter.makeIndentString(this.indent) + StringTools.rtrim(line);
		}
		let _g2 = 0;
		let _g3 = this.emptyLinesAfter;
		while(_g2 < _g3) {
			let index = _g2++;
			line += lineSeparator;
			if(indenter.shouldAddTrailingWhitespace()) {
				line += indenter.makeIndentString(this.indent);
			}
		}
		return line;
	}
}
$hxClasses["formatter.codedata.CodeLine"] = formatter_codedata_CodeLine;
formatter_codedata_CodeLine.__name__ = "formatter.codedata.CodeLine";
Object.assign(formatter_codedata_CodeLine.prototype, {
	__class__: formatter_codedata_CodeLine
	,parts: null
	,currentPart: null
	,indent: null
	,emptyLinesAfter: null
	,verbatim: null
	,partialLine: null
});
class formatter_codedata_CodeLines {
	constructor(parsedCode,indenter,range) {
		this.lines = [];
		this.indenter = indenter;
		this.parsedCode = parsedCode;
		this.range = null;
		this.posRange = range;
		this.trailingWhitespaceAfterRange = "";
		this.rangeStartOffset = 0;
		this.rangeEndOffset = 0;
		if(range != null) {
			let start = parsedCode.tokenList.getTokenAtOffset(range.startPos);
			let end = parsedCode.tokenList.getTokenAtOffset(range.endPos);
			if(end != null && range.endPos - 1 < end.token.pos.min) {
				end = parsedCode.tokenList.getPreviousToken(end.token);
			}
			if(start != null && end != null) {
				let _g = start.token.tok;
				if(_g._hx_index == 7) {
					let s = _g.s;
					this.rangeStartOffset = this.calcStartCommentOffset(start);
				} else {
					let startLine = parsedCode.getLinePos(start.token.pos.min);
					let rangeStartLine = parsedCode.getLinePos(range.startPos);
					let endLine = parsedCode.getLinePos(start.token.pos.max);
					if(startLine.line != rangeStartLine.line) {
						this.rangeStartOffset = range.startPos - rangeStartLine.ofs - start.token.pos.min;
					}
				}
				let _g1 = end.token.tok;
				if(_g1._hx_index == 7) {
					let s = _g1.s;
					this.rangeEndOffset = this.calcEndCommentOffset(end);
				} else if(this.posRange.endPos >= end.token.pos.min && this.posRange.endPos < end.token.pos.max) {
					this.rangeEndOffset = end.text.length - (end.token.pos.max - this.posRange.endPos);
				}
				this.range = { startPos : start.token.index, endPos : end.token.index};
			}
		}
		this.buildLines();
	}
	calcStartCommentOffset(info) {
		let comment = this.parsedCode.getString(info.token.pos.min,info.token.pos.max);
		let commentLines = comment.split(this.parsedCode.lineSeparator);
		let index = 0;
		let offset = 0;
		let sepLength = this.parsedCode.lineSeparator.length;
		let pos = this.posRange.startPos - info.token.pos.min;
		let _g = 0;
		while(_g < commentLines.length) {
			let line = commentLines[_g];
			++_g;
			if(line.length + offset + sepLength > pos) {
				break;
			}
			offset += line.length + sepLength;
			++index;
		}
		commentLines = info.text.split(this.parsedCode.lineSeparator);
		offset = 0;
		let _g1 = 0;
		let _g2 = index;
		while(_g1 < _g2) {
			let j = _g1++;
			offset += commentLines[j].length + sepLength;
		}
		return offset;
	}
	calcEndCommentOffset(info) {
		let comment = this.parsedCode.getString(info.token.pos.min,info.token.pos.max);
		let commentLines = comment.split(this.parsedCode.lineSeparator);
		let index = 0;
		let offset = 0;
		let trailCount = 0;
		let pos = this.posRange.endPos - info.token.pos.min;
		let sepLength = this.parsedCode.lineSeparator.length;
		let _g = 0;
		while(_g < commentLines.length) {
			let line = commentLines[_g];
			++_g;
			if(line.length + offset + sepLength > pos) {
				trailCount = line.length - (pos - offset);
				break;
			}
			offset += line.length + sepLength;
			++index;
		}
		commentLines = info.text.split(this.parsedCode.lineSeparator);
		offset = 0;
		let _g1 = 0;
		let _g2 = index;
		while(_g1 < _g2) {
			let j = _g1++;
			offset += commentLines[j].length + sepLength;
		}
		let lastLine = commentLines[index];
		return offset + lastLine.length - trailCount;
	}
	buildLines() {
		let line = null;
		let index = 0;
		while(index < this.parsedCode.tokenList.tokens.length) {
			if(this.range != null) {
				if(index > this.range.endPos) {
					break;
				}
			}
			let tokenInfo = this.parsedCode.tokenList.getTokenAt(index);
			if(tokenInfo == null) {
				++index;
				continue;
			}
			let _g = tokenInfo.token.tok;
			if(_g._hx_index == 8) {
				if(_g.s == " @formatter:off") {
					line = null;
					index = this.skipFormatterOff(index);
					continue;
				}
			}
			if(this.range != null) {
				if(index < this.range.startPos) {
					++index;
					continue;
				}
			}
			if(line == null) {
				line = new formatter_codedata_CodeLine(this.indenter.calcIndent(tokenInfo.token) + tokenInfo.additionalIndent);
				this.lines.push(line);
			}
			if(this.range != null) {
				if(index == this.range.startPos && this.rangeStartOffset > 0) {
					tokenInfo.text = HxOverrides.substr(tokenInfo.text,this.rangeStartOffset,null);
					line.indent = 0;
				}
			}
			if(this.range != null && index == this.range.endPos) {
				if(this.posRange.endPos >= tokenInfo.token.pos.min && this.posRange.endPos < tokenInfo.token.pos.max) {
					let index = 0;
					if(this.range.endPos == this.range.startPos) {
						index = this.rangeStartOffset;
					}
					tokenInfo.text = HxOverrides.substr(tokenInfo.text,0,this.rangeEndOffset - index);
					tokenInfo.spacesAfter = 0;
					tokenInfo.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
					tokenInfo.emptyLinesAfter = 0;
					line.partialLine = true;
				}
				if(this.posRange.endPos > tokenInfo.token.pos.max) {
					this.trailingWhitespaceAfterRange = this.parsedCode.getString(tokenInfo.token.pos.max,this.posRange.endPos);
					line.partialLine = true;
				}
			}
			line.addToken(tokenInfo,this.parsedCode.lineSeparator);
			if(tokenInfo.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
				line = null;
			}
			++index;
		}
	}
	skipFormatterOff(index) {
		let startIndex = index++;
		let startInfo = this.parsedCode.tokenList.getTokenAt(startIndex);
		let startLine = this.parsedCode.getLinePos(startInfo.token.pos.min).line;
		while(index < this.parsedCode.tokenList.tokens.length) {
			let endIndex = index++;
			let tokenInfo = this.parsedCode.tokenList.getTokenAt(endIndex);
			if(tokenInfo == null) {
				continue;
			}
			if(this.range != null) {
				if(endIndex < this.range.startPos) {
					continue;
				}
				if(endIndex == this.range.startPos) {
					startInfo = this.parsedCode.tokenList.getTokenAt(endIndex);
					startLine = this.parsedCode.getLinePos(startInfo.token.pos.min).line;
				}
				if(endIndex >= this.range.endPos) {
					this.copyVerbatimChars(startInfo.token.pos.min,tokenInfo.token.pos.max);
					return index;
				}
			}
			let _g = tokenInfo.token.tok;
			if(_g._hx_index == 8) {
				if(_g.s == " @formatter:on") {
					if(this.range != null) {
						if(startIndex < this.range.startPos) {
							this.copyVerbatimChars(startInfo.token.pos.min,tokenInfo.token.pos.max);
							return index;
						}
					}
					let endLine = this.parsedCode.getLinePos(tokenInfo.token.pos.max).line;
					this.copyVerbatimLines(startLine,endLine);
					return index;
				}
			}
		}
		let endLine = this.parsedCode.lines.length - 1;
		this.copyVerbatimLines(startLine,endLine);
		return index;
	}
	copyVerbatimLines(startLine,endLine) {
		let startOffs = this.parsedCode.linesIdx[startLine].l;
		let endOffs = this.parsedCode.linesIdx[endLine].r;
		let content = this.parsedCode.getString(startOffs,endOffs);
		if(endLine < this.parsedCode.lines.length - 1) {
			content = StringTools.rtrim(content);
		}
		this.lines.push(new formatter_codedata_VerbatimCodeLine(content));
	}
	copyVerbatimChars(startPos,endPos) {
		let content = this.parsedCode.getString(startPos,endPos);
		this.lines.push(new formatter_codedata_VerbatimCodeLine(content));
	}
	applyWrapping(config) {
		let wrappedLines = [];
		let _g = 0;
		let _g1 = this.lines;
		while(_g < _g1.length) {
			let line = _g1[_g];
			++_g;
			let wrappedCode = line.applyWrapping(config,this.parsedCode,this.indenter);
			wrappedLines = wrappedLines.concat(wrappedCode);
		}
		this.lines = wrappedLines;
	}
	print(lineSeparator) {
		let prefix = "";
		let _gthis = this;
		if(this.parsedCode.tokenList.leadingEmptyLInes > 0) {
			prefix = StringTools.lpad("",lineSeparator,lineSeparator.length * this.parsedCode.tokenList.leadingEmptyLInes);
		}
		let rangeNewLine = "";
		if(this.range != null) {
			if(this.range.startPos > 0) {
				prefix = "";
			}
			if(this.lines.length > 0) {
				let line = this.lines[this.lines.length - 1];
				line.emptyLinesAfter = 0;
			}
		}
		let _this = this.lines;
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = _this[i].print(_gthis.indenter,lineSeparator);
		}
		return prefix + result.join(lineSeparator) + this.trailingWhitespaceAfterRange;
	}
}
$hxClasses["formatter.codedata.CodeLines"] = formatter_codedata_CodeLines;
formatter_codedata_CodeLines.__name__ = "formatter.codedata.CodeLines";
Object.assign(formatter_codedata_CodeLines.prototype, {
	__class__: formatter_codedata_CodeLines
	,indenter: null
	,parsedCode: null
	,range: null
	,posRange: null
	,trailingWhitespaceAfterRange: null
	,rangeStartOffset: null
	,rangeEndOffset: null
	,lines: null
});
class formatter_codedata_ParsedCode {
	constructor(inputData) {
		this.file = { name : inputData.fileName, content : inputData.content};
		try {
			this.removeBOM();
			if(inputData.lineSeparator == null) {
				this.detectLineSeparator();
			} else {
				this.lineSeparator = inputData.lineSeparator;
			}
			this.makeLines();
			this.makePosIndices();
			if(inputData.tokenList == null) {
				this.makeTokens();
				this.getTokenTree(inputData.entryPoint);
			} else {
				this.tokens = inputData.tokenList;
				this.root = inputData.tokenTree;
				this.makeTokenList();
			}
			this.checkTokens();
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			let e = haxe_Exception.caught(_g).unwrap();
			throw haxe_Exception.thrown("failed to create parser context: " + (e == null ? "null" : Std.string(e)));
		}
	}
	checkTokens() {
		if(this.tokens.length != this.tokenList.tokens.length) {
			throw haxe_Exception.thrown("token count mismatch");
		}
		let skipCount = 0;
		let _g = 0;
		let _g1 = this.tokens.length;
		while(_g < _g1) {
			let index = _g++;
			let info = this.tokenList.tokens[index];
			if(info == null) {
				if(skipCount <= 0) {
					throw haxe_Exception.thrown("missing token \"" + Std.string(this.tokens[index]) + "\" [" + index + "] detected!");
				}
				--skipCount;
				continue;
			}
			let token = info.token;
			let _g1 = token.tok;
			switch(_g1._hx_index) {
			case 2:
				let _g2 = _g1.c;
				switch(_g2._hx_index) {
				case 0:
					let v = _g2.v;
					if(StringTools.startsWith(v,"-")) {
						skipCount = 1;
					}
					break;
				case 1:
					let v1 = _g2.f;
					if(StringTools.startsWith(v1,"-")) {
						skipCount = 1;
					}
					break;
				default:
					skipCount = 0;
				}
				break;
			case 6:
				let _g3 = _g1.op;
				switch(_g3._hx_index) {
				case 8:
					skipCount = 1;
					break;
				case 17:
					skipCount = 1;
					break;
				case 18:
					skipCount = 2;
					break;
				case 20:
					switch(_g3.op._hx_index) {
					case 17:
						skipCount = 2;
						break;
					case 18:
						skipCount = 3;
						break;
					default:
						skipCount = 0;
					}
					break;
				default:
					skipCount = 0;
				}
				break;
			default:
				skipCount = 0;
			}
		}
	}
	getTokenTree(entryPoint) {
		if(this.tokens == null) {
			return null;
		}
		if(entryPoint == null) {
			entryPoint = tokentree_TokenTreeEntryPoint.TypeLevel;
		}
		if(this.root == null) {
			let this1 = this.file.content;
			this.root = tokentree_TokenTreeBuilder.buildTokenTree(this.tokens,this1,entryPoint);
			this.makeTokenList();
		}
		return this.root;
	}
	removeBOM() {
		if(this.file.content == null || this.file.content.length <= 2) {
			return;
		}
		if(this.file.content.b[0] == 239 && this.file.content.b[1] == 187 && this.file.content.b[2] == 191) {
			let withBOM = this.file.content;
			this.file.content = withBOM.sub(3,this.file.content.length - 3);
		}
	}
	makeTokenList() {
		this.tokenList = new formatter_codedata_TokenList();
		this.tokenList.buildList(this.root);
	}
	makePosIndices() {
		let code = this.file.content;
		this.linesIdx = [];
		let last = 0;
		let left = false;
		let _g = 0;
		let _g1 = code.length;
		while(_g < _g1) {
			let i = _g++;
			if(code.b[i] == 10) {
				this.linesIdx.push({ l : last, r : i});
				last = i + 1;
				left = false;
			}
			left = true;
		}
		if(left) {
			this.linesIdx.push({ l : last, r : code.length});
		}
	}
	getLinePos(off) {
		let lowerBound = 0;
		let upperBound = this.linesIdx.length - 1;
		if(this.linesIdx.length <= 0) {
			throw haxe_Exception.thrown("Bad offset");
		}
		if(off < 0) {
			throw haxe_Exception.thrown("Bad offset");
		}
		if(off > this.linesIdx[upperBound].r) {
			throw haxe_Exception.thrown("Bad offset");
		}
		while(true) {
			if(lowerBound > upperBound) {
				throw haxe_Exception.thrown("Bad offset");
			}
			let center = lowerBound + Math.floor((upperBound - lowerBound) / 2);
			let matchLeft = this.linesIdx[center].l <= off;
			let matchRight = this.linesIdx[center].r >= off;
			if(matchLeft && matchRight) {
				return { line : center, ofs : off - this.linesIdx[center].l};
			}
			if(matchLeft) {
				lowerBound = center + 1;
				continue;
			}
			if(matchRight) {
				upperBound = center - 1;
				continue;
			}
		}
	}
	getString(off,off2) {
		let code = this.file.content;
		let len = off2 - off;
		if(off >= code.length || off + len > code.length) {
			return "";
		}
		return code.sub(off,off2 - off).toString();
	}
	isOriginalNewlineBefore(token) {
		if(token == null) {
			return false;
		}
		let prev = this.tokenList.getPreviousToken(token);
		if(prev == null) {
			return false;
		}
		return !this.isOriginalSameLine(prev.token,token);
	}
	isOriginalSameLine(first,second) {
		let startLine = this.getLinePos(first.pos.max).line;
		let endLine = this.getLinePos(second.pos.min).line;
		return startLine == endLine;
	}
	linesBetweenOriginal(first,second) {
		let startLine = this.getLinePos(first.pos.min).line;
		let endLine = this.getLinePos(second.pos.min).line;
		return endLine - startLine;
	}
	detectLineSeparator() {
		let codeBytes = this.file.content;
		let code = codeBytes.toString();
		let _g = 0;
		let _g1 = code.length;
		while(_g < _g1) {
			let i = _g++;
			let char = code.charAt(i);
			if(char == "\r" || char == "\n") {
				this.lineSeparator = char;
				if(char == "\r" && i + 1 < code.length) {
					char = code.charAt(i + 1);
					if(char == "\n") {
						this.lineSeparator += char;
					}
				}
				return;
			}
		}
		this.lineSeparator = "\n";
	}
	makeLines() {
		let code = this.file.content;
		let textCode = code.toString();
		this.lines = textCode.split(this.lineSeparator);
		this.emptyLines = [];
		let _g = 0;
		let _g1 = this.lines.length;
		while(_g < _g1) {
			let index = _g++;
			let line = this.lines[index];
			if(StringTools.startsWith(line,"<<<<<<<")) {
				throw haxe_Exception.thrown("not formatting \"" + this.file.name + "\" - file contains a merge conflict");
			}
			if(new EReg("^\\s*$","").match(line)) {
				this.emptyLines.push(index);
			}
		}
	}
	makeTokens() {
		try {
			this.tokens = [];
			this.root = null;
			let this1 = this.file.content;
			let lexer = new haxeparser_HaxeLexer(this1,this.file.name);
			let t = lexer.token(haxeparser_HaxeLexer.tok);
			while(t.tok != haxeparser_TokenDef.Eof) {
				this.tokens.push(t);
				t = lexer.token(haxeparser_HaxeLexer.tok);
			}
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			let e = haxe_Exception.caught(_g).unwrap();
			throw haxe_Exception.thrown("failed to make tokens " + (e == null ? "null" : Std.string(e)));
		}
	}
}
$hxClasses["formatter.codedata.ParsedCode"] = formatter_codedata_ParsedCode;
formatter_codedata_ParsedCode.__name__ = "formatter.codedata.ParsedCode";
Object.assign(formatter_codedata_ParsedCode.prototype, {
	__class__: formatter_codedata_ParsedCode
	,file: null
	,tokens: null
	,linesIdx: null
	,lines: null
	,lineSeparator: null
	,root: null
	,tokenList: null
	,emptyLines: null
});
class formatter_codedata_TokenList {
	constructor() {
		this.tokens = [];
		this.leadingEmptyLInes = 0;
		this.closeTokenCache = new haxe_ds_IntMap();
	}
	buildList(token) {
		if(token.children == null) {
			return;
		}
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let index = child.index;
			if(index < 0 || child.inserted) {
				continue;
			}
			if(child.index >= this.tokens.length) {
				this.fill(child.index - this.tokens.length);
			}
			this.tokens[index] = { token : child, whitespaceAfter : formatter_codedata_WhitespaceAfterType.None, spacesBefore : 0, spacesAfter : 0, emptyLinesAfter : 0, wrapAfter : false, text : null, additionalIndent : 0};
			this.buildList(child);
		}
	}
	fill(count) {
		while(count-- > 0) this.tokens.push(null);
	}
	getCloseToken(token) {
		if(token == null || token.tok == tokentree_TokenTreeDef.Root) {
			return null;
		}
		if(token.index < 0 || token.index >= this.tokens.length) {
			return null;
		}
		if(this.closeTokenCache.h.hasOwnProperty(token.index)) {
			return this.closeTokenCache.h[token.index];
		}
		let result;
		switch(token.tok._hx_index) {
		case 15:
			result = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.BkClose);
			break;
		case 17:
			result = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.BrClose);
			break;
		case 19:
			result = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.PClose);
			break;
		default:
			return null;
		}
		if(result == null) {
			return null;
		}
		this.closeTokenCache.h[token.index] = result;
		return result;
	}
	getTokenAtOffset(off) {
		if(this.tokens.length <= 0) {
			throw haxe_Exception.thrown("Bad offset");
		}
		if(off < 0) {
			throw haxe_Exception.thrown("Bad offset");
		}
		if(off > this.tokens[this.tokens.length - 1].token.pos.max) {
			throw haxe_Exception.thrown("Bad offset");
		}
		let _g = 0;
		let _g1 = this.tokens;
		while(_g < _g1.length) {
			let token = _g1[_g];
			++_g;
			if(token == null) {
				continue;
			}
			if(token.token.pos.max >= off) {
				return token;
			}
		}
		throw haxe_Exception.thrown("Bad offset");
	}
	getTokenAt(index) {
		if(index < 0 || index >= this.tokens.length) {
			return null;
		}
		return this.tokens[index];
	}
	getPreviousToken(token) {
		if(token == null || token.index <= 0) {
			return null;
		}
		let prevToken = null;
		let prevIndex = token.index - 1;
		if(prevIndex >= this.tokens.length) {
			return null;
		}
		while(prevToken == null) {
			prevToken = this.tokens[prevIndex--];
			if(prevIndex < 0) {
				return null;
			}
		}
		return prevToken;
	}
	getNextToken(token) {
		if(token == null || token.index <= 0) {
			return null;
		}
		let nextToken = null;
		let nextIndex = token.index + 1;
		if(nextIndex >= this.tokens.length) {
			return null;
		}
		while(nextToken == null) {
			nextToken = this.tokens[nextIndex++];
			if(nextIndex < 0) {
				return null;
			}
		}
		return nextToken;
	}
	whitespace(token,where) {
		if(token.index < 0) {
			return;
		}
		let info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		let prev = null;
		let prevIndex = token.index - 1;
		while(prev == null) {
			if(prevIndex < 0) {
				break;
			}
			prev = this.tokens[prevIndex--];
		}
		if(prev != null && this.needsLineBreak(prev.token)) {
			prev = null;
		}
		switch(where) {
		case "after":
			this.applyWhitespace(info,formatter_codedata_WhitespaceAfterType.Space);
			break;
		case "around":
			this.applyWhitespace(info,formatter_codedata_WhitespaceAfterType.Space);
			this.applyWhitespace(prev,formatter_codedata_WhitespaceAfterType.Space);
			break;
		case "before":
			this.applyWhitespace(prev,formatter_codedata_WhitespaceAfterType.Space);
			break;
		case "none":
			this.applyWhitespace(info,formatter_codedata_WhitespaceAfterType.None);
			this.applyWhitespace(prev,formatter_codedata_WhitespaceAfterType.None);
			break;
		case "noneAfter":
			this.applyWhitespace(info,formatter_codedata_WhitespaceAfterType.None);
			break;
		case "noneBefore":
			this.applyWhitespace(prev,formatter_codedata_WhitespaceAfterType.None);
			break;
		case "onlyAfter":
			this.applyWhitespace(prev,formatter_codedata_WhitespaceAfterType.None);
			this.applyWhitespace(info,formatter_codedata_WhitespaceAfterType.Space);
			break;
		case "onlyBefore":
			this.applyWhitespace(prev,formatter_codedata_WhitespaceAfterType.Space);
			this.applyWhitespace(info,formatter_codedata_WhitespaceAfterType.None);
			break;
		}
	}
	applyWhitespace(info,policy) {
		if(info == null) {
			return;
		}
		switch(info.whitespaceAfter._hx_index) {
		case 0:
			info.whitespaceAfter = policy;
			switch(policy._hx_index) {
			case 0:
				info.spacesAfter = 0;
				break;
			case 1:
				this.shouldHaveOneSpaceAfter(info);
				break;
			case 2:
				break;
			}
			break;
		case 1:
			switch(policy._hx_index) {
			case 0:
				info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
				info.spacesAfter = 0;
				break;
			case 1:
				this.shouldHaveOneSpaceAfter(info);
				break;
			case 2:
				info.whitespaceAfter = policy;
				break;
			}
			break;
		case 2:
			switch(policy._hx_index) {
			case 0:
				if(info.spacesAfter > 0) {
					info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
				} else {
					info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
					info.spacesAfter = 0;
				}
				break;
			case 1:
				info.whitespaceAfter = policy;
				this.shouldHaveOneSpaceAfter(info);
				break;
			case 2:
				break;
			}
			break;
		}
	}
	shouldHaveOneSpaceAfter(info) {
		if(info == null) {
			return;
		}
		if(info.spacesAfter <= 0) {
			info.spacesAfter = 1;
		}
	}
	spacesBefore(token,count) {
		if(token.index < 0) {
			return;
		}
		let info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		info.spacesBefore = count;
	}
	lineEndAfter(token) {
		if(token.index < 0) {
			return;
		}
		let info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		switch(info.whitespaceAfter._hx_index) {
		case 0:
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Newline;
			break;
		case 1:
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Newline;
			break;
		case 2:
			break;
		}
	}
	lineEndBefore(token) {
		let info = this.getPreviousToken(token);
		if(info == null) {
			return;
		}
		switch(info.whitespaceAfter._hx_index) {
		case 0:
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Newline;
			break;
		case 1:
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Newline;
			break;
		case 2:
			break;
		}
	}
	needsLineBreak(token) {
		if(token == null) {
			return false;
		}
		let _g = token.tok;
		if(_g._hx_index == 8) {
			let _g1 = _g.s;
			return true;
		}
		return false;
	}
	noLineEndAfter(token) {
		if(token.index < 0) {
			return;
		}
		let info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		if(this.needsLineBreak(info.token)) {
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Newline;
			return;
		}
		switch(info.whitespaceAfter._hx_index) {
		case 0:
			return;
		case 1:
			break;
		case 2:
			if(info.spacesAfter <= 0) {
				info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
			} else {
				info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
				this.shouldHaveOneSpaceAfter(info);
			}
			break;
		}
	}
	noLineEndBefore(token) {
		let info = this.getPreviousToken(token);
		if(info == null) {
			return;
		}
		if(this.needsLineBreak(info.token)) {
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Newline;
			return;
		}
		switch(info.whitespaceAfter._hx_index) {
		case 0:
			return;
		case 1:
			break;
		case 2:
			if(info.spacesAfter <= 0) {
				info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
			} else {
				info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
				this.shouldHaveOneSpaceAfter(info);
			}
			break;
		}
	}
	emptyLinesAfter(token,count) {
		if(token.index < 0) {
			return;
		}
		let info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		info.emptyLinesAfter = count;
	}
	emptyLinesBefore(token,count) {
		if(token.index <= 0) {
			this.leadingEmptyLInes = count;
			return;
		}
		let info = this.getPreviousToken(token);
		if(info == null) {
			return;
		}
		info.emptyLinesAfter = count;
	}
	emptyLinesAfterSubTree(token,count) {
		let lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
		if(lastToken == null) {
			return;
		}
		let info = this.tokens[lastToken.index];
		if(info == null) {
			return;
		}
		info.emptyLinesAfter = count;
	}
	tokenText(token,text) {
		if(token.index < 0) {
			return;
		}
		let info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		info.text = text;
	}
	wrapAfter(token,wrap) {
		if(token.index < 0) {
			return;
		}
		let info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		info.wrapAfter = wrap;
	}
	wrapBefore(token,wrap) {
		let prev = this.getPreviousToken(token);
		if(prev == null) {
			return;
		}
		prev.wrapAfter = wrap;
	}
	noWrappingBetween(tokenStart,tokenEnd,config,allowCommas) {
		if(allowCommas == null) {
			allowCommas = true;
		}
		if(tokenStart == null || tokenEnd == null) {
			return;
		}
		let index = tokenStart.index;
		while(index < tokenEnd.index) {
			let first = index == tokenStart.index;
			let info = this.tokens[index++];
			let next = this.tokens[index];
			if(info == null) {
				continue;
			}
			let _g = info.token.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:case 40:
					let lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(info.token);
					if(lastChild != null) {
						if(lastChild.index > index) {
							index = lastChild.index;
						}
						continue;
					}
					break;
				default:
				}
				break;
			case 8:
				let _g1 = _g.s;
				continue;
			case 13:
				let lastChild1 = tokentree_utils_TokenTreeCheckUtils.getLastToken(info.token);
				if(lastChild1 != null) {
					if(lastChild1.index > index) {
						index = lastChild1.index;
					}
					continue;
				}
				break;
			case 14:
				if(allowCommas) {
					continue;
				}
				break;
			case 15:
				if(!first) {
					let close = this.getCloseToken(info.token);
					if(close != null) {
						index = close.index;
						continue;
					}
				}
				break;
			case 17:
				if(!first) {
					let close = this.getCloseToken(info.token);
					if(close != null) {
						index = close.index;
						continue;
					}
				}
				break;
			case 19:
				if(!first) {
					let close = this.getCloseToken(info.token);
					if(close != null) {
						index = close.index;
						continue;
					}
				}
				break;
			default:
			}
			info.wrapAfter = false;
			if(next != null) {
				switch(next.token.tok._hx_index) {
				case 17:
					switch(config.lineEnds.leftCurly) {
					case "after":case "none":
						break;
					case "before":case "both":
						continue;
					}
					break;
				case 18:
					switch(config.lineEnds.rightCurly) {
					case "after":case "both":
						continue;
					case "before":case "none":
						break;
					}
					break;
				default:
				}
			}
			switch(info.whitespaceAfter._hx_index) {
			case 0:
				break;
			case 1:
				break;
			case 2:
				if(info.spacesAfter <= 0) {
					info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
				} else {
					info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
					this.shouldHaveOneSpaceAfter(info);
				}
				break;
			}
		}
	}
	additionalIndent(token,indent) {
		if(indent == null || token == null || token.index < 0) {
			return;
		}
		let info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		info.additionalIndent = indent;
	}
	increaseIndentBetween(start,end,depth) {
		if(depth == 0 || start == null || start.index < 0 || end == null || end.index < 0) {
			return;
		}
		let startIndex = start.index;
		if(depth > 0) {
			++startIndex;
		}
		let endIndex = end.index;
		let _g = startIndex;
		let _g1 = endIndex;
		while(_g < _g1) {
			let index = _g++;
			let info = this.tokens[index];
			if(info == null) {
				continue;
			}
			info.additionalIndent += depth;
		}
	}
	findTokenAtOffset(offset) {
		let lastInfo = null;
		let _g = 0;
		let _g1 = this.tokens;
		while(_g < _g1.length) {
			let info = _g1[_g];
			++_g;
			if(info == null) {
				continue;
			}
			if(info.token.pos.min >= offset) {
				return lastInfo;
			}
			lastInfo = info;
		}
		return lastInfo;
	}
	isSameLine(first,second) {
		let startIndex = first.index;
		let endIndex = second.index;
		if(startIndex == endIndex) {
			return true;
		}
		if(startIndex < 0 || endIndex < 0) {
			return false;
		}
		if(startIndex > endIndex) {
			startIndex = second.index;
			endIndex = first.index;
		}
		while(startIndex < endIndex) {
			let currTok = this.tokens[startIndex++];
			if(currTok == null) {
				continue;
			}
			if(currTok.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
				return false;
			}
		}
		return true;
	}
	findLowestIndex(start) {
		let lowest = start;
		if(!start.hasChildren()) {
			return lowest;
		}
		let _g = 0;
		let _g1 = start.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let token = this.findLowestIndex(child);
			if(token.index < lowest.index) {
				lowest = token;
			}
		}
		return lowest;
	}
	calcLength(token) {
		if(token == null || token.index < 0) {
			return 0;
		}
		let current = this.tokens[token.index];
		if(current == null) {
			return 0;
		}
		let spaceAdd = 0;
		if(current.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Space) {
			spaceAdd = 1;
		}
		if(current.text == null) {
			current.text = "" + Std.string(current.token);
		}
		let length = current.text.length + spaceAdd;
		if(token.children == null || token.children.length <= 0) {
			return length;
		}
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			length += this.calcLength(child);
		}
		return length;
	}
	isMultilineToken(token) {
		if(token == null || token.index < 0) {
			return false;
		}
		let current = this.tokens[token.index];
		if(current == null) {
			return false;
		}
		if(current.text.indexOf("\r") >= 0 || current.text.indexOf("\n") >= 0) {
			return true;
		}
		return false;
	}
	calcLengthUntilNewline(token,stop) {
		if(token == null || token.index < 0) {
			return 0;
		}
		let endIndex = this.tokens.length - 1;
		if(stop != null) {
			endIndex = stop.index;
		}
		let index = token.index;
		let length = 0;
		while(index <= endIndex) {
			let current = this.tokens[index++];
			if(current == null) {
				continue;
			}
			if(current.text == null) {
				current.text = "" + Std.string(current.token);
			}
			if(current.text.indexOf("\r") >= 0) {
				length += current.text.indexOf("\r");
				break;
			}
			if(current.text.indexOf("\n") >= 0) {
				length += current.text.indexOf("\n");
				break;
			}
			length += current.spacesBefore;
			if(current.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Space) {
				length += current.spacesAfter;
			}
			length += current.text.length;
			if(current.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
				break;
			}
		}
		return length;
	}
	calcLengthBetween(tokenStart,tokenEnd) {
		if(tokenStart == null || tokenEnd == null) {
			return 0;
		}
		if(tokenStart.index < 0 || tokenEnd.index < 0) {
			return 0;
		}
		let length = 0;
		let _g = tokenStart.index;
		let _g1 = tokenEnd.index;
		while(_g < _g1) {
			let index = _g++;
			let current = this.tokens[index];
			if(current == null) {
				continue;
			}
			if(current.text == null) {
				current.text = "" + Std.string(current.token);
			}
			length += current.text.length;
			if(current.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Space) {
				++length;
			}
		}
		return length;
	}
	calcLineLength(token) {
		if(token == null || token.index < 0) {
			return 0;
		}
		let start = token.index - 1;
		while(start >= 0) {
			let info = this.tokens[start--];
			if(info == null) {
				continue;
			}
			if(info.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
				start += 2;
				break;
			}
		}
		let length = 0;
		_hx_loop2: while(start < this.tokens.length) {
			let info = this.tokens[start++];
			if(info == null) {
				continue;
			}
			length += info.text.length;
			switch(info.whitespaceAfter._hx_index) {
			case 0:
				break;
			case 1:
				length += info.spacesAfter;
				break;
			case 2:
				break _hx_loop2;
			}
		}
		return length;
	}
	calcLineLengthBefore(token) {
		if(token == null || token.index < 0) {
			return 0;
		}
		let start = token.index - 1;
		let length = 0;
		_hx_loop1: while(start >= 0) {
			let info = this.tokens[start--];
			if(info == null) {
				continue;
			}
			switch(info.whitespaceAfter._hx_index) {
			case 0:
				break;
			case 1:
				length += info.spacesAfter;
				break;
			case 2:
				break _hx_loop1;
			}
			length += info.text.length;
		}
		return length;
	}
	calcLineLengthAfter(token) {
		if(token == null || token.index < 0) {
			return 0;
		}
		let start = token.index + 1;
		let length = 0;
		_hx_loop1: while(start < this.tokens.length) {
			let info = this.tokens[start++];
			if(info == null) {
				continue;
			}
			let tokenLength = info.text.length;
			let linefeed = info.text.lastIndexOf("\r");
			if(linefeed >= 0) {
				tokenLength -= linefeed;
			}
			linefeed = info.text.lastIndexOf("\n");
			if(linefeed >= 0) {
				tokenLength -= linefeed;
			}
			length += tokenLength;
			switch(info.whitespaceAfter._hx_index) {
			case 0:
				break;
			case 1:
				length += info.spacesAfter;
				break;
			case 2:
				break _hx_loop1;
			}
		}
		return length;
	}
	calcTokenLength(token) {
		if(token == null || token.index < 0) {
			return 0;
		}
		let info = this.tokens[token.index];
		if(info == null) {
			return 0;
		}
		let length = info.text.length;
		switch(info.whitespaceAfter._hx_index) {
		case 0:
			break;
		case 1:
			length += info.spacesAfter;
			break;
		case 2:
			break;
		}
		return length;
	}
	isNewLineBefore(token) {
		let info = this.getPreviousToken(token);
		if(info == null) {
			return false;
		}
		return info.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline;
	}
	isNewLineAfter(token) {
		let info = this.getTokenAt(token.index);
		if(info == null) {
			return false;
		}
		return info.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline;
	}
	isSameLineBetween(tokenStart,tokenEnd,exclude) {
		if(tokenStart == null || tokenEnd == null) {
			return true;
		}
		let start = tokenStart.index;
		let end = tokenEnd.index;
		if(exclude) {
			++start;
		}
		let _g = start;
		let _g1 = end;
		while(_g < _g1) {
			let index = _g++;
			let info = this.tokens[index];
			if(info == null) {
				continue;
			}
			if(info.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
				return false;
			}
			if(info.text == null) {
				continue;
			}
			if(info.text.indexOf("\r") >= 0 || info.text.indexOf("\n") >= 0) {
				return false;
			}
		}
		return true;
	}
	findLineStartToken(token) {
		if(token == null || token.index < 0) {
			return null;
		}
		let start = token.index - 1;
		while(true) {
			if(start < 0) {
				return this.tokens[0].token;
			}
			let info = this.tokens[start--];
			if(info == null) {
				continue;
			}
			switch(info.whitespaceAfter._hx_index) {
			case 0:
				break;
			case 1:
				break;
			case 2:
				return token;
			}
			token = info.token;
		}
	}
}
$hxClasses["formatter.codedata.TokenList"] = formatter_codedata_TokenList;
formatter_codedata_TokenList.__name__ = "formatter.codedata.TokenList";
Object.assign(formatter_codedata_TokenList.prototype, {
	__class__: formatter_codedata_TokenList
	,tokens: null
	,leadingEmptyLInes: null
	,closeTokenCache: null
});
class formatter_codedata_VerbatimCodeLine extends formatter_codedata_CodeLine {
	constructor(content) {
		super(0);
		this.content = content;
		this.verbatim = true;
	}
	applyWrapping(config,parsedCode,indenter) {
		return [this];
	}
	print(indenter,lineSeparator) {
		return this.content;
	}
}
$hxClasses["formatter.codedata.VerbatimCodeLine"] = formatter_codedata_VerbatimCodeLine;
formatter_codedata_VerbatimCodeLine.__name__ = "formatter.codedata.VerbatimCodeLine";
formatter_codedata_VerbatimCodeLine.__super__ = formatter_codedata_CodeLine;
Object.assign(formatter_codedata_VerbatimCodeLine.prototype, {
	__class__: formatter_codedata_VerbatimCodeLine
	,content: null
});
var formatter_codedata_WhitespaceAfterType = $hxEnums["formatter.codedata.WhitespaceAfterType"] = { __ename__ : true, __constructs__ : ["None","Space","Newline"]
	,None: {_hx_index:0,__enum__:"formatter.codedata.WhitespaceAfterType",toString:$estr}
	,Space: {_hx_index:1,__enum__:"formatter.codedata.WhitespaceAfterType",toString:$estr}
	,Newline: {_hx_index:2,__enum__:"formatter.codedata.WhitespaceAfterType",toString:$estr}
};
class formatter_config_Config {
	constructor() {
		this.excludes = [];
		this.readConfigFromString("{}","hxformat.json");
	}
	readConfigFromString(jsonContent,fileName) {
		let parser = new JsonParser_$1();
		let data = parser.fromJson(jsonContent,fileName);
		this.emptyLines = data.emptyLines;
		this.indentation = data.indentation;
		this.lineEnds = data.lineEnds;
		this.sameLine = data.sameLine;
		this.whitespace = data.whitespace;
		this.wrapping = data.wrapping;
		this.disableFormatting = data.disableFormatting;
		this.excludes = [];
		this.configFileName = fileName;
		let _g = 0;
		let _g1 = data.excludes;
		while(_g < _g1.length) {
			let exclude = _g1[_g];
			++_g;
			this.excludes.push(new EReg(exclude,""));
		}
	}
	isExcluded(fileName) {
		let _g = 0;
		let _g1 = this.excludes;
		while(_g < _g1.length) {
			let exclude = _g1[_g];
			++_g;
			if(exclude.match(fileName)) {
				return true;
			}
		}
		return false;
	}
}
$hxClasses["formatter.config.Config"] = formatter_config_Config;
formatter_config_Config.__name__ = "formatter.config.Config";
Object.assign(formatter_config_Config.prototype, {
	__class__: formatter_config_Config
	,emptyLines: null
	,indentation: null
	,lineEnds: null
	,sameLine: null
	,whitespace: null
	,wrapping: null
	,disableFormatting: null
	,excludes: null
	,configFileName: null
});
class formatter_config_WhitespacePolicy {
	static remove(policy,removePolicy) {
		switch(removePolicy) {
		case "after":
			break;
		case "around":
			return "none";
		case "before":
			break;
		case "none":
			return policy;
		case "noneAfter":
			removePolicy = "after";
			break;
		case "noneBefore":
			removePolicy = "before";
			break;
		case "onlyAfter":
			removePolicy = "after";
			break;
		case "onlyBefore":
			removePolicy = "before";
			break;
		}
		switch(policy) {
		case "after":
			if(removePolicy == "after") {
				return "none";
			}
			break;
		case "around":
			if(removePolicy == "before") {
				return "after";
			}
			if(removePolicy == "after") {
				return "before";
			}
			break;
		case "before":
			if(removePolicy == "before") {
				return "none";
			}
			break;
		case "none":
			return "none";
		case "noneAfter":
			return "noneAfter";
		case "noneBefore":
			return "noneBefore";
		case "onlyAfter":
			if(removePolicy == "after") {
				return "none";
			}
			break;
		case "onlyBefore":
			if(removePolicy == "before") {
				return "none";
			}
			break;
		}
		return policy;
	}
	static add(policy,addPolicy) {
		switch(addPolicy) {
		case "after":
			break;
		case "around":
			return "none";
		case "before":
			break;
		case "none":
			return policy;
		case "noneAfter":
			addPolicy = "after";
			break;
		case "noneBefore":
			addPolicy = "before";
			break;
		case "onlyAfter":
			addPolicy = "after";
			break;
		case "onlyBefore":
			addPolicy = "before";
			break;
		}
		switch(policy) {
		case "after":
			if(addPolicy == "before") {
				return "around";
			}
			break;
		case "around":
			break;
		case "before":
			if(addPolicy == "after") {
				return "around";
			}
			break;
		case "none":
			return addPolicy;
		case "noneAfter":
			if(addPolicy == "before") {
				return "onlyBefore";
			}
			if(addPolicy == "after") {
				return "onlyAfter";
			}
			break;
		case "noneBefore":
			if(addPolicy == "before") {
				return "onlyBefore";
			}
			if(addPolicy == "after") {
				return "onlyAfter";
			}
			break;
		case "onlyAfter":
			if(addPolicy == "before") {
				return "around";
			}
			break;
		case "onlyBefore":
			if(addPolicy == "after") {
				return "around";
			}
			break;
		}
		return policy;
	}
}
class formatter_marker_Indenter {
	constructor(config) {
		this.config = config;
		if(config.character.toLowerCase() == "tab") {
			config.character = "\t";
		}
	}
	setParsedCode(parsedCode) {
		this.parsedCode = parsedCode;
	}
	makeIndentString(count) {
		return StringTools.lpad("",this.config.character,this.config.character.length * count);
	}
	calcAbsoluteIndent(indent) {
		if(this.config.character == "\t") {
			return indent * this.config.tabWidth;
		}
		return indent * this.config.character.length;
	}
	calcIndent(token) {
		if(token == null) {
			return 0;
		}
		let _g = token.tok;
		if(_g._hx_index == 3) {
			let _g1 = _g.s;
			if(this.config.conditionalPolicy == "fixedZero") {
				return 0;
			}
			if(this.config.conditionalPolicy == "fixedZeroIncrease") {
				return this.calcConditionalLevel(token);
			}
			if(this.config.conditionalPolicy == "fixedZeroIncreaseBlocks") {
				if(this.hasBlockParent(token)) {
					return this.calcConditionalLevel(token);
				}
				return 0;
			}
		}
		token = this.findEffectiveParent(token);
		return this.calcFromCandidates(token);
	}
	calcConditionalLevel(token) {
		let count = -1;
		while(token != null && token.tok != tokentree_TokenTreeDef.Root) {
			let _g = token.tok;
			if(_g._hx_index == 3) {
				if(_g.s == "if") {
					++count;
				}
			}
			token = token.parent;
		}
		if(count <= 0) {
			return 0;
		}
		return count;
	}
	calcConsecutiveConditionalLevel(token) {
		let count = -1;
		let maxCount = -1;
		while(token != null && token.tok != tokentree_TokenTreeDef.Root) {
			let _g = token.tok;
			if(_g._hx_index == 3) {
				if(_g.s == "if") {
					++count;
				}
			} else {
				if(count > maxCount) {
					maxCount = count;
				}
				count = -1;
			}
			token = token.parent;
		}
		if(count > maxCount) {
			maxCount = count;
		}
		if(maxCount <= 0) {
			return 0;
		}
		return maxCount;
	}
	shouldAddTrailingWhitespace() {
		return this.config.trailingWhitespace;
	}
	findEffectiveParent(token) {
		if(token.tok == tokentree_TokenTreeDef.Root) {
			return token.getFirstChild();
		}
		let _g = token.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				let parent = token.parent;
				if(parent.tok == tokentree_TokenTreeDef.Root) {
					return token;
				}
				if(parent.tok._hx_index == 19) {
					if(this.parsedCode.tokenList.isNewLineBefore(token)) {
						return token;
					}
					return this.findEffectiveParent(token.parent);
				}
				break;
			case 3:
				let prev = this.parsedCode.tokenList.getPreviousToken(token);
				if(prev == null) {
					return token;
				}
				if(prev.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
					return token;
				}
				let metadata = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.At);
				if(metadata != null) {
					if(!this.parsedCode.tokenList.isSameLineBetween(metadata,token,false)) {
						return token;
					}
					prev = this.parsedCode.tokenList.getPreviousToken(metadata);
					if(prev == null) {
						return token;
					}
					if(prev.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
						return token;
					}
				}
				let parent1 = token.parent;
				if(parent1.tok == tokentree_TokenTreeDef.Root) {
					return token;
				}
				let _g1 = parent1.tok;
				switch(_g1._hx_index) {
				case 1:
					if(_g1.k._hx_index != 4) {
						return token;
					}
					break;
				case 6:
					let _g2 = _g1.op;
					return token;
				default:
				}
				return this.findEffectiveParent(token.parent);
			case 5:
				let parent2 = token.parent;
				if(parent2.tok == tokentree_TokenTreeDef.Root) {
					return token;
				}
				if(parent2 != null && parent2.is(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdDo))) {
					return this.findEffectiveParent(token.parent);
				}
				break;
			case 4:case 21:
				return this.findEffectiveParent(token.parent);
			default:
			}
			break;
		case 3:
			switch(_g.s) {
			case "else":case "elseif":case "end":
				return this.findEffectiveParent(token.parent);
			default:
			}
			break;
		case 7:
			let _g3 = _g.s;
			let next = this.parsedCode.tokenList.getNextToken(token);
			if(next == null) {
				return token;
			}
			let _g4 = next.token.tok;
			if(_g4._hx_index == 1) {
				switch(_g4.k._hx_index) {
				case 4:
					return this.findEffectiveParent(next.token);
				case 21:
					return this.findEffectiveParent(next.token);
				default:
					return token;
				}
			} else {
				return token;
			}
			break;
		case 8:
			let _g5 = _g.s;
			let next1 = this.parsedCode.tokenList.getNextToken(token);
			if(next1 == null) {
				return token;
			}
			let _g6 = next1.token.tok;
			if(_g6._hx_index == 1) {
				switch(_g6.k._hx_index) {
				case 4:
					return this.findEffectiveParent(next1.token);
				case 21:
					return this.findEffectiveParent(next1.token);
				default:
					return token;
				}
			} else {
				return token;
			}
			break;
		case 13:
			return this.findEffectiveParent(token.parent);
		case 17:
			let parent3 = token.parent;
			if(parent3.tok == tokentree_TokenTreeDef.Root) {
				return token;
			}
			let type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(token);
			switch(type._hx_index) {
			case 0:
				break;
			case 1:
				return token.parent;
			case 2:
				return token;
			case 3:
				return token;
			case 4:
				break;
			}
			let _g7 = parent3.tok;
			switch(_g7._hx_index) {
			case 1:
				switch(_g7.k._hx_index) {
				case 0:
					if(this.parsedCode.tokenList.isNewLineBefore(parent3)) {
						return parent3;
					}
					return this.findEffectiveParent(parent3);
				case 3:case 4:
					return this.findEffectiveParent(parent3);
				case 5:case 6:case 7:
					return this.findEffectiveParent(parent3);
				case 14:
					return this.findEffectiveParent(parent3);
				case 20:case 21:
					return this.findEffectiveParent(parent3);
				case 22:
					if(parent3.parent.is(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFunction))) {
						return this.findEffectiveParent(parent3.parent);
					}
					break;
				default:
				}
				break;
			case 2:
				let _g8 = _g7.c;
				if(_g8._hx_index == 3) {
					let _g = _g8.s;
					if(parent3.parent.is(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFunction))) {
						return this.findEffectiveParent(parent3.parent);
					}
				}
				break;
			case 6:
				let _g9 = _g7.op;
				switch(_g9._hx_index) {
				case 4:
					let access = tokentree_TokenTreeAccessHelper.is(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.parent(parent3)),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdTypedef));
					if(access != null) {
						return access;
					}
					break;
				case 20:
					let _g10 = _g9.op;
					let access1 = tokentree_TokenTreeAccessHelper.is(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.parent(parent3)),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdTypedef));
					if(access1 != null) {
						return access1;
					}
					break;
				default:
				}
				break;
			default:
			}
			break;
		case 16:case 18:
			return this.findEffectiveParent(token.parent);
		case 20:
			return this.findEffectiveParent(token.parent);
		default:
		}
		return token;
	}
	countLineBreaks(indentingTokensCandidates,indentComplexValueExpressions) {
		let count = 0;
		let prevToken = null;
		let currentToken = null;
		let mustIndent;
		let lastIndentingToken = null;
		let _g = 0;
		while(_g < indentingTokensCandidates.length) {
			let token = indentingTokensCandidates[_g];
			++_g;
			prevToken = currentToken;
			if(prevToken == null) {
				prevToken = token;
			}
			currentToken = token;
			mustIndent = false;
			let _g1 = prevToken.tok;
			switch(_g1._hx_index) {
			case 1:
				switch(_g1.k._hx_index) {
				case 0:
					if(currentToken.tok._hx_index == 19) {
						if(this.parsedCode.tokenList.isSameLineBetween(currentToken,prevToken,false)) {
							continue;
						}
						if(!this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							let firstToken = this.parsedCode.tokenList.getPreviousToken(prevToken);
							while(firstToken != null && !this.parsedCode.tokenList.isNewLineBefore(firstToken.token)) firstToken = this.parsedCode.tokenList.getPreviousToken(firstToken.token);
							let brOpen = tokentree_TokenTreeAccessHelper.firstOf(prevToken,tokentree_TokenTreeDef.BrOpen);
							if(brOpen != null) {
								if(!this.parsedCode.tokenList.isSameLineBetween(prevToken,brOpen,false)) {
									continue;
								}
							}
							return count + this.calcIndent(firstToken.token);
						}
					}
					break;
				case 3:
					if(prevToken.index == currentToken.index) {
						continue;
					}
					let _g2 = currentToken.tok;
					if(_g2._hx_index == 6) {
						if(_g2.op._hx_index == 4) {
							if(indentComplexValueExpressions) {
								mustIndent = true;
							}
						} else if(this.parsedCode.tokenList.isSameLineBetween(currentToken,prevToken,false)) {
							let elseTok = tokentree_TokenTreeAccessHelper.firstOf(prevToken,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse));
							if(elseTok != null) {
								if(this.parsedCode.tokenList.isSameLineBetween(prevToken,elseTok,false)) {
									continue;
								}
								if(indentComplexValueExpressions) {
									mustIndent = true;
								}
							}
							let brOpen = tokentree_TokenTreeAccessHelper.firstOf(prevToken,tokentree_TokenTreeDef.BrOpen);
							if(brOpen != null) {
								let type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(brOpen);
								if(type._hx_index == 0) {
									continue;
								}
							}
						}
					} else if(this.parsedCode.tokenList.isSameLineBetween(currentToken,prevToken,false)) {
						let elseTok = tokentree_TokenTreeAccessHelper.firstOf(prevToken,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse));
						if(elseTok != null) {
							if(this.parsedCode.tokenList.isSameLineBetween(prevToken,elseTok,false)) {
								continue;
							}
							if(indentComplexValueExpressions) {
								mustIndent = true;
							}
						}
						let brOpen = tokentree_TokenTreeAccessHelper.firstOf(prevToken,tokentree_TokenTreeDef.BrOpen);
						if(brOpen != null) {
							let type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(brOpen);
							if(type._hx_index == 0) {
								continue;
							}
						}
					}
					break;
				case 4:
					continue;
				case 14:
					let _g3 = currentToken.tok;
					switch(_g3._hx_index) {
					case 6:
						let op = _g3.op;
						if(indentComplexValueExpressions) {
							mustIndent = true;
						}
						break;
					case 19:
						let type = tokentree_utils_TokenTreeCheckUtils.getPOpenType(currentToken);
						switch(type._hx_index) {
						case 0:
							break;
						case 1:
							mustIndent = true;
							break;
						case 2:
							break;
						case 3:
							mustIndent = true;
							break;
						case 4:
							mustIndent = true;
							break;
						case 5:
							mustIndent = true;
							break;
						case 6:
							mustIndent = true;
							break;
						case 7:
							mustIndent = true;
							break;
						case 8:
							break;
						case 9:
							break;
						}
						break;
					default:
					}
					break;
				case 15:case 16:
					if(!this.config.indentCaseLabels) {
						continue;
					}
					break;
				case 21:
					if(currentToken.is(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdTry))) {
						continue;
					}
					break;
				default:
				}
				break;
			case 2:
				let _g4 = _g1.c;
				if(_g4._hx_index == 3) {
					switch(_g4.s) {
					case "from":case "to":
						if(this.isAbstractFromTo(token) && this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							mustIndent = true;
						}
						break;
					default:
					}
				}
				break;
			case 11:
				let _g5 = currentToken.tok;
				switch(_g5._hx_index) {
				case 1:
					switch(_g5.k._hx_index) {
					case 15:case 16:
						continue;
					case 10:case 22:case 28:
						if(!this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							continue;
						}
						break;
					default:
						if(this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							++count;
							continue;
						}
					}
					break;
				case 6:
					let _g6 = _g5.op;
					switch(_g6._hx_index) {
					case 4:
						if(this.parsedCode.tokenList.isSameLineBetween(currentToken,prevToken,false)) {
							continue;
						}
						if(!this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							let firstToken = this.parsedCode.tokenList.getPreviousToken(prevToken);
							while(firstToken != null && !this.parsedCode.tokenList.isNewLineBefore(firstToken.token)) firstToken = this.parsedCode.tokenList.getPreviousToken(firstToken.token);
							return count + this.calcIndent(firstToken.token);
						}
						break;
					case 20:
						let _g7 = _g6.op;
						if(this.parsedCode.tokenList.isSameLineBetween(currentToken,prevToken,false)) {
							continue;
						}
						if(!this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							let firstToken = this.parsedCode.tokenList.getPreviousToken(prevToken);
							while(firstToken != null && !this.parsedCode.tokenList.isNewLineBefore(firstToken.token)) firstToken = this.parsedCode.tokenList.getPreviousToken(firstToken.token);
							return count + this.calcIndent(firstToken.token);
						}
						break;
					default:
						if(this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							++count;
							continue;
						}
					}
					break;
				case 11:
					if(!(prevToken.pos.min == currentToken.pos.min && this.parsedCode.tokenList.isNewLineBefore(currentToken))) {
						continue;
					}
					break;
				case 17:case 19:
					if(this.parsedCode.tokenList.isSameLine(currentToken,prevToken)) {
						continue;
					}
					mustIndent = true;
					break;
				default:
					if(this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
						++count;
						continue;
					}
				}
				break;
			case 12:
				let _g8 = currentToken.tok;
				if(_g8._hx_index == 1) {
					switch(_g8.k._hx_index) {
					case 15:case 16:
						if(lastIndentingToken != null && lastIndentingToken.pos.min == prevToken.pos.min) {
							continue;
						}
						mustIndent = true;
						break;
					default:
					}
				}
				break;
			case 13:case 15:
				if(currentToken.tok._hx_index == 19) {
					if(this.parsedCode.tokenList.isSameLineBetween(currentToken,prevToken,false)) {
						continue;
					}
					if(!this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
						let firstToken = this.parsedCode.tokenList.getPreviousToken(prevToken);
						while(firstToken != null && !this.parsedCode.tokenList.isNewLineBefore(firstToken.token)) firstToken = this.parsedCode.tokenList.getPreviousToken(firstToken.token);
						let brOpen = tokentree_TokenTreeAccessHelper.firstOf(prevToken,tokentree_TokenTreeDef.BrOpen);
						if(brOpen != null) {
							if(!this.parsedCode.tokenList.isSameLineBetween(prevToken,brOpen,false)) {
								continue;
							}
						}
						return count + this.calcIndent(firstToken.token);
					}
				}
				break;
			case 17:
				let _g9 = currentToken.tok;
				switch(_g9._hx_index) {
				case 1:
					switch(_g9.k._hx_index) {
					case 0:case 3:case 4:case 5:case 6:case 7:case 10:case 14:case 20:case 21:case 28:
						let type1 = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(prevToken);
						if(type1._hx_index == 2) {
							let brClose = this.parsedCode.tokenList.getCloseToken(prevToken);
							if(brClose != null && !this.parsedCode.tokenList.isSameLine(prevToken,brClose) && !this.config.indentObjectLiteral) {
								continue;
							}
						} else {
							continue;
						}
						break;
					default:
					}
					break;
				case 6:
					let _g10 = _g9.op;
					switch(_g10._hx_index) {
					case 4:
						let type2 = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(prevToken);
						switch(type2._hx_index) {
						case 1:
							continue;
						case 2:
							let brClose = this.parsedCode.tokenList.getCloseToken(prevToken);
							if(brClose != null && !this.parsedCode.tokenList.isSameLine(prevToken,brClose) && !this.config.indentObjectLiteral) {
								continue;
							}
							break;
						default:
						}
						break;
					case 20:
						let _g11 = _g10.op;
						let type3 = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(prevToken);
						switch(type3._hx_index) {
						case 1:
							continue;
						case 2:
							let brClose1 = this.parsedCode.tokenList.getCloseToken(prevToken);
							if(brClose1 != null && !this.parsedCode.tokenList.isSameLine(prevToken,brClose1) && !this.config.indentObjectLiteral) {
								continue;
							}
							break;
						default:
						}
						break;
					default:
					}
					break;
				case 12:
					let type4 = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(prevToken);
					switch(type4._hx_index) {
					case 1:
						continue;
					case 2:
						let brClose2 = this.parsedCode.tokenList.getCloseToken(prevToken);
						if(brClose2 != null && !this.parsedCode.tokenList.isSameLine(prevToken,brClose2) && !this.config.indentObjectLiteral) {
							continue;
						}
						break;
					default:
					}
					break;
				case 13:
					let type5 = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(prevToken);
					if(type5._hx_index == 2) {
						let brClose = this.parsedCode.tokenList.getCloseToken(prevToken);
						if(brClose != null && !this.parsedCode.tokenList.isSameLine(prevToken,brClose) && !this.config.indentObjectLiteral) {
							continue;
						}
					} else {
						continue;
					}
					break;
				case 15:case 19:
					if(!this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
						continue;
					}
					break;
				default:
				}
				break;
			default:
			}
			if(!mustIndent && this.parsedCode.tokenList.isSameLineBetween(currentToken,prevToken,false)) {
				continue;
			}
			if(!this.isIndentingToken(currentToken)) {
				continue;
			}
			lastIndentingToken = currentToken;
			++count;
		}
		return count;
	}
	isFieldLevelVar(indentingTokensCandidates) {
		let tokens = indentingTokensCandidates.slice();
		tokens.reverse();
		let _g = 0;
		while(_g < tokens.length) {
			let token = tokens[_g];
			++_g;
			let _g1 = token.tok;
			switch(_g1._hx_index) {
			case 1:
				switch(_g1.k._hx_index) {
				case 0:
					return false;
				case 2:
					return true;
				case 41:
					break;
				default:
				}
				break;
			case 2:
				let _g2 = _g1.c;
				let tmp = _g2._hx_index == 3;
				break;
			case 6:
				if(_g1.op._hx_index == 4) {
					return true;
				}
				break;
			default:
			}
		}
		return false;
	}
	calcFromCandidates(token) {
		let indentingTokensCandidates = this.findIndentingCandidates(token);
		if(indentingTokensCandidates.length <= 0) {
			return 0;
		}
		let indentComplexValueExpressions = this.config.indentComplexValueExpressions;
		if(this.isFieldLevelVar(indentingTokensCandidates)) {
			indentComplexValueExpressions = true;
		}
		if(indentComplexValueExpressions) {
			indentingTokensCandidates = this.compressElseIfCandidates(indentingTokensCandidates);
		}
		let count = this.countLineBreaks(indentingTokensCandidates,indentComplexValueExpressions);
		if(this.hasConditional(indentingTokensCandidates)) {
			switch(this.config.conditionalPolicy) {
			case "aligned":
				break;
			case "alignedDecrease":
				--count;
				break;
			case "alignedIncrease":
				break;
			case "alignedNestedIncrease":
				count += this.calcConsecutiveConditionalLevel(token);
				break;
			case "fixedZero":
				break;
			case "fixedZeroIncrease":
				--count;
				let conditionalLevel = this.calcConditionalLevel(token);
				if(conditionalLevel == count) {
					++count;
				}
				break;
			case "fixedZeroIncreaseBlocks":
				if(this.hasBlock(indentingTokensCandidates)) {
					--count;
					let conditionalLevel = this.calcConditionalLevel(token);
					if(conditionalLevel == count) {
						++count;
					}
				}
				break;
			}
		}
		return count;
	}
	hasConditional(tokens) {
		let _g = 0;
		while(_g < tokens.length) {
			let token = tokens[_g];
			++_g;
			let _g1 = token.tok;
			if(_g1._hx_index == 3) {
				if(_g1.s == "if") {
					return true;
				}
			}
		}
		return false;
	}
	hasBlock(tokens) {
		let _g = 0;
		while(_g < tokens.length) {
			let token = tokens[_g];
			++_g;
			if(token.tok._hx_index == 17) {
				return true;
			}
		}
		return false;
	}
	hasBlockParent(token) {
		let parent = token.parent;
		while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) if(parent.tok._hx_index == 17) {
			return true;
		} else {
			parent = parent.parent;
		}
		return false;
	}
	findIndentingCandidates(token) {
		let indentingTokensCandidates = [];
		let lastIndentingToken = null;
		if(token.tok._hx_index == 11) {
			lastIndentingToken = token;
		}
		indentingTokensCandidates.push(token);
		let parent = token;
		while(parent.parent != null && parent.parent.tok != tokentree_TokenTreeDef.Root) {
			parent = parent.parent;
			if(parent.pos.min > token.pos.min) {
				continue;
			}
			if(this.isIndentingToken(parent)) {
				if(lastIndentingToken != null) {
					if(lastIndentingToken.is(tokentree_TokenTreeDef.Dot) && parent.is(tokentree_TokenTreeDef.Dot)) {
						continue;
					}
				}
				indentingTokensCandidates.push(parent);
				lastIndentingToken = parent;
			} else if(this.parsedCode.tokenList.isNewLineBefore(parent)) {
				indentingTokensCandidates.push(parent);
				lastIndentingToken = parent;
			}
		}
		return indentingTokensCandidates;
	}
	compressElseIfCandidates(indentingTokensCandidates) {
		let compressedCandidates = [];
		let state = formatter_marker_IndentationCompressElseIf.Copy;
		let _g = 0;
		while(_g < indentingTokensCandidates.length) {
			let token = indentingTokensCandidates[_g];
			++_g;
			let _g1 = token.tok;
			if(_g1._hx_index == 1) {
				switch(_g1.k._hx_index) {
				case 3:
					switch(state._hx_index) {
					case 0:
						if(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse)) != null) {
							state = formatter_marker_IndentationCompressElseIf.SkipElseIf;
						}
						break;
					case 1:
						state = formatter_marker_IndentationCompressElseIf.SkipElseIf;
						break;
					case 2:
						continue;
					}
					break;
				case 4:
					if(state == formatter_marker_IndentationCompressElseIf.SeenElse || state == formatter_marker_IndentationCompressElseIf.SkipElseIf) {
						state = formatter_marker_IndentationCompressElseIf.SkipElseIf;
						continue;
					}
					state = formatter_marker_IndentationCompressElseIf.SeenElse;
					break;
				default:
					state = formatter_marker_IndentationCompressElseIf.Copy;
				}
			} else {
				state = formatter_marker_IndentationCompressElseIf.Copy;
			}
			compressedCandidates.push(token);
		}
		return compressedCandidates;
	}
	isIndentingToken(token) {
		if(token == null) {
			return false;
		}
		let _g = token.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				return true;
			case 2:
				return true;
			case 3:case 4:
				return true;
			case 5:
				let parent = token.parent;
				if(parent != null && parent.is(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdDo))) {
					return false;
				}
				return true;
			case 6:case 7:
				return true;
			case 10:case 28:
				return true;
			case 14:case 15:case 16:
				return true;
			case 20:case 21:case 24:
				return true;
			case 22:
				let _g1 = token.parent.tok;
				if(_g1._hx_index == 1) {
					if(_g1.k._hx_index == 0) {
						return false;
					} else {
						return true;
					}
				} else {
					return true;
				}
				break;
			default:
			}
			break;
		case 2:
			let _g2 = _g.c;
			if(_g2._hx_index == 3) {
				switch(_g2.s) {
				case "from":case "to":
					return this.isAbstractFromTo(token);
				default:
				}
			}
			break;
		case 3:
			if(_g.s == "if") {
				switch(this.config.conditionalPolicy) {
				case "aligned":
					return false;
				case "alignedDecrease":case "alignedIncrease":
					return true;
				case "alignedNestedIncrease":
					return false;
				case "fixedZero":
					return false;
				case "fixedZeroIncrease":
					return true;
				case "fixedZeroIncreaseBlocks":
					return this.hasBlockParent(token);
				}
			}
			break;
		case 6:
			let _g3 = _g.op;
			switch(_g3._hx_index) {
			case 4:
				return true;
			case 9:
				return tokentree_utils_TokenTreeCheckUtils.isTypeParameter(token);
			case 20:
				let _g4 = _g3.op;
				return true;
			default:
			}
			break;
		case 12:
			if(token.parent.is(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdCase)) || token.parent.is(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdDefault))) {
				return true;
			}
			let info = this.parsedCode.tokenList.getTokenAt(token.index);
			if(info == null) {
				return false;
			}
			switch(info.whitespaceAfter._hx_index) {
			case 0:case 1:
				return false;
			case 2:
				return true;
			}
			break;
		case 13:
			return true;
		case 11:case 15:case 17:case 19:
			return true;
		default:
		}
		return false;
	}
	isAbstractFromTo(token) {
		let parent = token.parent;
		if(parent == null) {
			return false;
		}
		let _g = parent.tok;
		if(_g._hx_index == 2) {
			let _g1 = _g.c;
			if(_g1._hx_index == 3) {
				let _g = _g1.s;
			} else {
				return false;
			}
		} else {
			return false;
		}
		parent = parent.parent;
		if(parent == null) {
			return false;
		}
		let _g1 = parent.tok;
		if(_g1._hx_index == 1) {
			if(_g1.k._hx_index == 39) {
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}
}
$hxClasses["formatter.marker.Indenter"] = formatter_marker_Indenter;
formatter_marker_Indenter.__name__ = "formatter.marker.Indenter";
Object.assign(formatter_marker_Indenter.prototype, {
	__class__: formatter_marker_Indenter
	,config: null
	,parsedCode: null
});
var formatter_marker_IndentationCompressElseIf = $hxEnums["formatter.marker.IndentationCompressElseIf"] = { __ename__ : true, __constructs__ : ["Copy","SeenElse","SkipElseIf"]
	,Copy: {_hx_index:0,__enum__:"formatter.marker.IndentationCompressElseIf",toString:$estr}
	,SeenElse: {_hx_index:1,__enum__:"formatter.marker.IndentationCompressElseIf",toString:$estr}
	,SkipElseIf: {_hx_index:2,__enum__:"formatter.marker.IndentationCompressElseIf",toString:$estr}
};
class formatter_marker_MarkerBase {
	constructor(config,parsedCode,indenter) {
		this.config = config;
		this.parsedCode = parsedCode;
		this.indenter = indenter;
	}
	getCloseToken(token) {
		return this.parsedCode.tokenList.getCloseToken(token);
	}
	getNextToken(token) {
		return this.parsedCode.tokenList.getNextToken(token);
	}
	getPreviousToken(token) {
		return this.parsedCode.tokenList.getPreviousToken(token);
	}
	getTokenAt(index) {
		return this.parsedCode.tokenList.getTokenAt(index);
	}
	whitespace(token,where) {
		this.parsedCode.tokenList.whitespace(token,where);
	}
	spacesBefore(token,count) {
		this.parsedCode.tokenList.spacesBefore(token,count);
	}
	lineEndAfter(token) {
		this.parsedCode.tokenList.lineEndAfter(token);
	}
	lineEndBefore(token) {
		this.parsedCode.tokenList.lineEndBefore(token);
	}
	noLineEndAfter(token) {
		this.parsedCode.tokenList.noLineEndAfter(token);
	}
	noLineEndBefore(token) {
		this.parsedCode.tokenList.noLineEndBefore(token);
	}
	emptyLinesAfter(token,count) {
		this.parsedCode.tokenList.emptyLinesAfter(token,count);
	}
	emptyLinesBefore(token,count) {
		this.parsedCode.tokenList.emptyLinesBefore(token,count);
	}
	emptyLinesAfterSubTree(token,count) {
		this.parsedCode.tokenList.emptyLinesAfterSubTree(token,count);
	}
	tokenText(token,text) {
		this.parsedCode.tokenList.tokenText(token,text);
	}
	wrapAfter(token,wrap) {
		this.parsedCode.tokenList.wrapAfter(token,wrap);
	}
	wrapBefore(token,wrap) {
		this.parsedCode.tokenList.wrapBefore(token,wrap);
	}
	noWrappingBetween(tokenStart,tokenEnd,allowCommas) {
		if(allowCommas == null) {
			allowCommas = true;
		}
		this.parsedCode.tokenList.noWrappingBetween(tokenStart,tokenEnd,this.config,allowCommas);
	}
	additionalIndent(token,indent) {
		this.parsedCode.tokenList.additionalIndent(token,indent);
	}
	increaseIndentBetween(start,end,depth) {
		this.parsedCode.tokenList.increaseIndentBetween(start,end,depth);
	}
	findTokenAtOffset(offset) {
		return this.parsedCode.tokenList.findTokenAtOffset(offset);
	}
	isSameLine(first,second) {
		return this.parsedCode.tokenList.isSameLine(first,second);
	}
	calcLength(token) {
		return this.parsedCode.tokenList.calcLength(token);
	}
	isMultilineToken(token) {
		return this.parsedCode.tokenList.isMultilineToken(token);
	}
	calcLengthUntilNewline(token,stop) {
		return this.parsedCode.tokenList.calcLengthUntilNewline(token,stop);
	}
	calcLengthBetween(tokenStart,tokenEnd) {
		return this.parsedCode.tokenList.calcLengthBetween(tokenStart,tokenEnd);
	}
	calcLineLength(token) {
		return this.parsedCode.tokenList.calcLineLength(token);
	}
	calcLineLengthBefore(token) {
		return this.parsedCode.tokenList.calcLineLengthBefore(token);
	}
	calcLineLengthAfter(token) {
		return this.parsedCode.tokenList.calcLineLengthAfter(token);
	}
	calcTokenLength(token) {
		return this.parsedCode.tokenList.calcTokenLength(token);
	}
	isNewLineBefore(token) {
		return this.parsedCode.tokenList.isNewLineBefore(token);
	}
	isNewLineAfter(token) {
		return this.parsedCode.tokenList.isNewLineAfter(token);
	}
	isSameLineBetween(tokenStart,tokenEnd,exclude) {
		return this.parsedCode.tokenList.isSameLineBetween(tokenStart,tokenEnd,exclude);
	}
	findLineStartToken(token) {
		return this.parsedCode.tokenList.findLineStartToken(token);
	}
}
$hxClasses["formatter.marker.MarkerBase"] = formatter_marker_MarkerBase;
formatter_marker_MarkerBase.__name__ = "formatter.marker.MarkerBase";
Object.assign(formatter_marker_MarkerBase.prototype, {
	__class__: formatter_marker_MarkerBase
	,config: null
	,parsedCode: null
	,indenter: null
});
class formatter_marker_MarkAdditionalIndentation extends formatter_marker_MarkerBase {
	constructor(config,parsedCode,indenter) {
		super(config,parsedCode,indenter);
	}
	run() {
		let _gthis = this;
		this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 3) {
				if(_g.s == "if") {
					_gthis.markBlockBreakingConditional(token,_gthis.calcDepthDifferenceLeftCurly(token));
					_gthis.markBlockBreakingConditional(token,_gthis.calcDepthDifferenceRightCurly(token));
				}
			}
			return tokentree_FilterResult.GoDeeper;
		});
	}
	markBlockBreakingConditional(token,depthDifference) {
		if(token.children == null) {
			return;
		}
		let start = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Sharp("end"));
		if(start == null) {
			return;
		}
		if(depthDifference == 0) {
			return;
		}
		if(depthDifference < 0) {
			start = token;
		}
		let parent = token.parent;
		let topLevelToken = null;
		while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) {
			topLevelToken = parent;
			parent = parent.parent;
		}
		if(topLevelToken == null) {
			return;
		}
		let sibling = topLevelToken.nextSibling;
		while(sibling != null) if(sibling.tok._hx_index == 18) {
			this.increaseIndentBetween(start,sibling,depthDifference);
			return;
		} else {
			sibling = sibling.nextSibling;
		}
		this.increaseIndentBetween(start,tokentree_utils_TokenTreeCheckUtils.getLastToken(topLevelToken),depthDifference);
	}
	calcDepthDifferenceLeftCurly(token) {
		if(token.children == null) {
			return 0;
		}
		let depthIncrease = 0;
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let brOpens = child.filterCallback(function(token,index) {
				let _g = token.tok;
				switch(_g._hx_index) {
				case 3:
					let _g1 = _g.s;
					return tokentree_FilterResult.SkipSubtree;
				case 17:
					return tokentree_FilterResult.FoundGoDeeper;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			});
			if(brOpens.length <= 0) {
				continue;
			}
			let depth = 0;
			let _g2 = 0;
			while(_g2 < brOpens.length) {
				let brOpen = brOpens[_g2];
				++_g2;
				if(tokentree_TokenTreeAccessHelper.firstOf(brOpen,tokentree_TokenTreeDef.BrClose) != null) {
					continue;
				}
				++depth;
			}
			if(depth > depthIncrease) {
				depthIncrease = depth;
			}
		}
		return depthIncrease;
	}
	calcDepthDifferenceRightCurly(token) {
		if(token.children == null) {
			return 0;
		}
		let depthDecrease = 0;
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let brClose = child.filterCallback(function(token,index) {
				if(token.tok._hx_index == 18) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			});
			if(brClose.length <= 0) {
				continue;
			}
			let depth = 0;
			let _g2 = 0;
			while(_g2 < brClose.length) {
				let brClose1 = brClose[_g2];
				++_g2;
				if(tokentree_TokenTreeAccessHelper.is(tokentree_TokenTreeAccessHelper.parent(brClose1),tokentree_TokenTreeDef.BrOpen) != null) {
					continue;
				}
				++depth;
			}
			if(depth > depthDecrease) {
				depthDecrease = depth;
			}
		}
		return -depthDecrease;
	}
}
$hxClasses["formatter.marker.MarkAdditionalIndentation"] = formatter_marker_MarkAdditionalIndentation;
formatter_marker_MarkAdditionalIndentation.__name__ = "formatter.marker.MarkAdditionalIndentation";
formatter_marker_MarkAdditionalIndentation.__super__ = formatter_marker_MarkerBase;
Object.assign(formatter_marker_MarkAdditionalIndentation.prototype, {
	__class__: formatter_marker_MarkAdditionalIndentation
});
class formatter_marker_MarkEmptyLines extends formatter_marker_MarkerBase {
	constructor(config,parsedCode,indenter) {
		super(config,parsedCode,indenter);
	}
	run() {
		this.keepExistingEmptyLines();
		let packs = this.parsedCode.root.filter([tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdPackage)],tokentree_TokenFilterMode.All);
		packs.reverse();
		let _g = 0;
		while(_g < packs.length) {
			let pack = packs[_g];
			++_g;
			if(tokentree_utils_TokenTreeCheckUtils.isMetadata(pack)) {
				continue;
			}
			this.emptyLinesBefore(pack,this.config.emptyLines.beforePackage);
			this.emptyLinesAfter(pack,this.config.emptyLines.afterPackage);
		}
		this.betweenTypes();
		this.markImports();
		this.markClassesAndAbstracts();
		this.markMacroClasses();
		this.markInterfaces();
		this.markEnums();
		this.markTypedefs();
		this.markSharp();
		if(this.config.emptyLines.beforeDocCommentEmptyLines != "ignore" || this.config.emptyLines.afterFieldsWithDocComments != "ignore") {
			this.markDocComments();
		}
		this.markMultilineComments();
		this.markFileHeader();
		if(this.config.emptyLines.beforeRightCurly == "remove") {
			this.markRightCurly();
		}
		if(this.config.emptyLines.afterLeftCurly == "remove") {
			this.markLeftCurly();
		}
		if(this.config.emptyLines.afterReturn == "remove") {
			this.markReturn();
		}
		if(this.config.emptyLines.beforeBlocks == "remove" || this.config.emptyLines.afterBlocks == "remove") {
			this.markAroundBlocks();
		}
	}
	finalRun(codeLines) {
		if(codeLines.lines.length <= 0) {
			return;
		}
		let _g = 0;
		let _g1 = codeLines.lines;
		while(_g < _g1.length) {
			let line = _g1[_g];
			++_g;
			if(line.verbatim) {
				continue;
			}
			if(line.emptyLinesAfter > this.config.emptyLines.maxAnywhereInFile) {
				line.emptyLinesAfter = this.config.emptyLines.maxAnywhereInFile;
			}
		}
		let lastLine = codeLines.lines[codeLines.lines.length - 1];
		if(lastLine.verbatim) {
			return;
		}
		lastLine.emptyLinesAfter = this.config.emptyLines.finalNewline ? 1 : 0;
	}
	markImports() {
		let imports = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 13:case 35:
					if(tokentree_utils_TokenTreeCheckUtils.isMetadata(token)) {
						return tokentree_FilterResult.SkipSubtree;
					} else {
						return tokentree_FilterResult.FoundSkipSubtree;
					}
					break;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		if(imports.length <= 0) {
			return;
		}
		let lastImport = imports[imports.length - 1];
		let lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(lastImport);
		let afterImport = this.getNextToken(lastChild);
		if(afterImport != null) {
			let _g = afterImport.token.tok;
			if(_g._hx_index == 3) {
				switch(_g.s) {
				case "else":case "elseif":
					break;
				case "end":
					this.emptyLinesAfterSubTree(afterImport.token,this.config.emptyLines.importAndUsing.beforeType);
					break;
				default:
					this.emptyLinesAfterSubTree(lastImport,this.config.emptyLines.importAndUsing.beforeType);
				}
			} else {
				this.emptyLinesAfterSubTree(lastImport,this.config.emptyLines.importAndUsing.beforeType);
			}
		}
		lastImport = null;
		let prevInfo = null;
		let _g = 0;
		while(_g < imports.length) {
			let token = imports[_g];
			++_g;
			let newInfo = this.getImportInfo(token);
			let lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
			let next = this.getNextToken(lastToken);
			if(next != null) {
				let _g = next.token.tok;
				if(_g._hx_index == 3) {
					if(_g.s == "end") {
						newInfo.token = next.token;
					}
				}
			}
			if(prevInfo == null) {
				prevInfo = newInfo;
				continue;
			}
			if(prevInfo.isImport == newInfo.isImport) {
				switch(this.config.emptyLines.importAndUsing.betweenImportsLevel) {
				case "all":
					this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					break;
				case "fifthLevelPackage":
					if(prevInfo.fifthLevelPackage != newInfo.fifthLevelPackage) {
						this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					}
					break;
				case "firstLevelPackage":
					if(prevInfo.firstLevelPackage != newInfo.firstLevelPackage) {
						this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					}
					break;
				case "fourthLevelPackage":
					if(prevInfo.fourthLevelPackage != newInfo.fourthLevelPackage) {
						this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					}
					break;
				case "fullPackage":
					if(prevInfo.fullPackage != newInfo.fullPackage) {
						this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					}
					break;
				case "secondLevelPackage":
					if(prevInfo.secondLevelPackage != newInfo.secondLevelPackage) {
						this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					}
					break;
				case "thirdLevelPackage":
					if(prevInfo.thirdLevelPackage != newInfo.thirdLevelPackage) {
						this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					}
					break;
				}
			} else {
				this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.beforeUsing);
			}
			prevInfo = newInfo;
		}
	}
	getImportInfo(token) {
		let info = { token : token, isImport : false, firstLevelPackage : "", secondLevelPackage : "", thirdLevelPackage : "", fourthLevelPackage : "", fifthLevelPackage : "", fullPackage : "", moduleName : ""};
		let _g = token.tok;
		if(_g._hx_index == 1) {
			switch(_g.k._hx_index) {
			case 13:
				info.isImport = true;
				break;
			case 35:
				info.isImport = false;
				break;
			default:
			}
		}
		let parts = [];
		token = token.getFirstChild();
		while(true) {
			let _g = token.tok;
			switch(_g._hx_index) {
			case 1:
				let _g1 = _g.k;
				parts.push("" + Std.string(token));
				break;
			case 2:
				let _g2 = _g.c;
				if(_g2._hx_index == 3) {
					let text = _g2.s;
					parts.push(text);
				}
				break;
			default:
			}
			token = token.getFirstChild();
			if(token == null || !token.is(tokentree_TokenTreeDef.Dot)) {
				break;
			}
			token = token.getFirstChild();
			if(token == null) {
				break;
			}
		}
		info.moduleName = parts.pop();
		info.fullPackage = parts.join(".");
		if(parts.length > 0) {
			info.firstLevelPackage = parts[0];
		}
		if(parts.length > 1) {
			info.secondLevelPackage = parts.slice(0,2).join(".");
		} else {
			info.secondLevelPackage = info.firstLevelPackage;
		}
		if(parts.length > 2) {
			info.thirdLevelPackage = parts.slice(0,3).join(".");
		} else {
			info.thirdLevelPackage = info.secondLevelPackage;
		}
		if(parts.length > 3) {
			info.fourthLevelPackage = parts.slice(0,4).join(".");
		} else {
			info.fourthLevelPackage = info.thirdLevelPackage;
		}
		if(parts.length > 4) {
			info.fifthLevelPackage = parts.slice(0,5).join(".");
		} else {
			info.fifthLevelPackage = info.fourthLevelPackage;
		}
		return info;
	}
	markClassesAndAbstracts() {
		let classes = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 1:case 39:
					return tokentree_FilterResult.FoundSkipSubtree;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < classes.length) {
			let c = classes[_g];
			++_g;
			if(tokentree_utils_TokenTreeCheckUtils.isTypeEnumAbstract(c)) {
				this.markEnumAbstracts(c);
				continue;
			}
			let typeConfig = null;
			let _g1 = c.tok;
			if(_g1._hx_index == 1) {
				switch(_g1.k._hx_index) {
				case 1:
					typeConfig = this.config.emptyLines.classEmptyLines;
					if(tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(c),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdExtern)) != null) {
						this.markExternClass(c,this.config.emptyLines.externClassEmptyLines);
						continue;
					}
					break;
				case 39:
					typeConfig = this.config.emptyLines.abstractEmptyLines;
					break;
				default:
					continue;
				}
			} else {
				continue;
			}
			let block = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(c),tokentree_TokenTreeDef.BrOpen);
			this.markBeginAndEndType(block,typeConfig.beginType,typeConfig.endType);
			let finalTokDef = haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdFinal);
			let fields = this.findClassAndAbstractFields(c);
			let prevToken = null;
			let prevTokenType = null;
			let currToken = null;
			let currTokenType = null;
			let _g2 = 0;
			while(_g2 < fields.length) {
				let field = fields[_g2];
				++_g2;
				currToken = field;
				currTokenType = tokentree_utils_FieldUtils.getFieldType(field,tokentree_utils_TokenFieldVisibility.Private);
				this.markClassFieldEmptyLines(prevToken,prevTokenType,currToken,currTokenType,typeConfig);
				prevToken = currToken;
				prevTokenType = currTokenType;
			}
		}
	}
	markMacroClasses() {
		let classes = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 1) {
					if(token.parent == null || token.parent.tok == tokentree_TokenTreeDef.Root) {
						return tokentree_FilterResult.GoDeeper;
					}
					let _g = token.parent.tok;
					if(_g._hx_index == 1) {
						if(_g.k._hx_index == 40) {
							return tokentree_FilterResult.FoundSkipSubtree;
						} else {
							return tokentree_FilterResult.GoDeeper;
						}
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < classes.length) {
			let c = classes[_g];
			++_g;
			let typeConfig = this.config.emptyLines.macroClassEmptyLines;
			let block = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(c),tokentree_TokenTreeDef.BrOpen);
			this.markBeginAndEndType(block,typeConfig.beginType,typeConfig.endType);
			let finalTokDef = haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdFinal);
			let functions = this.findClassAndAbstractFields(c);
			let prevToken = null;
			let prevTokenType = null;
			let currToken = null;
			let currTokenType = null;
			let _g1 = 0;
			while(_g1 < functions.length) {
				let func = functions[_g1];
				++_g1;
				currToken = func;
				currTokenType = tokentree_utils_FieldUtils.getFieldType(func,tokentree_utils_TokenFieldVisibility.Private);
				this.markClassFieldEmptyLines(prevToken,prevTokenType,currToken,currTokenType,typeConfig);
				prevToken = currToken;
				prevTokenType = currTokenType;
			}
		}
	}
	findClassAndAbstractFields(c) {
		return c.filterCallback(function(token,index) {
			let _g = token.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:case 2:
					return tokentree_FilterResult.FoundSkipSubtree;
				case 41:
					return tokentree_FilterResult.FoundSkipSubtree;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
				break;
			case 2:
				let _g1 = _g.c;
				if(_g1._hx_index == 3) {
					if(_g1.s == "final") {
						return tokentree_FilterResult.FoundSkipSubtree;
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
				break;
			case 22:
				return tokentree_FilterResult.SkipSubtree;
			default:
				return tokentree_FilterResult.GoDeeper;
			}
		});
	}
	markBeginAndEndType(brOpen,beginType,endType) {
		if(brOpen == null) {
			return;
		}
		this.emptyLinesAfter(brOpen,beginType);
		let brClose = this.getCloseToken(brOpen);
		if(brClose == null) {
			return;
		}
		this.emptyLinesBefore(brClose,endType);
	}
	markClassFieldEmptyLines(prevToken,prevTokenType,currToken,currTokenType,conf) {
		if(prevToken == null) {
			return;
		}
		let prevVar = false;
		let currVar = false;
		let prevStatic = false;
		let currStatic = false;
		let prevPrivate = false;
		let currPrivate = false;
		switch(prevTokenType._hx_index) {
		case 0:
			let isExtern = prevTokenType.isExtern;
			let isFinal = prevTokenType.isFinal;
			let isOverride = prevTokenType.isOverride;
			let isInline = prevTokenType.isInline;
			let isStatic = prevTokenType.isStatic;
			let visibility = prevTokenType.visibility;
			let name = prevTokenType.name;
			prevVar = false;
			prevStatic = isStatic;
			prevPrivate = visibility == tokentree_utils_TokenFieldVisibility.Private;
			break;
		case 1:
			let isExtern1 = prevTokenType.isExtern;
			let isFinal1 = prevTokenType.isFinal;
			let isInline1 = prevTokenType.isInline;
			let isStatic1 = prevTokenType.isStatic;
			let visibility1 = prevTokenType.visibility;
			let name1 = prevTokenType.name;
			prevVar = true;
			prevStatic = isStatic1;
			prevPrivate = visibility1 == tokentree_utils_TokenFieldVisibility.Private;
			break;
		case 2:
			let setter = prevTokenType.setter;
			let getter = prevTokenType.getter;
			let isStatic2 = prevTokenType.isStatic;
			let visibility2 = prevTokenType.visibility;
			let name2 = prevTokenType.name;
			prevVar = true;
			prevStatic = isStatic2;
			prevPrivate = visibility2 == tokentree_utils_TokenFieldVisibility.Private;
			break;
		case 3:
			return;
		}
		switch(currTokenType._hx_index) {
		case 0:
			let isExtern2 = currTokenType.isExtern;
			let isFinal2 = currTokenType.isFinal;
			let isOverride1 = currTokenType.isOverride;
			let isInline2 = currTokenType.isInline;
			let isStatic3 = currTokenType.isStatic;
			let visibility3 = currTokenType.visibility;
			let name3 = currTokenType.name;
			currVar = false;
			currStatic = isStatic3;
			currPrivate = visibility3 == tokentree_utils_TokenFieldVisibility.Private;
			break;
		case 1:
			let isExtern3 = currTokenType.isExtern;
			let isFinal3 = currTokenType.isFinal;
			let isInline3 = currTokenType.isInline;
			let isStatic4 = currTokenType.isStatic;
			let visibility4 = currTokenType.visibility;
			let name4 = currTokenType.name;
			currVar = true;
			currStatic = isStatic4;
			currPrivate = visibility4 == tokentree_utils_TokenFieldVisibility.Private;
			break;
		case 2:
			let setter1 = currTokenType.setter;
			let getter1 = currTokenType.getter;
			let isStatic5 = currTokenType.isStatic;
			let visibility5 = currTokenType.visibility;
			let name5 = currTokenType.name;
			currVar = true;
			currStatic = isStatic5;
			currPrivate = visibility5 == tokentree_utils_TokenFieldVisibility.Private;
			break;
		case 3:
			return;
		}
		if(!currVar) {
			this.markLineCommentsBefore(currToken,this.config.emptyLines.lineCommentsBetweenFunctions);
			this.markLineCommentsAfter(currToken,1);
		}
		prevToken = this.skipSharpFields(prevToken);
		if(prevToken == null) {
			return;
		}
		if(conf.existingBetweenFields == "keep") {
			if(this.hasEmptyLinesBetweenFields(prevToken,currToken)) {
				this.emptyLinesAfterSubTree(prevToken,1);
				return;
			}
		}
		if(prevVar != currVar) {
			this.emptyLinesAfterSubTree(prevToken,conf.afterVars);
			return;
		}
		if(prevVar) {
			if(prevStatic != currStatic) {
				this.emptyLinesAfterSubTree(prevToken,conf.afterStaticVars);
				return;
			}
			if(prevStatic) {
				this.emptyLinesAfterSubTree(prevToken,conf.betweenStaticVars);
				return;
			}
			if(prevPrivate != currPrivate) {
				this.emptyLinesAfterSubTree(prevToken,conf.afterPrivateVars);
				return;
			}
			this.emptyLinesAfterSubTree(prevToken,conf.betweenVars);
			return;
		} else {
			if(prevStatic != currStatic) {
				this.emptyLinesAfterSubTree(prevToken,conf.afterStaticFunctions);
				return;
			}
			if(prevStatic) {
				this.emptyLinesAfterSubTree(prevToken,conf.betweenStaticFunctions);
				return;
			}
			if(prevPrivate != currPrivate) {
				this.emptyLinesAfterSubTree(prevToken,conf.afterPrivateFunctions);
				return;
			}
			this.emptyLinesAfterSubTree(prevToken,conf.betweenFunctions);
			return;
		}
	}
	hasEmptyLinesBetweenFields(prevToken,currToken) {
		let lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(prevToken);
		if(lastToken == null) {
			return false;
		}
		let prevLine = this.parsedCode.getLinePos(lastToken.pos.max).line;
		let currLine = this.parsedCode.getLinePos(currToken.pos.min).line;
		let _g = 0;
		let _g1 = this.parsedCode.emptyLines;
		while(_g < _g1.length) {
			let emptyLine = _g1[_g];
			++_g;
			if(prevLine >= emptyLine) {
				continue;
			}
			if(currLine > emptyLine) {
				return true;
			}
			return false;
		}
		return false;
	}
	markLineCommentsBefore(token,policy) {
		if(policy == "none") {
			return;
		}
		if(token.previousSibling == null) {
			return;
		}
		let prev = token.previousSibling;
		while(prev != null) {
			let _g = prev.tok;
			switch(_g._hx_index) {
			case 7:
				let _g1 = _g.s;
				break;
			case 8:
				let _g2 = _g.s;
				let prevInfo = this.getPreviousToken(prev);
				if(prevInfo == null || prevInfo.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
					switch(policy) {
					case "keep":
						if(this.parsedCode.linesBetweenOriginal(prev,token) > 1) {
							this.emptyLinesAfter(prev,1);
						}
						break;
					case "none":
						break;
					case "one":
						this.emptyLinesAfter(prev,1);
						break;
					}
				}
				return;
			default:
				return;
			}
			prev = prev.previousSibling;
		}
	}
	markLineCommentsAfter(token,count) {
		if(count <= 0) {
			return;
		}
		if(token.nextSibling == null) {
			return;
		}
		let next = token.nextSibling;
		let _g = next.tok;
		if(_g._hx_index == 8) {
			let _g1 = _g.s;
			if(this.isNewLineBefore(next)) {
				this.emptyLinesBefore(next,count);
			}
		}
	}
	markExternClass(c,conf) {
		let block = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(c),tokentree_TokenTreeDef.BrOpen);
		if(block == null) {
			return;
		}
		this.markBeginAndEndType(block,conf.beginType,conf.endType);
		let fields = this.findClassAndAbstractFields(block);
		let prevToken = null;
		let prevTokenType = null;
		let currToken = null;
		let currTokenType = null;
		let _g = 0;
		while(_g < fields.length) {
			let field = fields[_g];
			++_g;
			currToken = field;
			currTokenType = tokentree_utils_FieldUtils.getFieldType(field,tokentree_utils_TokenFieldVisibility.Public);
			this.markInterfaceEmptyLines(prevToken,prevTokenType,currToken,currTokenType,conf);
			prevToken = currToken;
			prevTokenType = currTokenType;
		}
	}
	markInterfaces() {
		let interfaces = this.parsedCode.root.filter([tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdInterface)],tokentree_TokenFilterMode.All);
		let _g = 0;
		while(_g < interfaces.length) {
			let i = interfaces[_g];
			++_g;
			this.markExternClass(i,this.config.emptyLines.interfaceEmptyLines);
		}
	}
	markInterfaceEmptyLines(prevToken,prevTokenType,currToken,currTokenType,conf) {
		if(prevToken == null) {
			return;
		}
		let prevVar = false;
		let currVar = false;
		switch(prevTokenType._hx_index) {
		case 0:
			let _g = prevTokenType.isExtern;
			let _g1 = prevTokenType.isFinal;
			let _g2 = prevTokenType.isOverride;
			let _g3 = prevTokenType.isInline;
			let _g4 = prevTokenType.isStatic;
			let _g5 = prevTokenType.visibility;
			let name = prevTokenType.name;
			prevVar = false;
			break;
		case 1:
			let _g6 = prevTokenType.isExtern;
			let _g7 = prevTokenType.isFinal;
			let _g8 = prevTokenType.isInline;
			let _g9 = prevTokenType.isStatic;
			let _g10 = prevTokenType.visibility;
			let name1 = prevTokenType.name;
			prevVar = true;
			break;
		case 2:
			let _g11 = prevTokenType.setter;
			let _g12 = prevTokenType.getter;
			let _g13 = prevTokenType.isStatic;
			let _g14 = prevTokenType.visibility;
			let name2 = prevTokenType.name;
			prevVar = true;
			break;
		case 3:
			return;
		}
		switch(currTokenType._hx_index) {
		case 0:
			let _g15 = currTokenType.isExtern;
			let _g16 = currTokenType.isFinal;
			let _g17 = currTokenType.isOverride;
			let _g18 = currTokenType.isInline;
			let _g19 = currTokenType.isStatic;
			let _g20 = currTokenType.visibility;
			let name3 = currTokenType.name;
			currVar = false;
			break;
		case 1:
			let _g21 = currTokenType.isExtern;
			let _g22 = currTokenType.isFinal;
			let _g23 = currTokenType.isInline;
			let _g24 = currTokenType.isStatic;
			let _g25 = currTokenType.visibility;
			let name4 = currTokenType.name;
			currVar = true;
			break;
		case 2:
			let _g26 = currTokenType.setter;
			let _g27 = currTokenType.getter;
			let _g28 = currTokenType.isStatic;
			let _g29 = currTokenType.visibility;
			let name5 = currTokenType.name;
			currVar = true;
			break;
		case 3:
			return;
		}
		prevToken = this.skipSharpFields(prevToken);
		if(prevToken == null) {
			return;
		}
		if(conf.existingBetweenFields == "keep") {
			if(this.hasEmptyLinesBetweenFields(prevToken,currToken)) {
				this.emptyLinesAfterSubTree(prevToken,1);
				return;
			}
		}
		if(prevVar != currVar) {
			this.emptyLinesAfterSubTree(prevToken,conf.afterVars);
			return;
		}
		if(prevVar) {
			this.emptyLinesAfterSubTree(prevToken,conf.betweenVars);
			return;
		} else {
			this.emptyLinesAfterSubTree(prevToken,conf.betweenFunctions);
			return;
		}
	}
	markEnumAbstracts(token) {
		let block = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(token),tokentree_TokenTreeDef.BrOpen);
		this.markBeginAndEndType(block,this.config.emptyLines.enumAbstractEmptyLines.beginType,this.config.emptyLines.enumAbstractEmptyLines.endType);
		let functions = this.findClassAndAbstractFields(token);
		let prevToken = null;
		let prevTokenType = null;
		let currToken = null;
		let currTokenType = null;
		let _g = 0;
		while(_g < functions.length) {
			let func = functions[_g];
			++_g;
			currToken = func;
			currTokenType = tokentree_utils_FieldUtils.getFieldType(func,tokentree_utils_TokenFieldVisibility.Public);
			this.markEnumAbstractFieldEmptyLines(prevToken,prevTokenType,currToken,currTokenType);
			prevToken = currToken;
			prevTokenType = currTokenType;
		}
	}
	markEnumAbstractFieldEmptyLines(prevToken,prevTokenType,currToken,currTokenType) {
		if(prevToken == null) {
			return;
		}
		let prevVar = false;
		let currVar = false;
		switch(prevTokenType._hx_index) {
		case 0:
			let isExtern = prevTokenType.isExtern;
			let isFinal = prevTokenType.isFinal;
			let isOverride = prevTokenType.isOverride;
			let isInline = prevTokenType.isInline;
			let isStatic = prevTokenType.isStatic;
			let visibility = prevTokenType.visibility;
			let name = prevTokenType.name;
			prevVar = false;
			break;
		case 1:
			let isExtern1 = prevTokenType.isExtern;
			let isFinal1 = prevTokenType.isFinal;
			let isInline1 = prevTokenType.isInline;
			let isStatic1 = prevTokenType.isStatic;
			let visibility1 = prevTokenType.visibility;
			let name1 = prevTokenType.name;
			prevVar = true;
			break;
		case 2:
			let setter = prevTokenType.setter;
			let getter = prevTokenType.getter;
			let isStatic2 = prevTokenType.isStatic;
			let visibility2 = prevTokenType.visibility;
			let name2 = prevTokenType.name;
			prevVar = true;
			break;
		case 3:
			return;
		}
		switch(currTokenType._hx_index) {
		case 0:
			let isExtern2 = currTokenType.isExtern;
			let isFinal2 = currTokenType.isFinal;
			let isOverride1 = currTokenType.isOverride;
			let isInline2 = currTokenType.isInline;
			let isStatic3 = currTokenType.isStatic;
			let visibility3 = currTokenType.visibility;
			let name3 = currTokenType.name;
			currVar = false;
			break;
		case 1:
			let isExtern3 = currTokenType.isExtern;
			let isFinal3 = currTokenType.isFinal;
			let isInline3 = currTokenType.isInline;
			let isStatic4 = currTokenType.isStatic;
			let visibility4 = currTokenType.visibility;
			let name4 = currTokenType.name;
			currVar = true;
			break;
		case 2:
			let setter1 = currTokenType.setter;
			let getter1 = currTokenType.getter;
			let isStatic5 = currTokenType.isStatic;
			let visibility5 = currTokenType.visibility;
			let name5 = currTokenType.name;
			currVar = true;
			break;
		case 3:
			return;
		}
		prevToken = this.skipSharpFields(prevToken);
		if(prevToken == null) {
			return;
		}
		if(prevVar != currVar) {
			this.emptyLinesAfterSubTree(prevToken,this.config.emptyLines.enumAbstractEmptyLines.afterVars);
			return;
		}
		if(prevVar) {
			this.emptyLinesAfterSubTree(prevToken,this.config.emptyLines.enumAbstractEmptyLines.betweenVars);
			return;
		} else {
			this.emptyLinesAfterSubTree(prevToken,this.config.emptyLines.enumAbstractEmptyLines.betweenFunctions);
			return;
		}
	}
	markEnums() {
		let enums = this.parsedCode.root.filter([tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdEnum)],tokentree_TokenFilterMode.All);
		let _g = 0;
		while(_g < enums.length) {
			let e = enums[_g];
			++_g;
			if(e.parent.tok != tokentree_TokenTreeDef.Root) {
				let _g = e.parent.tok;
				switch(_g._hx_index) {
				case 2:
					let _g1 = _g.c;
					continue;
				case 12:case 22:
					continue;
				default:
				}
			}
			let block = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(e),tokentree_TokenTreeDef.BrOpen);
			if(block == null) {
				continue;
			}
			this.markEnumFields(block,this.config.emptyLines.enumEmptyLines);
		}
	}
	markEnumFields(block,config) {
		this.markBeginAndEndType(block,config.beginType,config.endType);
		if(block.children == null || block.children.length <= 0) {
			return;
		}
		let prevToken = null;
		let _g = 0;
		let _g1 = block.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			switch(_g2._hx_index) {
			case 7:
				let _g3 = _g2.s;
				continue;
			case 8:
				let _g4 = _g2.s;
				continue;
			case 18:
				return;
			default:
			}
			if(prevToken == null) {
				prevToken = child;
				continue;
			}
			if(config.existingBetweenFields == "keep") {
				if(this.hasEmptyLinesBetweenFields(prevToken,child)) {
					this.emptyLinesAfterSubTree(prevToken,1);
					return;
				}
			}
			this.emptyLinesAfterSubTree(prevToken,config.betweenFields);
			prevToken = child;
		}
	}
	markTypedefs() {
		let typedefs = this.parsedCode.root.filter([tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdTypedef)],tokentree_TokenFilterMode.All);
		let _g = 0;
		while(_g < typedefs.length) {
			let t = typedefs[_g];
			++_g;
			let block = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(t),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign)),tokentree_TokenTreeDef.BrOpen);
			if(block == null) {
				continue;
			}
			this.markEnumFields(block,this.config.emptyLines.typedefEmptyLines);
		}
	}
	skipSharpFields(prevToken) {
		let next = prevToken.nextSibling;
		if(next == null) {
			next = prevToken.parent;
			let _g = next.tok;
			if(_g._hx_index == 3) {
				let _g1 = _g.s;
				next = next.nextSibling;
			} else {
				return prevToken;
			}
		}
		let _g = next.tok;
		if(_g._hx_index == 3) {
			switch(_g.s) {
			case "end":
				return next;
			case "if":
				return prevToken;
			default:
				return null;
			}
		}
		return prevToken;
	}
	betweenTypes() {
		if(this.config.emptyLines.betweenTypes <= 0 && this.config.emptyLines.betweenSingleLineTypes <= 0) {
			return;
		}
		let types = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:case 2:
					return tokentree_FilterResult.FoundSkipSubtree;
				case 1:case 26:case 27:case 31:case 39:
					return tokentree_FilterResult.FoundSkipSubtree;
				case 41:
					return tokentree_FilterResult.FoundSkipSubtree;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
				break;
			case 2:
				let _g1 = _g.c;
				if(_g1._hx_index == 3) {
					if(_g1.s == "final") {
						return tokentree_FilterResult.FoundSkipSubtree;
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
				break;
			default:
				return tokentree_FilterResult.GoDeeper;
			}
		});
		if(types.length <= 1) {
			return;
		}
		let prevTypeInfo = null;
		let _g = 0;
		while(_g < types.length) {
			let type = types[_g];
			++_g;
			let newTypeInfo = this.getTypeInfo(type);
			this.markLineCommentsBefore(type,this.config.emptyLines.lineCommentsBetweenTypes);
			this.markLineCommentsAfter(type,1);
			if(prevTypeInfo == null) {
				prevTypeInfo = newTypeInfo;
				continue;
			}
			let next = this.getNextToken(prevTypeInfo.lastToken);
			if(next != null) {
				let _g = next.token.tok;
				if(_g._hx_index == 3) {
					switch(_g.s) {
					case "else":case "elseif":
						prevTypeInfo = newTypeInfo;
						continue;
					default:
					}
				}
			}
			let emptyLines = this.config.emptyLines.betweenTypes;
			if(prevTypeInfo.oneLine && newTypeInfo.oneLine) {
				emptyLines = this.config.emptyLines.betweenSingleLineTypes;
			}
			this.emptyLinesAfterSubTree(prevTypeInfo.lastToken,emptyLines);
			this.markLineCommentsAfter(prevTypeInfo.typeToken,1);
			prevTypeInfo = newTypeInfo;
		}
	}
	getTypeInfo(token) {
		let info = { lastToken : tokentree_utils_TokenTreeCheckUtils.getLastToken(token), typeToken : token, oneLine : false};
		let start = this.parsedCode.tokenList.findLowestIndex(token);
		if(this.isSameLine(start,info.lastToken)) {
			info.oneLine = true;
		}
		while(true) {
			let next = this.getNextToken(info.lastToken);
			if(next == null) {
				break;
			}
			let _g = next.token.tok;
			if(_g._hx_index == 3) {
				if(_g.s == "end") {
					info.lastToken = next.token;
				} else {
					break;
				}
			} else {
				break;
			}
		}
		return info;
	}
	markLeftCurly() {
		let brOpens = this.parsedCode.root.filter([tokentree_TokenTreeDef.BrOpen],tokentree_TokenFilterMode.All);
		let _g = 0;
		while(_g < brOpens.length) {
			let br = brOpens[_g];
			++_g;
			this.emptyLinesAfter(br,0);
		}
	}
	markRightCurly() {
		let brCloses = this.parsedCode.root.filter([tokentree_TokenTreeDef.BrClose],tokentree_TokenFilterMode.All);
		let _g = 0;
		while(_g < brCloses.length) {
			let br = brCloses[_g];
			++_g;
			this.emptyLinesBefore(br,0);
		}
	}
	markReturn() {
		let returns = this.parsedCode.root.filter([tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdReturn)],tokentree_TokenFilterMode.All);
		let _g = 0;
		while(_g < returns.length) {
			let ret = returns[_g];
			++_g;
			if(this.isReturnBody(ret)) {
				continue;
			}
			let lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(ret);
			if(lastChild == null) {
				continue;
			}
			let next = this.getNextToken(lastChild);
			if(next == null) {
				continue;
			}
			if(next.token.tok._hx_index == 18) {
				this.emptyLinesAfterSubTree(ret,0);
			}
		}
	}
	isReturnBody(ret) {
		let parent = ret.parent;
		while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) {
			let _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				if(_g.k._hx_index == 0) {
					return true;
				} else {
					parent = parent.parent;
				}
				break;
			case 17:
				return false;
			default:
				parent = parent.parent;
			}
		}
		return true;
	}
	markSharp() {
		let sharps = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 3) {
				let _g1 = _g.s;
				return tokentree_FilterResult.FoundGoDeeper;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < sharps.length) {
			let sharp = sharps[_g];
			++_g;
			let prev = this.getPreviousToken(sharp);
			if(prev != null && prev.whitespaceAfter != formatter_codedata_WhitespaceAfterType.Newline) {
				continue;
			}
			let _g1 = sharp.tok;
			if(_g1._hx_index == 3) {
				switch(_g1.s) {
				case "else":
					this.emptyLinesBefore(sharp,this.config.emptyLines.conditionalsEmptyLines.beforeElse);
					this.emptyLinesAfter(sharp,this.config.emptyLines.conditionalsEmptyLines.afterElse);
					break;
				case "elseif":
					this.emptyLinesBefore(sharp,this.config.emptyLines.conditionalsEmptyLines.beforeElse);
					this.emptyLinesAfterSubTree(sharp.getFirstChild(),this.config.emptyLines.conditionalsEmptyLines.afterIf);
					break;
				case "end":
					this.emptyLinesBefore(sharp,this.config.emptyLines.conditionalsEmptyLines.beforeEnd);
					break;
				case "error":
					this.emptyLinesBefore(sharp,this.config.emptyLines.conditionalsEmptyLines.beforeError);
					this.emptyLinesAfterSubTree(sharp,this.config.emptyLines.conditionalsEmptyLines.afterError);
					break;
				case "if":
					this.emptyLinesAfterSubTree(sharp.getFirstChild(),this.config.emptyLines.conditionalsEmptyLines.afterIf);
					break;
				default:
				}
			}
		}
	}
	markDocComments() {
		let comments = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 7) {
				let text = _g.s;
				if(StringTools.startsWith(text,"*")) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < comments.length) {
			let comment = comments[_g];
			++_g;
			let effectiveToken = null;
			effectiveToken = comment;
			if(comment.previousSibling != null) {
				if(comment.parent != null) {
					let _g = comment.parent.tok;
					if(_g._hx_index == 3) {
						let _g1 = _g.s;
						if(comment.parent.getFirstChild() == comment.previousSibling) {
							effectiveToken = comment.parent;
						}
					}
				}
			} else if(comment.parent == null || comment.parent.tok == tokentree_TokenTreeDef.Root) {
				continue;
			}
			if(comment.nextSibling == null) {
				continue;
			}
			let next = comment.nextSibling;
			let found = true;
			while(next != null) {
				let _g = next.tok;
				switch(_g._hx_index) {
				case 1:
					switch(_g.k._hx_index) {
					case 0:
						break;
					case 1:
						break;
					case 2:
						break;
					case 26:
						break;
					case 27:
						break;
					case 31:
						break;
					case 39:
						break;
					case 41:
						break;
					default:
						found = false;
					}
					break;
				case 2:
					let _g1 = _g.c;
					if(_g1._hx_index == 3) {
						let _g = _g1.s;
					} else {
						found = false;
					}
					break;
				case 3:
					let _g2 = _g.s;
					next = null;
					break;
				case 8:
					let _g3 = _g.s;
					next = next.nextSibling;
					continue;
				default:
					found = false;
				}
				break;
			}
			if(!found) {
				continue;
			}
			switch(this.config.emptyLines.beforeDocCommentEmptyLines) {
			case "ignore":
				break;
			case "none":
				this.emptyLinesBefore(effectiveToken,0);
				break;
			case "one":
				this.emptyLinesBefore(effectiveToken,1);
				break;
			}
			if(next == null) {
				continue;
			}
			let lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(next);
			let nextInfo = this.getNextToken(lastToken);
			if(nextInfo == null) {
				continue;
			}
			let _g1 = nextInfo.token.tok;
			if(_g1._hx_index == 3) {
				switch(_g1.s) {
				case "end":
					lastToken = nextInfo.token;
					break;
				case "error":
					break;
				case "if":
					break;
				default:
					continue;
				}
			}
			switch(this.config.emptyLines.afterFieldsWithDocComments) {
			case "ignore":
				break;
			case "none":
				this.emptyLinesAfter(lastToken,0);
				break;
			case "one":
				this.emptyLinesAfter(lastToken,1);
				break;
			}
		}
	}
	markMultilineComments() {
		let comments = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 7) {
				let text = _g.s;
				return tokentree_FilterResult.FoundSkipSubtree;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < comments.length) {
			let comment = comments[_g];
			++_g;
			let sibling = comment.nextSibling;
			if(sibling == null) {
				continue;
			}
			if(!this.isNewLineAfter(comment)) {
				continue;
			}
			let _g1 = sibling.tok;
			if(_g1._hx_index == 7) {
				let s = _g1.s;
				this.emptyLinesAfter(comment,this.config.emptyLines.betweenMultilineComments);
			} else {
				continue;
			}
		}
	}
	markAroundBlocks() {
		let _gthis = this;
		this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 0:
					break;
				case 3:
					_gthis.removeEmptyLinesAroundBlock(token.children[1],_gthis.config.emptyLines.beforeBlocks,"keep");
					let block = tokentree_TokenTreeAccessHelper.previousSibling(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse)));
					if(block != null) {
						_gthis.removeEmptyLinesAroundBlock(block,"keep",_gthis.config.emptyLines.afterBlocks);
					}
					break;
				case 4:
					_gthis.removeEmptyLinesAroundBlock(token.getFirstChild(),_gthis.config.emptyLines.beforeBlocks,"keep");
					break;
				case 5:
					if(token.parent == null || !token.parent.is(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdDo))) {
						_gthis.removeEmptyLinesAroundBlock(token.children[1],_gthis.config.emptyLines.beforeBlocks,"keep");
					}
					break;
				case 6:
					_gthis.removeEmptyLinesAroundBlock(token.getFirstChild(),_gthis.config.emptyLines.beforeBlocks,"keep");
					let block1 = tokentree_TokenTreeAccessHelper.previousSibling(tokentree_TokenTreeAccessHelper.lastChild(token));
					_gthis.removeEmptyLinesAroundBlock(block1,"keep",_gthis.config.emptyLines.afterBlocks);
					break;
				case 7:
					_gthis.removeEmptyLinesAroundBlock(token.children[1],_gthis.config.emptyLines.beforeBlocks,"keep");
					break;
				case 15:case 16:
					let block2 = tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.DblDot));
					_gthis.removeEmptyLinesAroundBlock(block2,_gthis.config.emptyLines.beforeBlocks,"keep");
					break;
				case 20:
					_gthis.removeEmptyLinesAroundBlock(token.getFirstChild(),_gthis.config.emptyLines.beforeBlocks,"keep");
					let block3 = tokentree_TokenTreeAccessHelper.previousSibling(tokentree_TokenTreeAccessHelper.lastChild(token));
					_gthis.removeEmptyLinesAroundBlock(block3,"keep",_gthis.config.emptyLines.afterBlocks);
					break;
				case 21:
					_gthis.removeEmptyLinesAroundBlock(token.children[1],_gthis.config.emptyLines.beforeBlocks,"keep");
					break;
				default:
				}
			}
			return tokentree_FilterResult.GoDeeper;
		});
	}
	removeEmptyLinesAroundBlock(block,before,after) {
		if(block == null) {
			return;
		}
		if(before == "remove") {
			let prev = this.getPreviousToken(block);
			if(prev != null) {
				this.emptyLinesAfter(prev.token,0);
			}
		}
		if(after == "remove") {
			this.emptyLinesAfterSubTree(block,0);
		}
	}
	keepExistingEmptyLines() {
		let funcs = this.parsedCode.root.filter([tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFunction)],tokentree_TokenFilterMode.All);
		let _g = 0;
		while(_g < funcs.length) {
			let func = funcs[_g];
			++_g;
			let block = tokentree_TokenTreeAccessHelper.is(tokentree_TokenTreeAccessHelper.firstChild(func),tokentree_TokenTreeDef.BrOpen);
			if(block == null) {
				block = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(func),tokentree_TokenTreeDef.BrOpen);
			}
			if(block == null) {
				continue;
			}
			let fullPos = block.getPos();
			let startLine = this.parsedCode.getLinePos(fullPos.min).line;
			let endLine = this.parsedCode.getLinePos(fullPos.max).line;
			let _g1 = 0;
			let _g2 = this.parsedCode.emptyLines;
			while(_g1 < _g2.length) {
				let emptyLine = _g2[_g1];
				++_g1;
				if(startLine >= emptyLine || endLine <= emptyLine) {
					continue;
				}
				let idx = this.parsedCode.linesIdx[emptyLine];
				let tokenInf = this.findTokenAtOffset(idx.l);
				if(tokenInf == null) {
					continue;
				}
				if(tokentree_utils_TokenTreeCheckUtils.isMetadata(tokenInf.token)) {
					continue;
				}
				tokenInf.emptyLinesAfter++;
			}
		}
	}
	markFileHeader() {
		let info = this.getTokenAt(0);
		let info2 = this.getTokenAt(1);
		let packagesAndImports = this.parsedCode.root.filter([tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdPackage),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdImport),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdUsing)],tokentree_TokenFilterMode.All);
		if(info == null) {
			return;
		}
		let _g = info.token.tok;
		if(_g._hx_index == 7) {
			let s = _g.s;
			if(packagesAndImports.length == 0) {
				let _g = info2.token.tok;
				if(_g._hx_index == 7) {
					let s = _g.s;
				} else {
					return;
				}
			}
			info.emptyLinesAfter = this.config.emptyLines.afterFileHeaderComment;
		}
	}
}
$hxClasses["formatter.marker.MarkEmptyLines"] = formatter_marker_MarkEmptyLines;
formatter_marker_MarkEmptyLines.__name__ = "formatter.marker.MarkEmptyLines";
formatter_marker_MarkEmptyLines.__super__ = formatter_marker_MarkerBase;
Object.assign(formatter_marker_MarkEmptyLines.prototype, {
	__class__: formatter_marker_MarkEmptyLines
});
class formatter_marker_MarkLineEnds extends formatter_marker_MarkerBase {
	constructor(config,parsedCode,indenter) {
		super(config,parsedCode,indenter);
	}
	run() {
		let semicolonTokens = this.parsedCode.root.filter([tokentree_TokenTreeDef.Semicolon],tokentree_TokenFilterMode.All);
		let _g = 0;
		while(_g < semicolonTokens.length) {
			let token = semicolonTokens[_g];
			++_g;
			this.lineEndAfter(token);
		}
		this.markBrOpenClose();
		this.markAt();
		this.markDblDot();
		this.markSharp();
		this.markComments();
		this.markStructureExtension();
	}
	markComments() {
		let commentTokens = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			switch(_g._hx_index) {
			case 7:
				let _g1 = _g.s;
				return tokentree_FilterResult.FoundSkipSubtree;
			case 8:
				let _g2 = _g.s;
				return tokentree_FilterResult.FoundSkipSubtree;
			default:
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < commentTokens.length) {
			let token = commentTokens[_g];
			++_g;
			let _g1 = token.tok;
			switch(_g1._hx_index) {
			case 7:
				let _g2 = _g1.s;
				let prev = this.getPreviousToken(token);
				let noneBefore = false;
				if(prev != null) {
					if(this.parsedCode.isOriginalSameLine(token,prev.token)) {
						if(prev.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
							this.lineEndAfter(token);
						}
						this.noLineEndBefore(token);
						noneBefore = true;
					}
				}
				let commentLine = this.parsedCode.getLinePos(token.pos.min);
				let prefix = this.parsedCode.getString(this.parsedCode.linesIdx[commentLine.line].l,token.pos.min);
				commentLine = this.parsedCode.getLinePos(token.pos.max);
				let postfix = this.parsedCode.getString(token.pos.max,this.parsedCode.linesIdx[commentLine.line].r);
				if(new EReg("^\\s*$","").match(prefix) && new EReg("^\\s*$","").match(postfix)) {
					this.lineEndAfter(token);
					continue;
				}
				let next = this.getNextToken(token);
				if(next == null) {
					continue;
				}
				let _g3 = next.token.tok;
				switch(_g3._hx_index) {
				case 1:
					let _g4 = _g3.k;
					if(!noneBefore) {
						this.lineEndAfter(token);
					}
					continue;
				case 2:
					let _g5 = _g3.c;
					if(_g5._hx_index == 3) {
						if(_g5.s == "final") {
							if(!noneBefore) {
								this.lineEndAfter(token);
							}
							continue;
						}
					}
					break;
				default:
				}
				break;
			case 8:
				let _g6 = _g1.s;
				let prev1 = this.getPreviousToken(token);
				if(prev1 != null) {
					if(this.parsedCode.isOriginalSameLine(token,prev1.token)) {
						this.noLineEndBefore(token);
					}
				}
				this.lineEndAfter(token);
				break;
			default:
			}
		}
	}
	markBrOpenClose() {
		let brTokens = this.parsedCode.root.filterCallback(function(token,index) {
			if(token.tok._hx_index == 17) {
				return tokentree_FilterResult.FoundGoDeeper;
			}
			return tokentree_FilterResult.GoDeeper;
		});
		let _g = 0;
		while(_g < brTokens.length) {
			let brOpen = brTokens[_g];
			++_g;
			let curlyPolicy = this.detectCurlyPolicy(brOpen);
			let brClose = this.getCloseToken(brOpen);
			if(brClose == null) {
				switch(curlyPolicy.leftCurly) {
				case "after":
					this.lineEndAfter(brOpen);
					break;
				case "before":
					this.beforeLeftCurly(brOpen);
					break;
				case "both":
					this.beforeLeftCurly(brOpen);
					this.lineEndAfter(brOpen);
					break;
				case "none":
					break;
				}
				continue;
			}
			let prev = this.getPreviousToken(brOpen);
			if(prev != null) {
				let _g = prev.token.tok;
				if(_g._hx_index == 4) {
					switch(_g.s) {
					case "":case "a":case "b":case "e":case "i":case "p":case "v":
						if(this.parsedCode.isOriginalSameLine(brOpen,brClose)) {
							this.noLineEndAfter(brOpen);
							this.noLineEndBefore(brClose);
							this.whitespace(brOpen,"none");
							this.whitespace(brClose,"noneBefore");
							let next = this.getNextToken(brClose);
							if(next != null) {
								if(next.token.tok._hx_index == 12) {
									this.whitespace(brClose,"after");
								}
							}
							continue;
						}
						this.whitespace(brOpen,"noneBefore");
						break;
					default:
					}
				}
			}
			let next = this.getNextToken(brOpen);
			let isEmpty = false;
			if(next != null && next.token.is(tokentree_TokenTreeDef.BrClose) && curlyPolicy.emptyCurly == "noBreak") {
				isEmpty = true;
			}
			if(!isEmpty) {
				switch(curlyPolicy.leftCurly) {
				case "after":
					this.lineEndAfter(brOpen);
					break;
				case "before":
					this.beforeLeftCurly(brOpen);
					break;
				case "both":
					this.beforeLeftCurly(brOpen);
					this.lineEndAfter(brOpen);
					break;
				case "none":
					break;
				}
			}
			let preventBefore = isEmpty;
			let preventAfter = false;
			next = this.getNextToken(brClose);
			if(next != null) {
				if(next.token.tok._hx_index == 12) {
					preventAfter = true;
				}
			}
			switch(curlyPolicy.rightCurly) {
			case "after":
				if(!preventAfter) {
					this.afterRightCurly(brClose);
				}
				break;
			case "before":
				if(!preventBefore) {
					this.beforeRightCurly(brClose);
				}
				break;
			case "both":
				if(!preventBefore) {
					this.beforeRightCurly(brClose);
				}
				if(!preventAfter) {
					this.afterRightCurly(brClose);
				}
				break;
			case "none":
				break;
			}
		}
	}
	detectCurlyPolicy(brOpen) {
		let type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(brOpen);
		let curlyPolicy = { leftCurly : this.config.lineEnds.leftCurly, rightCurly : this.config.lineEnds.rightCurly, emptyCurly : this.config.lineEnds.emptyCurly};
		switch(type._hx_index) {
		case 0:
			if(brOpen.parent != null && this.config.lineEnds.anonFunctionCurly != null) {
				let _g = brOpen.parent.tok;
				switch(_g._hx_index) {
				case 1:
					if(_g.k._hx_index == 0) {
						return this.config.lineEnds.anonFunctionCurly;
					}
					break;
				case 13:
					return this.config.lineEnds.anonFunctionCurly;
				default:
				}
			}
			if(this.config.lineEnds.blockCurly != null) {
				return this.config.lineEnds.blockCurly;
			}
			break;
		case 1:
			if(this.config.lineEnds.typedefCurly != null) {
				return this.config.lineEnds.typedefCurly;
			}
			break;
		case 2:
			if(this.config.lineEnds.objectLiteralCurly != null) {
				return this.config.lineEnds.objectLiteralCurly;
			}
			break;
		case 3:
			if(this.config.lineEnds.anonTypeCurly != null) {
				return this.config.lineEnds.anonTypeCurly;
			}
			break;
		case 4:
			break;
		}
		return curlyPolicy;
	}
	beforeLeftCurly(token) {
		this.lineEndBefore(token);
	}
	beforeRightCurly(token) {
		this.lineEndBefore(token);
	}
	afterRightCurly(token) {
		let next = token.index + 1;
		if(this.parsedCode.tokenList.tokens.length <= next) {
			this.lineEndAfter(token);
			return;
		}
		let nextToken = this.getTokenAt(next);
		if(nextToken == null) {
			this.lineEndAfter(token);
			return;
		}
		let _g = nextToken.token.tok;
		switch(_g._hx_index) {
		case 6:
			switch(_g.op._hx_index) {
			case 4:
				break;
			case 7:
				break;
			default:
				this.lineEndAfter(token);
			}
			break;
		case 10:
			break;
		case 11:
			break;
		case 13:
			break;
		case 14:
			break;
		case 17:
			let type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(nextToken.token);
			switch(type._hx_index) {
			case 0:
				break;
			case 1:
				break;
			case 2:
				this.lineEndAfter(token);
				break;
			case 3:
				break;
			case 4:
				break;
			}
			break;
		case 20:
			break;
		default:
			this.lineEndAfter(token);
		}
	}
	markAt() {
		let atTokens = this.parsedCode.root.filter([tokentree_TokenTreeDef.At],tokentree_TokenFilterMode.All);
		let _g = 0;
		while(_g < atTokens.length) {
			let token = atTokens[_g];
			++_g;
			let metadataPolicy = this.determineMetadataPolicy(token);
			let lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
			if(lastChild == null) {
				continue;
			}
			if(metadataPolicy == "after") {
				this.lineEndAfter(lastChild);
				continue;
			}
			if(token.previousSibling != null && token.previousSibling.is(tokentree_TokenTreeDef.At)) {
				continue;
			}
			let next = token.nextSibling;
			let metadata = [token];
			while(next != null && next.is(tokentree_TokenTreeDef.At)) {
				metadata.push(next);
				next = next.nextSibling;
			}
			let _g1 = 0;
			while(_g1 < metadata.length) {
				let meta = metadata[_g1];
				++_g1;
				lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(meta);
				if(lastChild == null) {
					continue;
				}
				switch(metadataPolicy) {
				case "after":
					this.lineEndAfter(lastChild);
					break;
				case "afterLast":
					let next = this.getNextToken(lastChild);
					if(next != null && !this.parsedCode.isOriginalSameLine(lastChild,next.token)) {
						this.lineEndAfter(lastChild);
						continue;
					}
					this.whitespace(lastChild,"after");
					break;
				case "forceAfterLast":
					this.whitespace(lastChild,"after");
					break;
				case "none":
					let next1 = this.getNextToken(lastChild);
					if(next1 != null && !this.parsedCode.isOriginalSameLine(lastChild,next1.token)) {
						this.lineEndAfter(lastChild);
						continue;
					}
					this.whitespace(lastChild,"after");
					break;
				}
			}
			if(metadataPolicy == "afterLast" || metadataPolicy == "forceAfterLast") {
				this.lineEndAfter(lastChild);
			}
		}
	}
	determineMetadataPolicy(token) {
		if(token == null) {
			return this.config.lineEnds.metadataOther;
		}
		let parent = token.parent;
		if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
			return this.config.lineEnds.metadataType;
		}
		let _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				return this.config.lineEnds.metadataFunction;
			case 22:
				if(parent.parent == null) {
					return this.config.lineEnds.metadataOther;
				}
				let _g1 = parent.parent.tok;
				if(_g1._hx_index == 1) {
					switch(_g1.k._hx_index) {
					case 0:
						return this.config.lineEnds.metadataFunction;
					case 2:
						return this.config.lineEnds.metadataVar;
					case 1:case 26:case 27:case 31:case 39:
						return this.config.lineEnds.metadataType;
					default:
						return this.config.lineEnds.metadataOther;
					}
				} else {
					return this.config.lineEnds.metadataOther;
				}
				break;
			default:
				return this.config.lineEnds.metadataOther;
			}
			break;
		case 2:
			let _g2 = _g.c;
			if(_g2._hx_index == 3) {
				let _g = _g2.s;
				if(parent.parent == null) {
					return this.config.lineEnds.metadataOther;
				}
				let _g1 = parent.parent.tok;
				if(_g1._hx_index == 1) {
					switch(_g1.k._hx_index) {
					case 0:
						return this.config.lineEnds.metadataFunction;
					case 2:
						return this.config.lineEnds.metadataVar;
					case 1:case 26:case 27:case 31:case 39:
						return this.config.lineEnds.metadataType;
					default:
						return this.config.lineEnds.metadataOther;
					}
				} else {
					return this.config.lineEnds.metadataOther;
				}
			} else {
				return this.config.lineEnds.metadataOther;
			}
			break;
		case 3:
			let _g3 = _g.s;
			return "after";
		case 4:
			let _g4 = _g.s;
			if(parent.parent == null) {
				return this.config.lineEnds.metadataOther;
			}
			let _g5 = parent.parent.tok;
			if(_g5._hx_index == 1) {
				switch(_g5.k._hx_index) {
				case 0:
					return this.config.lineEnds.metadataFunction;
				case 2:
					return this.config.lineEnds.metadataVar;
				case 1:case 26:case 27:case 31:case 39:
					return this.config.lineEnds.metadataType;
				default:
					return this.config.lineEnds.metadataOther;
				}
			} else {
				return this.config.lineEnds.metadataOther;
			}
			break;
		default:
			return this.config.lineEnds.metadataOther;
		}
	}
	markDblDot() {
		let dblDotTokens = this.parsedCode.root.filter([tokentree_TokenTreeDef.DblDot],tokentree_TokenFilterMode.All);
		let _g = 0;
		while(_g < dblDotTokens.length) {
			let token = dblDotTokens[_g];
			++_g;
			if(!token.parent.is(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdCase)) && !token.parent.is(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdDefault))) {
				continue;
			}
			if(this.config.lineEnds.caseColon != "none") {
				this.lineEndAfter(token);
			}
			let lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
			if(lastChild == null) {
				continue;
			}
			this.lineEndAfter(lastChild);
		}
	}
	markSharp() {
		let sharpTokens = this.parsedCode.root.filter([tokentree_TokenTreeDef.Sharp("if"),tokentree_TokenTreeDef.Sharp("else"),tokentree_TokenTreeDef.Sharp("elseif"),tokentree_TokenTreeDef.Sharp("end"),tokentree_TokenTreeDef.Sharp("error")],tokentree_TokenFilterMode.All);
		let _g = 0;
		while(_g < sharpTokens.length) {
			let token = sharpTokens[_g];
			++_g;
			let _g1 = token.tok;
			if(_g1._hx_index == 3) {
				switch(_g1.s) {
				case "else":
					if(this.isInlineSharp(token)) {
						this.noLineEndBefore(token);
						continue;
					}
					this.lineEndBefore(token);
					this.lineEndAfter(token);
					break;
				case "end":
					if(this.isInlineSharp(token)) {
						this.noLineEndBefore(token);
					} else {
						this.lineEndBefore(token);
					}
					let next = this.getNextToken(token);
					if(next != null) {
						switch(next.token.tok._hx_index) {
						case 10:case 14:
							continue;
						default:
						}
					}
					if(!this.isOnlyWhitespaceAfterToken(token,true)) {
						continue;
					}
					this.lineEndAfter(token);
					break;
				case "error":
					let lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(token.getFirstChild());
					if(lastChild == null) {
						lastChild = token;
					}
					this.lineEndAfter(lastChild);
					break;
				case "elseif":case "if":
					let lastChild1 = tokentree_utils_TokenTreeCheckUtils.getLastToken(token.getFirstChild());
					if(lastChild1 == null) {
						continue;
					}
					if(this.config.lineEnds.sharp == "none") {
						this.whitespace(lastChild1,"after");
						continue;
					}
					if(this.isInlineSharp(token)) {
						if(token.is(tokentree_TokenTreeDef.Sharp("if")) && this.isOnlyWhitespaceBeforeToken(token)) {
							continue;
						}
						this.noLineEndBefore(token);
						continue;
					}
					this.lineEndBefore(token);
					this.lineEndAfter(lastChild1);
					break;
				default:
					this.lineEndAfter(token);
				}
			} else {
				this.lineEndAfter(token);
			}
		}
	}
	isInlineSharp(token) {
		let _g = token.tok;
		if(_g._hx_index == 3) {
			switch(_g.s) {
			case "else":
				return this.isInlineSharp(token.parent);
			case "elseif":
				return this.isInlineSharp(token.parent);
			case "end":
				return this.isInlineSharp(token.parent);
			case "if":
				let sharpEnd = token.getLastChild();
				if(sharpEnd == null) {
					return false;
				}
				let _g1 = sharpEnd.tok;
				switch(_g1._hx_index) {
				case 3:
					if(_g1.s == "end") {
						if(this.parsedCode.linesBetweenOriginal(token,sharpEnd) > 5) {
							return false;
						}
					} else {
						return false;
					}
					break;
				case 10:case 14:
					sharpEnd = sharpEnd.previousSibling;
					if(sharpEnd == null) {
						return false;
					}
					if(!sharpEnd.is(tokentree_TokenTreeDef.Sharp("end"))) {
						return false;
					}
					break;
				default:
					return false;
				}
				if(!this.isOnlyWhitespaceAfterToken(sharpEnd,true)) {
					return true;
				}
				if(!this.isOnlyWhitespaceBeforeToken(token)) {
					return true;
				}
				let prev = this.getPreviousToken(token);
				if(prev == null) {
					return !this.isOnlyWhitespaceBeforeToken(token);
				}
				if(prev.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
					return false;
				}
				let _g2 = prev.token.tok;
				switch(_g2._hx_index) {
				case 7:
					let _g3 = _g2.s;
					return false;
				case 8:
					let _g4 = _g2.s;
					return false;
				case 10:
					return false;
				case 18:
					return false;
				case 20:
					if(this.parsedCode.isOriginalSameLine(prev.token,token)) {
						return true;
					}
					return false;
				default:
					return true;
				}
				break;
			default:
				return false;
			}
		} else {
			return false;
		}
	}
	isOnlyWhitespaceBeforeToken(token) {
		let tokenLine = this.parsedCode.getLinePos(token.pos.min);
		let prefix = this.parsedCode.getString(this.parsedCode.linesIdx[tokenLine.line].l,token.pos.min);
		return new EReg("^\\s*$","").match(prefix);
	}
	isOnlyWhitespaceAfterToken(token,allowLineComments) {
		let tokenLine = this.parsedCode.getLinePos(token.pos.max);
		let prefix = this.parsedCode.getString(token.pos.max,this.parsedCode.linesIdx[tokenLine.line].r);
		if(allowLineComments) {
			return new EReg("^\\s*(|//.*)$","").match(prefix);
		} else {
			return new EReg("^\\s*$","").match(prefix);
		}
	}
	findTypedefBrOpen(token) {
		let assign = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.firstChild(token)),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign));
		if(assign == null) {
			return null;
		}
		return tokentree_TokenTreeAccessHelper.firstOf(assign,tokentree_TokenTreeDef.BrOpen);
	}
	markStructureExtension() {
		let typedefTokens = this.parsedCode.root.filter([tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdTypedef)],tokentree_TokenFilterMode.All);
		let _g = 0;
		while(_g < typedefTokens.length) {
			let token = typedefTokens[_g];
			++_g;
			this.markAfterTypedef(token);
			let brOpen = this.findTypedefBrOpen(token);
			if(brOpen == null) {
				continue;
			}
			if(brOpen.children == null || brOpen.children.length <= 0) {
				continue;
			}
			let assignParent = brOpen.parent;
			if(assignParent.children.length > 1) {
				let _g = 0;
				let _g1 = assignParent.children;
				while(_g < _g1.length) {
					let child = _g1[_g];
					++_g;
					let lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
					if(lastChild == null) {
						continue;
					}
					let next = this.getNextToken(lastChild);
					if(next == null) {
						continue;
					}
					if(lastChild.is(tokentree_TokenTreeDef.BrClose)) {
						let _g = next.token.tok;
						switch(_g._hx_index) {
						case 6:
							if(_g.op._hx_index == 11) {
								this.noLineEndAfter(lastChild);
								continue;
							}
							break;
						case 10:
							this.whitespace(lastChild,"noneAfter");
							continue;
						case 13:
							this.whitespace(lastChild,"none");
							continue;
						default:
						}
					}
					if(next.token.is(tokentree_TokenTreeDef.BrOpen)) {
						continue;
					}
					this.lineEndAfter(lastChild);
				}
			}
			let _g1 = 0;
			let _g2 = brOpen.children;
			while(_g1 < _g2.length) {
				let child = _g2[_g1];
				++_g1;
				let _g = child.tok;
				switch(_g._hx_index) {
				case 2:
					let _g3 = _g.c;
					if(_g3._hx_index == 3) {
						let _g = _g3.s;
						let lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
						if(lastChild == null) {
							continue;
						}
						this.lineEndAfter(lastChild);
					}
					break;
				case 6:
					if(_g.op._hx_index == 7) {
						let lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
						if(lastChild == null) {
							continue;
						}
						this.lineEndAfter(lastChild);
					}
					break;
				case 18:
					let next = this.getNextToken(child);
					if(next == null) {
						continue;
					}
					if(next.token.is(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAnd))) {
						this.noLineEndAfter(child);
					}
					if(next.token.is(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt))) {
						this.whitespace(child,"noneAfter");
					}
					break;
				case 21:
					let lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
					if(lastChild == null) {
						continue;
					}
					this.lineEndAfter(lastChild);
					break;
				default:
				}
			}
		}
	}
	markAfterTypedef(token) {
		let lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
		if(lastChild == null) {
			return;
		}
		let next = this.getNextToken(lastChild);
		if(next != null) {
			let _g = next.token.tok;
			switch(_g._hx_index) {
			case 8:
				let _g1 = _g.s;
				if(!this.parsedCode.isOriginalNewlineBefore(next.token)) {
					return;
				}
				break;
			case 10:
				this.whitespace(lastChild,"noneAfter");
				return;
			default:
			}
		}
		this.lineEndAfter(lastChild);
	}
}
$hxClasses["formatter.marker.MarkLineEnds"] = formatter_marker_MarkLineEnds;
formatter_marker_MarkLineEnds.__name__ = "formatter.marker.MarkLineEnds";
formatter_marker_MarkLineEnds.__super__ = formatter_marker_MarkerBase;
Object.assign(formatter_marker_MarkLineEnds.prototype, {
	__class__: formatter_marker_MarkLineEnds
});
class formatter_marker_MarkSameLine extends formatter_marker_MarkerBase {
	constructor(config,parsedCode,indenter) {
		super(config,parsedCode,indenter);
	}
	run() {
		this.markDollarSameLine();
		let _gthis = this;
		this.parsedCode.root.filterCallback(function(token,index) {
			if(token.parent != null && token.parent.is(tokentree_TokenTreeDef.At)) {
				return tokentree_FilterResult.GoDeeper;
			}
			let _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 0:
					_gthis.markFunction(token);
					break;
				case 3:
					_gthis.markIf(token);
					break;
				case 4:
					_gthis.markElse(token);
					break;
				case 5:
					if(token.parent != null && token.parent.is(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdDo))) {
						return tokentree_FilterResult.GoDeeper;
					}
					_gthis.markWhile(token);
					break;
				case 6:
					_gthis.markDoWhile(token);
					break;
				case 7:
					_gthis.markFor(token);
					break;
				case 10:
					_gthis.markReturn(token);
					break;
				case 15:
					_gthis.markCase(token);
					break;
				case 16:
					_gthis.markCase(token);
					break;
				case 20:
					_gthis.markTry(token);
					break;
				case 21:
					_gthis.markCatch(token);
					break;
				case 28:
					_gthis.markUntyped(token);
					break;
				case 40:
					_gthis.markMacro(token);
					break;
				default:
				}
			}
			return tokentree_FilterResult.GoDeeper;
		});
	}
	isExpression(token) {
		if(token == null) {
			return false;
		}
		let parent = token.parent;
		let _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 4:
				return this.shouldElseBeSameLine(parent);
			case 5:case 7:
				if(parent.parent.is(tokentree_TokenTreeDef.BkOpen)) {
					return true;
				}
				break;
			case 10:
				return true;
			case 28:
				return this.isExpression(parent);
			default:
			}
			break;
		case 6:
			let _g1 = _g.op;
			return true;
		case 12:
			let lastChild = parent.getLastChild();
			if(lastChild == null) {
				return false;
			}
			if(lastChild.index != token.index) {
				return false;
			}
			return this.isReturnExpression(parent);
		case 13:
			return true;
		case 19:
			let pos = parent.getPos();
			if(pos.min < token.pos.min && pos.max > token.pos.max) {
				return true;
			}
			break;
		default:
		}
		return false;
	}
	isReturnExpression(token) {
		let parent = token;
		while(parent.parent.tok != tokentree_TokenTreeDef.Root) {
			parent = parent.parent;
			let _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:
					return false;
				case 10:
					return true;
				default:
				}
				break;
			case 6:
				let _g1 = _g.op;
				return true;
			case 12:
				return true;
			case 13:
				return true;
			case 15:
				return false;
			case 17:
				let type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(parent);
				switch(type._hx_index) {
				case 0:
					break;
				case 1:
					break;
				case 2:
					return true;
				case 3:
					break;
				case 4:
					break;
				}
				break;
			case 19:
				return true;
			default:
			}
		}
		return false;
	}
	shouldIfBeSameLine(token) {
		if(token == null) {
			return false;
		}
		if(!token.is(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdIf))) {
			return false;
		}
		let body = this.getBodyAfterCondition(token);
		if(body == null) {
			return false;
		}
		return this.isExpression(token);
	}
	shouldElseBeSameLine(token) {
		if(token == null) {
			return false;
		}
		if(!token.is(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse))) {
			return false;
		}
		return this.shouldIfBeSameLine(token.parent);
	}
	shouldTryBeSameLine(token) {
		if(token == null) {
			return false;
		}
		if(!token.is(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdTry))) {
			return false;
		}
		return this.isExpression(token);
	}
	shouldCatchBeSameLine(token) {
		if(token == null) {
			return false;
		}
		if(!token.is(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdCatch))) {
			return false;
		}
		return this.shouldTryBeSameLine(token.parent);
	}
	markIf(token) {
		if(this.shouldIfBeSameLine(token)) {
			switch(this.config.sameLine.expressionIf) {
			case "keep":
				this.markBodyAfterPOpen(token,"keep",this.config.sameLine.expressionIfWithBlocks);
				return;
			case "next":
				break;
			case "same":
				this.markBodyAfterPOpen(token,"same",this.config.sameLine.expressionIfWithBlocks);
				return;
			}
		}
		this.markBodyAfterPOpen(token,this.config.sameLine.ifBody,false);
		let prev = this.getPreviousToken(token);
		if(prev != null && prev.token.is(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse))) {
			this.applySameLinePolicy(token,this.config.sameLine.elseIf);
		}
	}
	markElse(token) {
		if(this.shouldElseBeSameLine(token)) {
			switch(this.config.sameLine.expressionIf) {
			case "keep":
				this.markBody(token,"keep",this.config.sameLine.expressionIfWithBlocks);
				if(this.parsedCode.isOriginalNewlineBefore(token)) {
					this.lineEndBefore(token);
				}
				let prev = this.getPreviousToken(token);
				if(prev == null) {
					return;
				}
				if(prev.token.is(tokentree_TokenTreeDef.BrClose)) {
					this.applySameLinePolicyChained(token,"keep","keep");
				}
				return;
			case "next":
				break;
			case "same":
				this.markBody(token,"same",this.config.sameLine.expressionIfWithBlocks);
				let prev1 = this.getPreviousToken(token);
				if(prev1 == null) {
					return;
				}
				if(prev1.token.is(tokentree_TokenTreeDef.BrClose)) {
					this.applySameLinePolicyChained(token,this.config.sameLine.ifBody,this.config.sameLine.ifElse);
				}
				return;
			}
		}
		this.markBody(token,this.config.sameLine.elseBody,false);
		let policy = this.config.sameLine.ifElse;
		let prev2 = this.getPreviousToken(token);
		if(prev2 != null) {
			if(prev2.token.tok._hx_index == 18) {
				if(tokentree_TokenTreeAccessHelper.is(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.is(tokentree_TokenTreeAccessHelper.parent(prev2.token),tokentree_TokenTreeDef.BrOpen)),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdIf)) == null) {
					switch(policy) {
					case "keep":
						break;
					case "next":
						break;
					case "same":
						policy = "next";
						break;
					}
				}
			}
		}
		this.applySameLinePolicyChained(token,this.config.sameLine.ifBody,policy);
	}
	markTry(token) {
		if(this.shouldTryBeSameLine(token) && this.config.sameLine.expressionTry == "same") {
			this.markBody(token,"same",false);
			return;
		}
		this.markBody(token,this.config.sameLine.tryBody,false);
	}
	markCatch(token) {
		if(this.shouldCatchBeSameLine(token) && this.config.sameLine.expressionTry == "same") {
			this.markBodyAfterPOpen(token,"same",false);
			this.applySameLinePolicy(token,this.config.sameLine.tryCatch);
			return;
		}
		this.markBodyAfterPOpen(token,this.config.sameLine.catchBody,false);
		this.applySameLinePolicyChained(token,this.config.sameLine.tryBody,this.config.sameLine.tryCatch);
	}
	markCase(token) {
		if(token == null) {
			return;
		}
		let dblDot = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.DblDot);
		if(dblDot == null) {
			return;
		}
		if(this.isReturnExpression(token)) {
			this.markExpressionCase(token,dblDot);
			return;
		}
		if(dblDot.children == null || dblDot.children.length > 1) {
			return;
		}
		switch(this.config.sameLine.caseBody) {
		case "keep":
			if(!this.parsedCode.isOriginalSameLine(dblDot,dblDot.getFirstChild())) {
				return;
			}
			break;
		case "next":
			return;
		case "same":
			break;
		}
		let first = dblDot.getFirstChild();
		let last = tokentree_utils_TokenTreeCheckUtils.getLastToken(first);
		if(this.parsedCode.linesBetweenOriginal(first,last) > 2) {
			return;
		}
		this.noLineEndAfter(dblDot);
	}
	markExpressionCase(token,dblDot) {
		if(dblDot.children == null) {
			return;
		}
		switch(this.config.sameLine.expressionCase) {
		case "keep":
			if(!this.parsedCode.isOriginalSameLine(dblDot,dblDot.getFirstChild())) {
				return;
			}
			break;
		case "next":
			return;
		case "same":
			break;
		}
		if(dblDot.children.length == 2) {
			let second = dblDot.children[1];
			let _g = second.tok;
			if(_g._hx_index == 8) {
				let _g1 = _g.s;
				let prev = this.getPreviousToken(second);
				if(prev != null) {
					if(!this.parsedCode.isOriginalSameLine(dblDot,prev.token)) {
						return;
					}
				}
			} else {
				return;
			}
		}
		if(dblDot.children.length > 2) {
			return;
		}
		this.noLineEndAfter(dblDot);
	}
	isArrayComprehension(token) {
		if(token == null) {
			return false;
		}
		let parent = token.parent;
		while(parent != null) {
			let _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 3:case 4:case 5:case 7:
					parent = parent.parent;
					break;
				default:
					return false;
				}
				break;
			case 15:
				return true;
			default:
				return false;
			}
		}
		return false;
	}
	markFor(token) {
		if(token == null) {
			return;
		}
		let parent = token.parent;
		if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
			return;
		}
		if(this.isArrayComprehension(token)) {
			this.markArrayComprehension(token,parent);
			return;
		}
		let _g = parent.tok;
		if(_g._hx_index == 1) {
			if(_g.k._hx_index == 40) {
				let lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
				if(lastToken == null) {
					return;
				}
				if(this.parsedCode.isOriginalSameLine(token,lastToken)) {
					this.markBodyAfterPOpen(token,"same",false);
					return;
				}
			}
		}
		this.markBodyAfterPOpen(token,this.config.sameLine.forBody,false);
	}
	markWhile(token) {
		if(token == null) {
			return;
		}
		let parent = token.parent;
		if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
			return;
		}
		if(this.isArrayComprehension(token)) {
			this.markArrayComprehension(token,parent);
			return;
		}
		this.markBodyAfterPOpen(token,this.config.sameLine.whileBody,false);
	}
	markArrayComprehension(token,bkOpen) {
		let bkClose = this.getCloseToken(bkOpen);
		switch(this.config.sameLine.comprehensionFor) {
		case "keep":
			if(this.parsedCode.isOriginalNewlineBefore(token)) {
				this.lineEndBefore(token);
			}
			this.markBodyAfterPOpen(token,this.config.sameLine.comprehensionFor,false);
			if(bkClose != null && this.parsedCode.isOriginalNewlineBefore(bkClose)) {
				this.lineEndBefore(bkClose);
			}
			break;
		case "next":
			break;
		case "same":
			let origSame = false;
			if(bkClose != null) {
				origSame = this.parsedCode.isOriginalSameLine(bkOpen,bkClose);
			} else {
				let lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(bkOpen);
				if(lastToken != null) {
					origSame = this.parsedCode.isOriginalSameLine(bkOpen,lastToken);
				}
			}
			if(origSame) {
				this.markBodyAfterPOpen(token,this.config.sameLine.comprehensionFor,false);
				if(bkClose != null) {
					this.whitespace(token,"noneBefore");
					this.whitespace(bkClose,"noneBefore");
				}
			} else {
				this.markBodyAfterPOpen(token,this.config.sameLine.forBody,false);
			}
			break;
		}
	}
	getBodyAfterCondition(token) {
		let pClose = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.POpen),tokentree_TokenTreeDef.PClose);
		if(pClose != null) {
			let next = this.getNextToken(pClose);
			if(next != null) {
				if(next.token.tok._hx_index != 12) {
					return next.token;
				}
			}
		}
		if(token.children == null) {
			return null;
		}
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			switch(_g2._hx_index) {
			case 1:
				switch(_g2.k._hx_index) {
				case 36:case 37:case 38:
					return child.nextSibling;
				default:
				}
				break;
			case 2:
				let _g3 = _g2.c;
				if(_g3._hx_index == 3) {
					let _g = _g3.s;
					return child.nextSibling;
				}
				break;
			case 17:
				return child;
			case 22:
				break;
			default:
			}
		}
		return null;
	}
	markBodyAfterPOpen(token,policy,includeBrOpen) {
		let body = this.getBodyAfterCondition(token);
		_hx_loop1: while(body != null) {
			let _g = body.tok;
			switch(_g._hx_index) {
			case 3:
				switch(_g.s) {
				case "else":case "elseif":case "end":
					return;
				default:
					break _hx_loop1;
				}
				break;
			case 8:
				let _g1 = _g.s;
				let prev = this.getPreviousToken(body);
				if(prev != null) {
					if(!this.parsedCode.isOriginalSameLine(body,prev.token)) {
						this.applySameLinePolicy(body,policy);
						return;
					}
				}
				body = body.nextSibling;
				break;
			case 17:
				let type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(body);
				switch(type._hx_index) {
				case 0:
					if(includeBrOpen) {
						this.markBlockBody(body,policy);
					}
					return;
				case 1:
					break;
				case 2:
					this.applySameLinePolicy(body,policy);
					break;
				case 3:
					break;
				case 4:
					break;
				}
				body = body.nextSibling;
				break;
			default:
				break _hx_loop1;
			}
		}
		if(body == null) {
			return;
		}
		this.applySameLinePolicy(body,policy);
	}
	markBody(token,policy,includeBrOpen) {
		let body = tokentree_TokenTreeAccessHelper.firstChild(token);
		if(body == null) {
			return;
		}
		if(body.is(tokentree_TokenTreeDef.BrOpen)) {
			let type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(body);
			switch(type._hx_index) {
			case 0:
				if(includeBrOpen) {
					this.markBlockBody(body,policy);
				}
				return;
			case 1:
				break;
			case 2:
				this.applySameLinePolicy(body,policy);
				break;
			case 3:
				break;
			case 4:
				break;
			}
			return;
		}
		this.applySameLinePolicy(body,policy);
	}
	markBlockBody(token,policy) {
		if(token == null) {
			return;
		}
		if(!token.is(tokentree_TokenTreeDef.BrOpen)) {
			return;
		}
		if(token.children == null) {
			return;
		}
		let lastChild = token.getLastChild();
		if(lastChild.is(tokentree_TokenTreeDef.Semicolon)) {
			if(token.children.length > 3) {
				return;
			}
		} else if(token.children.length > 2) {
			return;
		}
		this.noLineEndAfter(token);
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			if(child.tok._hx_index == 18) {
				let next = this.getNextToken(child);
				let _g = next.token.tok;
				switch(_g._hx_index) {
				case 1:
					switch(_g.k._hx_index) {
					case 4:
						this.noLineEndAfter(child);
						break;
					case 21:
						this.noLineEndAfter(child);
						break;
					default:
					}
					break;
				case 10:
					this.whitespace(child,"noneAfter");
					break;
				case 14:
					this.whitespace(child,"noneAfter");
					break;
				default:
				}
				return;
			} else {
				let lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
				if(lastToken == null) {
					return;
				}
				this.noLineEndAfter(lastToken);
			}
		}
	}
	applySameLinePolicyChained(token,previousBlockPolicy,policy) {
		if(policy == "same") {
			let prev = this.getPreviousToken(token);
			if(prev == null) {
				policy = "next";
			}
			if(!prev.token.is(tokentree_TokenTreeDef.BrClose) && previousBlockPolicy != "same") {
				policy = "next";
			}
		}
		this.applySameLinePolicy(token,policy);
	}
	applySameLinePolicy(token,policy) {
		switch(policy) {
		case "keep":
			if(this.parsedCode.isOriginalNewlineBefore(token)) {
				this.applySameLinePolicy(token,"next");
			} else {
				this.applySameLinePolicy(token,"same");
			}
			break;
		case "next":
			let _g = token.tok;
			switch(_g._hx_index) {
			case 8:
				let s = _g.s;
				if(!this.parsedCode.isOriginalNewlineBefore(token)) {
					return;
				}
				break;
			case 15:
				if(tokentree_TokenTreeAccessHelper.is(tokentree_TokenTreeAccessHelper.parent(token),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFor)) != null) {
					return;
				}
				break;
			default:
			}
			this.lineEndBefore(token);
			break;
		case "same":
			this.wrapBefore(token,true);
			let prev = this.getPreviousToken(token);
			if(prev == null) {
				this.noLineEndBefore(token);
			} else {
				switch(prev.token.tok._hx_index) {
				case 10:case 18:
					if(token.tok._hx_index != 22) {
						this.noLineEndBefore(token);
					}
					break;
				case 11:case 19:
					this.whitespace(token,"noneBefore");
					break;
				default:
					this.noLineEndBefore(token);
				}
			}
			let lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
			if(lastToken == null) {
				return;
			}
			let next = this.getNextToken(lastToken);
			if(next == null) {
				return;
			}
			let _g1 = next.token.tok;
			if(_g1._hx_index == 1) {
				if(_g1.k._hx_index == 4) {
					this.noLineEndAfter(lastToken);
				}
			}
			return;
		}
	}
	markDollarSameLine() {
		let tokens = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 4) {
				switch(_g.s) {
				case "":case "a":case "b":case "e":case "i":case "p":case "v":
					return tokentree_FilterResult.FoundSkipSubtree;
				default:
					return tokentree_FilterResult.SkipSubtree;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < tokens.length) {
			let token = tokens[_g];
			++_g;
			let brOpen = tokentree_TokenTreeAccessHelper.is(tokentree_TokenTreeAccessHelper.firstChild(token),tokentree_TokenTreeDef.BrOpen);
			if(brOpen == null) {
				continue;
			}
			let brClose = this.getCloseToken(brOpen);
			if(!this.parsedCode.isOriginalSameLine(brOpen,brClose)) {
				continue;
			}
			this.whitespace(brOpen,"none");
			let next = this.getNextToken(brClose);
			if(next != null) {
				switch(next.token.tok._hx_index) {
				case 10:case 11:case 14:
					this.whitespace(brClose,"none");
					break;
				case 12:case 15:case 16:case 18:case 19:case 20:
					break;
				default:
					this.whitespace(brClose,"onlyAfter");
				}
			} else {
				this.noLineEndAfter(brClose);
			}
			this.wrapBefore(brOpen,false);
			this.wrapAfter(brOpen,false);
			this.wrapBefore(brClose,false);
			this.wrapAfter(brClose,false);
		}
	}
	markFunction(token) {
		let body = tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.firstChild(token));
		if(body == null) {
			body = tokentree_TokenTreeAccessHelper.is(tokentree_TokenTreeAccessHelper.firstChild(token),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdNew));
		}
		let policy = this.config.sameLine.functionBody;
		if(body == null) {
			body = token;
			policy = this.config.sameLine.anonFunctionBody;
		}
		if(body == null || body.children == null) {
			return;
		}
		body = tokentree_TokenTreeAccessHelper.firstOf(body,tokentree_TokenTreeDef.POpen);
		if(body == null) {
			return;
		}
		if(body.nextSibling == null) {
			return;
		}
		body = body.nextSibling;
		if(body.tok._hx_index == 12) {
			body = body.nextSibling;
		}
		if(body == null) {
			return;
		}
		let _g = body.tok;
		switch(_g._hx_index) {
		case 3:
			if(_g.s == "if") {
				return;
			}
			break;
		case 8:
			let _g1 = _g.s;
			return;
		case 10:
			return;
		case 17:
			return;
		default:
		}
		this.applySameLinePolicy(body,policy);
	}
	markDoWhile(token) {
		this.markBody(token,this.config.sameLine.doWhileBody,false);
		let whileTok = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdWhile));
		if(whileTok == null) {
			return;
		}
		this.applySameLinePolicy(whileTok,this.config.sameLine.doWhile);
	}
	markMacro(token) {
		let brOpen = this.getNextToken(token);
		if(brOpen == null || !brOpen.token.is(tokentree_TokenTreeDef.BrOpen)) {
			return;
		}
		let brClose = this.getCloseToken(brOpen.token);
		if(this.parsedCode.isOriginalSameLine(brOpen.token,brClose)) {
			this.noLineEndAfter(brOpen.token);
			this.noLineEndBefore(brClose);
			this.noWrappingBetween(brOpen.token,brClose);
		}
	}
	markReturn(token) {
		if(this.shouldReturnBeSameLine(token)) {
			this.markBody(token,this.config.sameLine.returnBodySingleLine,false);
		} else {
			this.markBody(token,this.config.sameLine.returnBody,false);
		}
	}
	markUntyped(token) {
		if(tokentree_TokenTreeAccessHelper.is(tokentree_TokenTreeAccessHelper.firstChild(token),tokentree_TokenTreeDef.BrOpen) == null) {
			return;
		}
		let parent = token.parent;
		if(parent == null || token.tok == tokentree_TokenTreeDef.Root) {
			return;
		}
		if(parent.tok._hx_index == 17) {
			let type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(parent);
			switch(type._hx_index) {
			case 0:
				return;
			case 1:
				return;
			case 2:
				break;
			case 3:
				break;
			case 4:
				break;
			}
		}
		this.applySameLinePolicy(token,this.config.sameLine.untypedBody);
	}
	shouldReturnBeSameLine(token) {
		let lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
		if(lastToken == null) {
			return true;
		}
		if(this.isSameLineBetween(token,lastToken,false)) {
			return true;
		}
		return this.shouldReturnChildsBeSameLine(token);
	}
	shouldReturnChildsBeSameLine(token) {
		if(token.children == null) {
			return true;
		}
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			if(_g2._hx_index == 1) {
				switch(_g2.k._hx_index) {
				case 3:case 5:case 7:case 14:case 20:
					return false;
				default:
					let result = this.shouldReturnChildsBeSameLine(child);
					if(!result) {
						return false;
					}
				}
			} else {
				let result = this.shouldReturnChildsBeSameLine(child);
				if(!result) {
					return false;
				}
			}
		}
		return true;
	}
}
$hxClasses["formatter.marker.MarkSameLine"] = formatter_marker_MarkSameLine;
formatter_marker_MarkSameLine.__name__ = "formatter.marker.MarkSameLine";
formatter_marker_MarkSameLine.__super__ = formatter_marker_MarkerBase;
Object.assign(formatter_marker_MarkSameLine.prototype, {
	__class__: formatter_marker_MarkSameLine
});
class formatter_marker_MarkTokenText extends formatter_marker_MarkerBase {
	constructor(config,parsedCode,indenter) {
		super(config,parsedCode,indenter);
	}
	run() {
		let _gthis = this;
		this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			switch(_g._hx_index) {
			case 2:
				let _g1 = _g.c;
				switch(_g1._hx_index) {
				case 2:
					let _g2 = _g1.kind;
					let text = _g1.s;
					_gthis.tokenText(token,_gthis.printStringToken(token));
					break;
				case 4:
					let _g3 = _g1.opt;
					let _g4 = _g1.r;
					_gthis.tokenText(token,_gthis.printEregToken(token));
					break;
				default:
					_gthis.tokenText(token,token.toString());
				}
				break;
			case 8:
				let text1 = _g.s;
				_gthis.tokenText(token,_gthis.printCommentLine(text1));
				break;
			default:
				_gthis.tokenText(token,token.toString());
			}
			return tokentree_FilterResult.GoDeeper;
		});
	}
	finalRun() {
		let _gthis = this;
		this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 7) {
				let text = _g.s;
				_gthis.tokenText(token,_gthis.printComment(text,token));
			}
			return tokentree_FilterResult.GoDeeper;
		});
	}
	printStringToken(token) {
		let text = this.parsedCode.getString(token.pos.min,token.pos.max);
		if(!this.config.whitespace.formatStringInterpolation) {
			return text;
		}
		if(StringTools.startsWith(text,"'")) {
			let start = 0;
			let index;
			while(true) {
				index = text.indexOf("${",start);
				if(!(index >= 0)) {
					break;
				}
				if(this.isDollarEscaped(text,index)) {
					return text;
				}
				start = index + 1;
				let indexEnd = text.indexOf("}",index + 2);
				let fragment = text.substring(index + 2,indexEnd);
				if(fragment.indexOf("{") >= 0) {
					continue;
				}
				let formatted = this.formatFragment(fragment);
				start += formatted.length;
				text = HxOverrides.substr(text,0,index + 2) + formatted + HxOverrides.substr(text,indexEnd,null);
			}
		}
		return text;
	}
	isDollarEscaped(text,index) {
		let escaped = false;
		while(--index >= 0) {
			if(text.charCodeAt(index) != 36) {
				return escaped;
			}
			escaped = !escaped;
		}
		return escaped;
	}
	formatFragment(fragment) {
		try {
			let fileName = "string interpolation";
			let this1 = haxe_io_Bytes.ofString(fragment);
			let tokens = this.makeTokens(this1,fileName);
			let this2 = haxe_io_Bytes.ofString(fragment);
			let stream = new tokentree_TokenStream(tokens,this2);
			let root = new tokentree_TokenTree(tokentree_TokenTreeDef.Root,"",null,-1);
			let progress = new tokentree_TokenStreamProgress(stream);
			while(progress.streamHasChanged()) if(stream.hasMore()) {
				tokentree_walk_WalkStatement.walkStatement(stream,root);
			}
			let this3 = haxe_io_Bytes.ofString(fragment);
			let inputData = { fileName : fileName, content : this3, tokenList : tokens, tokenTree : root, config : this.config, entryPoint : tokentree_TokenTreeEntryPoint.ExpressionLevel};
			let interpolParsedCode = new formatter_codedata_ParsedCode(inputData);
			let interpolIndenter = new formatter_marker_Indenter(this.config.indentation);
			interpolIndenter.setParsedCode(interpolParsedCode);
			let markTokenText = new formatter_marker_MarkTokenText(this.config,interpolParsedCode,interpolIndenter);
			let markWhitespace = new formatter_marker_MarkWhitespace(this.config,interpolParsedCode,interpolIndenter);
			markTokenText.run();
			markWhitespace.run();
			let lines = new formatter_codedata_CodeLines(interpolParsedCode,interpolIndenter);
			let formatted = lines.print(interpolParsedCode.lineSeparator);
			return StringTools.trim(formatted);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
		}
		return fragment;
	}
	makeTokens(fragment,name) {
		let tokens = [];
		try {
			let lexer = new haxeparser_HaxeLexer(fragment,name);
			let t = lexer.token(haxeparser_HaxeLexer.tok);
			while(t.tok != haxeparser_TokenDef.Eof) {
				tokens.push(t);
				t = lexer.token(haxeparser_HaxeLexer.tok);
			}
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			let e = haxe_Exception.caught(_g).unwrap();
			throw haxe_Exception.thrown("failed to make tokens " + (e == null ? "null" : Std.string(e)));
		}
		return tokens;
	}
	printEregToken(token) {
		return this.parsedCode.getString(token.pos.min,token.pos.max);
	}
	printComment(text,token) {
		let lines = text.split(this.parsedCode.lineSeparator);
		let indent = this.indenter.calcIndent(token);
		let startsWithStar = lines.length >= 3;
		let _g = 1;
		let _g1 = lines.length - 1;
		while(_g < _g1) {
			let index = _g++;
			if(!new EReg("^\\s*\\*(\\s|$)","").match(lines[index])) {
				startsWithStar = false;
				break;
			}
		}
		let linesNew = [];
		let _g2 = 0;
		while(_g2 < lines.length) {
			let line = lines[_g2];
			++_g2;
			linesNew.push(this.convertLeadingIndent(line));
		}
		lines = this.removeCommentPrefix(linesNew);
		text = "/*" + lines[0];
		let _g3 = 1;
		let _g4 = lines.length;
		while(_g3 < _g4) {
			let index = _g3++;
			text += this.parsedCode.lineSeparator;
			let line = lines[index];
			let lineIndent = indent;
			let lastLine = index == lines.length - 1;
			if(!lastLine) {
				++lineIndent;
			}
			if(startsWithStar) {
				lineIndent = indent;
			}
			if(!lastLine && line.length <= 0) {
				lineIndent = 0;
			}
			if(!lastLine && startsWithStar) {
				line = " " + line;
			}
			if(lastLine) {
				if(new EReg("^\\s*\\*\\s*[^\\s\\*]","").match(line)) {
					line = " " + line;
				}
				let leadingWS = new EReg("^\\s*}","");
				if(leadingWS.match(line)) {
					line = StringTools.trim(line);
				} else {
					if(new EReg("^\\s*[^*\\s]","").match(line)) {
						lineIndent = indent + 1;
					}
					line = StringTools.rtrim(line);
					if(!StringTools.endsWith(line,"*")) {
						line += " ";
					}
				}
				if(new EReg("^\\s*$","").match(line)) {
					line = " ";
				}
			}
			text += this.indenter.makeIndentString(lineIndent) + line;
		}
		return text + "*/";
	}
	removeCommentPrefix(lines) {
		let prefixReg = new EReg("^(\\s*)","");
		let prefix = null;
		let linesNew = [];
		let endIndex = lines.length - 1;
		let lastLine = lines[lines.length - 1];
		if(!new EReg("^\\s*(\\**$|\\})","").match(lastLine)) {
			endIndex = lines.length;
		}
		let _g = 1;
		let _g1 = endIndex;
		while(_g < _g1) {
			let index = _g++;
			let line = lines[index];
			prefixReg.match(line);
			let linePrefix = prefixReg.matched(1);
			if(linePrefix.length <= 0) {
				continue;
			}
			if(prefix == null || prefix.length > linePrefix.length) {
				prefix = linePrefix;
			}
		}
		if(prefix != null) {
			linesNew = [];
			let startPrefix = prefix + " *";
			let _g = 0;
			while(_g < lines.length) {
				let line = lines[_g];
				++_g;
				if(StringTools.startsWith(line,startPrefix)) {
					line = HxOverrides.substr(line,startPrefix.length - 1,null);
				}
				if(StringTools.startsWith(line,prefix)) {
					line = HxOverrides.substr(line,prefix.length,null);
				}
				linesNew.push(line);
			}
			lines = linesNew;
		}
		let lastLine1 = lines[lines.length - 1];
		if(new EReg("^\\s*\\*\\**$","").match(lastLine1)) {
			lines[lines.length - 1] = StringTools.ltrim(lastLine1);
		}
		return lines;
	}
	convertLeadingIndent(line) {
		let spaceIndent = StringTools.lpad(""," ",this.config.indentation.tabWidth);
		let oneIndent = this.config.indentation.character;
		let whitespaceReg = new EReg("^\\s+","");
		if(!whitespaceReg.match(line)) {
			return line;
		}
		let match = whitespaceReg.matched(0);
		if(this.config.indentation.character == "\t") {
			let newPrefix = StringTools.replace(match,spaceIndent,oneIndent);
			line = newPrefix + HxOverrides.substr(line,match.length,null);
		} else {
			let newPrefix = StringTools.replace(match,"\t",oneIndent);
			line = newPrefix + HxOverrides.substr(line,match.length,null);
		}
		return line;
	}
	printCommentLine(text) {
		if(new EReg("^[/\\*\\-\\s]+","").match(text)) {
			return "//" + StringTools.rtrim(text);
		}
		if(this.config.whitespace.addLineCommentSpace) {
			return "// " + StringTools.trim(text);
		}
		return "//" + StringTools.trim(text);
	}
}
$hxClasses["formatter.marker.MarkTokenText"] = formatter_marker_MarkTokenText;
formatter_marker_MarkTokenText.__name__ = "formatter.marker.MarkTokenText";
formatter_marker_MarkTokenText.__super__ = formatter_marker_MarkerBase;
Object.assign(formatter_marker_MarkTokenText.prototype, {
	__class__: formatter_marker_MarkTokenText
});
class formatter_marker_MarkWhitespace extends formatter_marker_MarkerBase {
	constructor(config,parsedCode,indenter) {
		super(config,parsedCode,indenter);
	}
	run() {
		let _gthis = this;
		this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			switch(_g._hx_index) {
			case 1:
				let _g1 = _g.k;
				_gthis.markKeyword(token);
				break;
			case 2:
				let _g2 = _g.c;
				if(_g2._hx_index == 3) {
					switch(_g2.s) {
					case "final":
						_gthis.whitespace(token,"after");
						break;
					case "is":
						let parent = tokentree_TokenTreeAccessHelper.is(tokentree_TokenTreeAccessHelper.parent(token),tokentree_TokenTreeDef.POpen);
						if(parent != null) {
							let prev = _gthis.getPreviousToken(parent);
							if(prev != null && prev.token.is(tokentree_TokenTreeDef.POpen)) {
								_gthis.whitespace(token,"around");
							}
						}
						_gthis.fixConstAfterConst(token);
						break;
					case "from":case "to":
						let parent1 = tokentree_TokenTreeAccessHelper.is(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.parent(token)),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdAbstract));
						if(parent1 != null) {
							_gthis.whitespace(token,"around");
							_gthis.wrapBefore(token,true);
						}
						_gthis.fixConstAfterConst(token);
						break;
					default:
						_gthis.fixConstAfterConst(token);
					}
				} else {
					_gthis.fixConstAfterConst(token);
				}
				break;
			case 3:
				let _g3 = _g.s;
				_gthis.markSharp(token);
				break;
			case 4:
				let _g4 = _g.s;
				_gthis.markDollar(token);
				break;
			case 5:
				let _g5 = _g.op;
				_gthis.markUnop(token);
				break;
			case 6:
				switch(_g.op._hx_index) {
				case 1:
					if(tokentree_utils_TokenTreeCheckUtils.isImport(token.parent)) {
						_gthis.whitespace(token,"none");
					} else {
						_gthis.whitespace(token,_gthis.config.whitespace.binopPolicy);
					}
					break;
				case 3:
					if(tokentree_utils_TokenTreeCheckUtils.filterOpSub(token)) {
						let policy = formatter_config_WhitespacePolicy.remove(_gthis.config.whitespace.binopPolicy,"after");
						let prev = _gthis.getPreviousToken(token);
						switch(prev.token.tok._hx_index) {
						case 15:case 19:
							policy = formatter_config_WhitespacePolicy.remove(policy,"before");
							break;
						default:
						}
						_gthis.whitespace(token,policy);
					} else {
						_gthis.whitespace(token,_gthis.config.whitespace.binopPolicy);
					}
					break;
				case 7:
					_gthis.markGt(token);
					break;
				case 9:
					if(tokentree_utils_TokenTreeCheckUtils.isTypeParameter(token)) {
						_gthis.whitespace(token,_gthis.config.whitespace.typeParamOpenPolicy);
					} else {
						_gthis.whitespace(token,_gthis.config.whitespace.binopPolicy);
					}
					break;
				case 21:
					_gthis.whitespace(token,_gthis.config.whitespace.intervalPolicy);
					break;
				case 23:
					_gthis.markIn(token);
					break;
				default:
					_gthis.whitespace(token,_gthis.config.whitespace.binopPolicy);
				}
				break;
			case 7:
				let _g6 = _g.s;
				_gthis.markComment(token);
				break;
			case 8:
				let _g7 = _g.s;
				_gthis.whitespace(token,"before");
				break;
			case 10:
				_gthis.markSemicolon(token);
				break;
			case 12:
				_gthis.markDblDot(token);
				break;
			case 13:
				_gthis.markArrow(token);
				break;
			case 14:
				_gthis.whitespace(token,_gthis.config.whitespace.commaPolicy);
				break;
			case 15:
				_gthis.successiveParenthesis(token,false,_gthis.config.whitespace.openingBracketPolicy,_gthis.config.whitespace.compressSuccessiveParenthesis);
				break;
			case 16:
				_gthis.successiveParenthesis(token,true,_gthis.config.whitespace.closingBracketPolicy,_gthis.config.whitespace.compressSuccessiveParenthesis);
				break;
			case 17:
				_gthis.markBrOpen(token);
				break;
			case 18:
				_gthis.markBrClose(token);
				break;
			case 19:
				_gthis.markPOpen(token);
				break;
			case 20:
				_gthis.markPClose(token);
				break;
			case 21:
				if(tokentree_utils_TokenTreeCheckUtils.isTernary(token)) {
					_gthis.whitespace(token,_gthis.config.whitespace.ternaryPolicy);
				} else {
					_gthis.whitespace(token,"noneAfter");
				}
				break;
			case 22:
				_gthis.markAt(token);
				break;
			default:
			}
			return tokentree_FilterResult.GoDeeper;
		});
	}
	markGt(token) {
		if(tokentree_utils_TokenTreeCheckUtils.isOpGtTypedefExtension(token)) {
			this.whitespace(token,this.config.whitespace.typeExtensionPolicy);
			return;
		}
		if(tokentree_utils_TokenTreeCheckUtils.isTypeParameter(token)) {
			let policy = this.config.whitespace.typeParamClosePolicy;
			let next = this.getNextToken(token);
			if(next != null) {
				let _g = next.token.tok;
				switch(_g._hx_index) {
				case 1:
					let _g1 = _g.k;
					policy = formatter_config_WhitespacePolicy.add(policy,"after");
					break;
				case 6:
					if(_g.op._hx_index == 7) {
						policy = formatter_config_WhitespacePolicy.remove(policy,"after");
					}
					break;
				case 10:case 14:
					policy = formatter_config_WhitespacePolicy.remove(policy,"after");
					break;
				case 18:case 20:
					policy = formatter_config_WhitespacePolicy.remove(policy,"after");
					break;
				default:
				}
			}
			this.whitespace(token,policy);
		} else {
			this.whitespace(token,this.config.whitespace.binopPolicy);
		}
	}
	fixConstAfterConst(token) {
		let next = this.getNextToken(token);
		if(next != null) {
			let _g = next.token.tok;
			switch(_g._hx_index) {
			case 1:
				let _g1 = _g.k;
				this.whitespace(token,"after");
				break;
			case 2:
				let _g2 = _g.c;
				this.whitespace(token,"after");
				break;
			default:
			}
		}
	}
	successiveParenthesis(token,closing,policy,compress) {
		let next = this.getNextToken(token);
		if(next != null) {
			let _g = next.token.tok;
			switch(_g._hx_index) {
			case 1:
				let _g1 = _g.k;
				if(closing) {
					policy = formatter_config_WhitespacePolicy.add(policy,"after");
				}
				break;
			case 6:
				switch(_g.op._hx_index) {
				case 7:
					if(token.is(tokentree_TokenTreeDef.BrClose)) {
						policy = formatter_config_WhitespacePolicy.remove(policy,"after");
					}
					break;
				case 22:
					policy = formatter_config_WhitespacePolicy.add(policy,"after");
					break;
				default:
				}
				break;
			case 10:case 11:case 12:case 14:
				policy = formatter_config_WhitespacePolicy.remove(policy,"after");
				break;
			default:
			}
		}
		if(!compress) {
			this.whitespace(token,policy);
			return;
		}
		if(closing) {
			if(next != null) {
				let _g = next.token.tok;
				switch(_g._hx_index) {
				case 6:
					if(_g.op._hx_index == 7) {
						if(tokentree_utils_TokenTreeCheckUtils.isTypeParameter(next.token)) {
							policy = formatter_config_WhitespacePolicy.remove(policy,"after");
						}
					}
					break;
				case 18:
					policy = formatter_config_WhitespacePolicy.remove(policy,"after");
					break;
				case 15:case 16:case 17:case 19:case 20:
					if(token.is(tokentree_TokenTreeDef.PClose)) {
						switch(tokentree_utils_TokenTreeCheckUtils.getPOpenType(token.parent)._hx_index) {
						case 1:
							policy = formatter_config_WhitespacePolicy.add(policy,"after");
							break;
						case 0:case 2:case 9:
							policy = formatter_config_WhitespacePolicy.remove(policy,"after");
							break;
						case 3:case 4:case 5:case 6:case 7:
							policy = formatter_config_WhitespacePolicy.add(policy,"after");
							break;
						case 8:
							policy = formatter_config_WhitespacePolicy.add(policy,"after");
							break;
						}
					} else {
						policy = formatter_config_WhitespacePolicy.remove(policy,"after");
					}
					break;
				default:
				}
			}
		} else {
			let prev = this.getPreviousToken(token);
			if(prev != null) {
				let _g = prev.token.tok;
				switch(_g._hx_index) {
				case 6:
					switch(_g.op._hx_index) {
					case 9:
						if(token.is(tokentree_TokenTreeDef.BrOpen)) {
							return;
						}
						break;
					case 21:
						policy = formatter_config_WhitespacePolicy.remove(policy,"before");
						break;
					default:
					}
					break;
				case 9:
					let _g1 = _g.s;
					policy = formatter_config_WhitespacePolicy.remove(policy,"before");
					break;
				case 12:
					switch(prev.whitespaceAfter._hx_index) {
					case 0:
						policy = formatter_config_WhitespacePolicy.remove(policy,"before");
						break;
					case 1:
						policy = formatter_config_WhitespacePolicy.add(policy,"before");
						break;
					case 2:
						break;
					}
					break;
				case 13:
					return;
				case 14:
					let _g2 = this.config.whitespace.commaPolicy;
					if(_g2 != null) {
						switch(_g2) {
						case "after":case "around":case "onlyAfter":
							policy = formatter_config_WhitespacePolicy.add(policy,"before");
							break;
						default:
						}
					}
					break;
				case 15:case 17:case 19:
					policy = formatter_config_WhitespacePolicy.remove(policy,"before");
					break;
				case 20:
					switch(tokentree_utils_TokenTreeCheckUtils.getPOpenType(prev.token)._hx_index) {
					case 3:case 4:case 5:case 6:case 7:
						policy = formatter_config_WhitespacePolicy.add(policy,"before");
						break;
					default:
					}
					break;
				default:
				}
			}
		}
		this.whitespace(token,policy);
	}
	markKeyword(token) {
		let prev = this.getPreviousToken(token);
		if(prev != null) {
			let _g = prev.token.tok;
			switch(_g._hx_index) {
			case 2:
				let _g1 = _g.c;
				prev.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
				break;
			case 20:
				prev.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
				break;
			case 22:
				return;
			default:
			}
		}
		let _g = token.tok;
		if(_g._hx_index == 1) {
			switch(_g.k._hx_index) {
			case 3:
				this.whitespace(token,this.config.whitespace.ifPolicy);
				break;
			case 4:
				let policy = this.config.whitespace.ifPolicy;
				this.whitespace(token,formatter_config_WhitespacePolicy.add(policy,"after"));
				break;
			case 5:
				this.whitespace(token,this.config.whitespace.whilePolicy);
				break;
			case 6:
				this.whitespace(token,this.config.whitespace.doPolicy);
				break;
			case 7:
				this.whitespace(token,this.config.whitespace.forPolicy);
				break;
			case 9:case 16:case 23:case 36:case 37:case 38:
				let next = this.getNextToken(token);
				if(next != null) {
					let _g = next.token.tok;
					switch(_g._hx_index) {
					case 1:
						let _g1 = _g.k;
						this.whitespace(token,"after");
						return;
					case 2:
						let _g2 = _g.c;
						if(_g2._hx_index == 3) {
							let _g = _g2.s;
							this.whitespace(token,"after");
							return;
						}
						break;
					case 21:
						this.whitespace(token,"after");
						return;
					default:
					}
				}
				this.whitespace(token,"noneAfter");
				break;
			case 10:
				this.whitespace(token,"after");
				break;
			case 11:case 12:
				this.whitespace(token,"around");
				break;
			case 14:
				this.whitespace(token,this.config.whitespace.switchPolicy);
				break;
			case 20:
				this.whitespace(token,this.config.whitespace.tryPolicy);
				break;
			case 21:
				this.whitespace(token,this.config.whitespace.catchPolicy);
				break;
			case 28:
				this.whitespace(token,"after");
				break;
			default:
				let next1 = this.getNextToken(token);
				if(next1 != null) {
					switch(next1.token.tok._hx_index) {
					case 11:
						return;
					case 19:
						return;
					default:
					}
				}
				this.whitespace(token,"after");
			}
		}
	}
	markIn(token) {
		if(!tokentree_utils_TokenTreeCheckUtils.hasAtParent(token)) {
			this.whitespace(token,"around");
			return;
		}
		let policy = "after";
		if(token.hasChildren()) {
			policy = "none";
		}
		this.whitespace(token,policy);
	}
	markUnop(token) {
		let next = this.getNextToken(token);
		if(next != null) {
			switch(next.token.tok._hx_index) {
			case 10:case 14:
				return;
			case 11:
				let _g = token.tok;
				if(_g._hx_index == 5) {
					if(_g.op._hx_index == 2) {
						this.whitespace(token,"none");
						return;
					}
				}
				break;
			case 16:case 18:case 20:
				return;
			default:
			}
		}
		let prev = this.getPreviousToken(token);
		if(prev == null) {
			return;
		}
		let _g1 = prev.token.tok;
		if(_g1._hx_index == 2) {
			let _g = _g1.c;
			if(_g._hx_index == 3) {
				let _g1 = _g.s;
				let _g2 = token.tok;
				if(_g2._hx_index == 5) {
					switch(_g2.op._hx_index) {
					case 2:case 3:case 4:
						return;
					default:
					}
				}
				this.whitespace(token,"after");
			}
		}
	}
	markDollar(token) {
		let next = this.getNextToken(token);
		if(next == null) {
			return;
		}
		let _g = next.token.tok;
		switch(_g._hx_index) {
		case 1:
			let _g1 = _g.k;
			this.whitespace(token,"after");
			break;
		case 2:
			let _g2 = _g.c;
			this.whitespace(token,"after");
			break;
		default:
		}
	}
	markDblDot(token) {
		let type = tokentree_utils_TokenTreeCheckUtils.getColonType(token);
		if(type == null) {
			type = tokentree_utils_ColonType.Unknown;
		}
		let policy = this.config.whitespace.colonPolicy;
		switch(type._hx_index) {
		case 0:
			policy = this.config.whitespace.caseColonPolicy;
			break;
		case 1:
			policy = this.config.whitespace.typeHintColonPolicy;
			break;
		case 2:
			policy = this.config.whitespace.typeCheckColonPolicy;
			break;
		case 3:
			policy = this.config.whitespace.ternaryPolicy;
			break;
		case 4:
			policy = this.config.whitespace.objectFieldColonPolicy;
			break;
		case 5:
			this.whitespace(token,"none");
			return;
		case 6:
			policy = this.config.whitespace.colonPolicy;
			break;
		}
		policy = this.correctDblDotSharp(token,policy);
		this.whitespace(token,policy);
	}
	correctDblDotSharp(token,policy) {
		let prev = this.getPreviousToken(token);
		if(prev == null) {
			return policy;
		}
		let _g = prev.token.tok;
		switch(_g._hx_index) {
		case 2:
			let _g1 = _g.c;
			if(prev.token.parent == null) {
				return policy;
			}
			let _g2 = prev.token.parent.tok;
			if(_g2._hx_index == 3) {
				if(_g2.s == "if") {
					if(prev.token.parent.getFirstChild().index == prev.token.index) {
						policy = formatter_config_WhitespacePolicy.add(policy,"before");
					}
				}
			}
			break;
		case 3:
			if(_g.s != "end") {
				policy = formatter_config_WhitespacePolicy.add(policy,"before");
			}
			break;
		case 20:
			if(prev.token.parent == null) {
				return policy;
			}
			let _g3 = prev.token.parent.tok;
			if(_g3._hx_index == 3) {
				if(_g3.s == "if") {
					if(prev.token.parent.getFirstChild().index == prev.token.index) {
						policy = formatter_config_WhitespacePolicy.add(policy,"before");
					}
				}
			}
			break;
		default:
		}
		return policy;
	}
	markSemicolon(token) {
		let next = this.getNextToken(token);
		let policy = this.config.whitespace.semicolonPolicy;
		if(next != null) {
			if(next.token.tok._hx_index == 18) {
				policy = formatter_config_WhitespacePolicy.remove(policy,"after");
			}
		}
		this.whitespace(token,policy);
	}
	markSharp(token) {
		let _g = token.tok;
		if(_g._hx_index == 3) {
			switch(_g.s) {
			case "else":
				this.whitespace(token,"around");
				break;
			case "elseif":
				this.whitespace(token,"around");
				break;
			case "end":
				let prev = this.getPreviousToken(token);
				if(prev != null) {
					switch(prev.token.tok._hx_index) {
					case 15:case 17:case 19:
						break;
					default:
						this.whitespace(token,"before");
					}
				}
				let next = this.getNextToken(token);
				if(next != null) {
					let _g = next.token.tok;
					switch(_g._hx_index) {
					case 1:
						let _g1 = _g.k;
						this.whitespace(token,"after");
						break;
					case 2:
						let _g2 = _g.c;
						this.whitespace(token,"after");
						break;
					case 10:case 14:
						break;
					case 15:case 17:case 19:case 21:
						this.whitespace(token,"after");
						break;
					default:
					}
				}
				break;
			case "error":
				this.whitespace(token,"after");
				break;
			case "if":
				this.whitespace(token,"after");
				let prev1 = this.getPreviousToken(token);
				if(prev1 != null) {
					let _g = prev1.token.tok;
					switch(_g._hx_index) {
					case 1:
						let _g1 = _g.k;
						this.whitespace(token,"before");
						break;
					case 2:
						let _g2 = _g.c;
						this.whitespace(token,"before");
						break;
					default:
					}
				}
				let next1 = this.getNextToken(token);
				if(next1 != null) {
					let lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(token.getFirstChild());
					if(lastChild != null) {
						this.whitespace(lastChild,"after");
					}
				}
				break;
			default:
			}
		}
	}
	markArrow(token) {
		let arrowType = tokentree_utils_TokenTreeCheckUtils.getArrowType(token);
		if(arrowType == null) {
			arrowType = tokentree_utils_ArrowType.ArrowFunction;
		}
		switch(arrowType._hx_index) {
		case 0:
			this.whitespace(token,this.config.whitespace.arrowFunctionsPolicy);
			break;
		case 1:
			this.whitespace(token,this.config.whitespace.functionTypeHaxe3Policy);
			break;
		case 2:
			this.whitespace(token,this.config.whitespace.functionTypeHaxe4Policy);
			break;
		}
	}
	determinePOpenPolicy(token) {
		let type = tokentree_utils_TokenTreeCheckUtils.getPOpenType(token);
		if(type == null) {
			type = tokentree_utils_POpenType.Expression;
		}
		switch(type._hx_index) {
		case 0:
			this.config.whitespace.parenConfig.metadataParens.openingPolicy = formatter_config_WhitespacePolicy.remove(this.config.whitespace.parenConfig.metadataParens.openingPolicy,"before");
			return this.config.whitespace.parenConfig.metadataParens;
		case 1:
			let _g = token.parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 10:
					let policy = { openingPolicy : this.config.whitespace.parenConfig.anonFuncParamParens.openingPolicy, closingPolicy : this.config.whitespace.parenConfig.anonFuncParamParens.closingPolicy, removeInnerWhenEmpty : this.config.whitespace.parenConfig.anonFuncParamParens.removeInnerWhenEmpty};
					switch(policy.openingPolicy) {
					case "after":
						policy.openingPolicy = "around";
						break;
					case "around":
						break;
					case "before":
						break;
					case "none":
						policy.openingPolicy = "before";
						break;
					case "noneAfter":
						policy.openingPolicy = "onlyBefore";
						break;
					case "noneBefore":
						policy.openingPolicy = "before";
						break;
					case "onlyAfter":
						policy.openingPolicy = "around";
						break;
					case "onlyBefore":
						break;
					}
					return policy;
				case 22:
					return this.config.whitespace.parenConfig.funcParamParens;
				default:
					return this.config.whitespace.parenConfig.anonFuncParamParens;
				}
				break;
			case 2:
				let _g1 = _g.c;
				if(_g1._hx_index == 3) {
					let _g = _g1.s;
					return this.config.whitespace.parenConfig.funcParamParens;
				} else {
					return this.config.whitespace.parenConfig.anonFuncParamParens;
				}
				break;
			default:
				return this.config.whitespace.parenConfig.anonFuncParamParens;
			}
			break;
		case 2:
			return this.config.whitespace.parenConfig.callParens;
		case 3:
			if(this.config.whitespace.parenConfig.switchConditionParens != null) {
				return this.config.whitespace.parenConfig.switchConditionParens;
			}
			return this.config.whitespace.parenConfig.conditionParens;
		case 4:
			if(this.config.whitespace.parenConfig.whileConditionParens != null) {
				return this.config.whitespace.parenConfig.whileConditionParens;
			}
			return this.config.whitespace.parenConfig.conditionParens;
		case 5:
			if(this.config.whitespace.parenConfig.ifConditionParens != null) {
				return this.config.whitespace.parenConfig.ifConditionParens;
			}
			return this.config.whitespace.parenConfig.conditionParens;
		case 6:
			if(this.config.whitespace.parenConfig.sharpConditionParens != null) {
				return this.config.whitespace.parenConfig.sharpConditionParens;
			}
			return this.config.whitespace.parenConfig.conditionParens;
		case 7:
			if(this.config.whitespace.parenConfig.catchParens != null) {
				return this.config.whitespace.parenConfig.catchParens;
			}
			return this.config.whitespace.parenConfig.conditionParens;
		case 8:
			return this.config.whitespace.parenConfig.forLoopParens;
		case 9:
			return this.config.whitespace.parenConfig.expressionParens;
		}
	}
	markPOpen(token) {
		let openClosePolicy = this.determinePOpenPolicy(token);
		let policy = openClosePolicy.openingPolicy;
		let prev = this.getPreviousToken(token);
		if(prev != null) {
			let _g = prev.token.tok;
			switch(_g._hx_index) {
			case 5:
				let _g1 = _g.op;
				policy = formatter_config_WhitespacePolicy.remove(policy,"before");
				break;
			case 6:
				let _g2 = _g.op;
				if(prev.spacesAfter > 0) {
					policy = formatter_config_WhitespacePolicy.add(policy,"before");
				}
				break;
			case 7:
				let _g3 = _g.s;
				if(prev.spacesAfter > 0) {
					policy = formatter_config_WhitespacePolicy.add(policy,"before");
				}
				break;
			default:
			}
		}
		if(openClosePolicy.removeInnerWhenEmpty) {
			let next = this.getNextToken(token);
			if(next != null) {
				if(next.token.tok._hx_index == 20) {
					policy = formatter_config_WhitespacePolicy.remove(policy,"after");
				}
			}
		}
		this.successiveParenthesis(token,false,policy,this.config.whitespace.compressSuccessiveParenthesis);
	}
	markPClose(token) {
		let openClosePolicy = this.determinePOpenPolicy(token.parent);
		let policy = openClosePolicy.closingPolicy;
		if(openClosePolicy.removeInnerWhenEmpty) {
			let prev = this.getPreviousToken(token);
			if(prev != null) {
				if(prev.token.tok._hx_index == 19) {
					policy = formatter_config_WhitespacePolicy.remove(policy,"before");
				}
			}
		}
		this.successiveParenthesis(token,true,policy,this.config.whitespace.compressSuccessiveParenthesis);
	}
	determineBrOpenPolicy(token) {
		let type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(token);
		if(type == null) {
			type = tokentree_utils_BrOpenType.Unknown;
		}
		switch(type._hx_index) {
		case 0:
			return this.config.whitespace.bracesConfig.blockBraces;
		case 1:
			return this.config.whitespace.bracesConfig.typedefBraces;
		case 2:
			return this.config.whitespace.bracesConfig.objectLiteralBraces;
		case 3:
			return this.config.whitespace.bracesConfig.anonTypeBraces;
		case 4:
			return this.config.whitespace.bracesConfig.unknownBraces;
		}
	}
	markBrOpen(token) {
		let openClosePolicy = this.determineBrOpenPolicy(token);
		let policy = openClosePolicy.openingPolicy;
		if(openClosePolicy.removeInnerWhenEmpty) {
			let next = this.getNextToken(token);
			if(next != null) {
				if(next.token.tok._hx_index == 18) {
					policy = formatter_config_WhitespacePolicy.remove(policy,"after");
				}
			}
		}
		this.successiveParenthesis(token,false,policy,this.config.whitespace.compressSuccessiveParenthesis);
	}
	markBrClose(token) {
		let openClosePolicy = this.determineBrOpenPolicy(token.parent);
		let policy = openClosePolicy.closingPolicy;
		if(openClosePolicy.removeInnerWhenEmpty) {
			let prev = this.getPreviousToken(token);
			if(prev != null) {
				if(prev.token.tok._hx_index == 17) {
					policy = formatter_config_WhitespacePolicy.remove(policy,"before");
				}
			}
		}
		this.successiveParenthesis(token,true,policy,this.config.whitespace.compressSuccessiveParenthesis);
	}
	markComment(token) {
		let policy = "around";
		let prev = this.getPreviousToken(token);
		if(prev != null) {
			let _g = prev.token.tok;
			switch(_g._hx_index) {
			case 6:
				if(_g.op._hx_index == 9) {
					if(tokentree_utils_TokenTreeCheckUtils.isTypeParameter(prev.token)) {
						policy = formatter_config_WhitespacePolicy.remove(policy,"before");
					}
				}
				break;
			case 15:case 17:case 19:
				policy = formatter_config_WhitespacePolicy.remove(policy,"before");
				break;
			default:
			}
		}
		let next = this.getNextToken(token);
		if(next != null) {
			switch(next.token.tok._hx_index) {
			case 14:
				policy = formatter_config_WhitespacePolicy.remove(policy,"after");
				break;
			case 16:case 18:case 20:
				policy = formatter_config_WhitespacePolicy.remove(policy,"after");
				break;
			default:
			}
		}
		this.whitespace(token,policy);
	}
	markAt(token) {
		let prev = this.getPreviousToken(token);
		if(prev == null) {
			return;
		}
		switch(prev.whitespaceAfter._hx_index) {
		case 0:
			break;
		case 1:case 2:
			return;
		}
		let _g = prev.token.tok;
		switch(_g._hx_index) {
		case 0:
			return;
		case 1:
			let _g1 = _g.k;
			break;
		case 2:
			let _g2 = _g.c;
			break;
		case 3:
			let _g3 = _g.s;
			break;
		case 4:
			let _g4 = _g.s;
			break;
		case 5:
			let _g5 = _g.op;
			break;
		case 6:
			if(_g.op._hx_index == 9) {
				if(tokentree_utils_TokenTreeCheckUtils.isTypeParameter(prev.token)) {
					return;
				}
			}
			break;
		case 7:
			let _g6 = _g.s;
			return;
		case 8:
			let _g7 = _g.s;
			return;
		case 9:
			let _g8 = _g.s;
			break;
		case 10:
			return;
		case 11:
			break;
		case 12:
			break;
		case 13:
			break;
		case 14:
			break;
		case 16:
			break;
		case 18:
			break;
		case 15:case 17:case 19:
			return;
		case 20:
			break;
		case 21:
			break;
		case 22:
			break;
		case 23:
			return;
		}
		this.whitespace(token,"before");
	}
}
$hxClasses["formatter.marker.MarkWhitespace"] = formatter_marker_MarkWhitespace;
formatter_marker_MarkWhitespace.__name__ = "formatter.marker.MarkWhitespace";
formatter_marker_MarkWhitespace.__super__ = formatter_marker_MarkerBase;
Object.assign(formatter_marker_MarkWhitespace.prototype, {
	__class__: formatter_marker_MarkWhitespace
});
class formatter_marker_wrapping_MarkWrappingBase extends formatter_marker_MarkerBase {
	constructor(config,parsedCode,indenter) {
		super(config,parsedCode,indenter);
		this.wrappingQueue = [];
	}
	noWrap(open,close) {
		let colon = tokentree_TokenTreeAccessHelper.is(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.is(open,tokentree_TokenTreeDef.BrOpen)),tokentree_TokenTreeDef.DblDot);
		if(colon != null) {
			let type = tokentree_utils_TokenTreeCheckUtils.getColonType(colon);
			switch(type._hx_index) {
			case 0:
				break;
			case 1:
				break;
			case 2:
				break;
			case 3:
				break;
			case 4:
				this.noLineEndBefore(open);
				break;
			case 5:
				break;
			case 6:
				break;
			}
		}
		this.noWrappingBetween(open,close);
		let _g = 0;
		let _g1 = open.children;
		_hx_loop1: while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			switch(_g2._hx_index) {
			case 6:
				if(_g2.op._hx_index == 7) {
					continue;
				}
				break;
			case 10:case 14:
				continue;
			case 16:case 18:case 20:
				break _hx_loop1;
			default:
			}
			let lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
			if(lastChild == null) {
				continue;
			} else {
				switch(lastChild.tok._hx_index) {
				case 10:case 14:
					this.noLineEndAfter(lastChild);
					break;
				default:
				}
			}
		}
		this.noLineEndBefore(close);
	}
	keep2(open,close,items,addIndent,location) {
		let tokens = [];
		let _g = [];
		let _g1 = 0;
		while(_g1 < items.length) {
			let item = items[_g1];
			++_g1;
			_g.push(item.last);
		}
		tokens = _g;
		if(items.length > 0) {
			tokens.unshift(items[0].first);
		}
		let _g2 = [];
		let _g3 = 0;
		while(_g3 < items.length) {
			let item = items[_g3];
			++_g3;
			_g2.push(item.first);
		}
		tokens = tokens.concat(_g2);
		if(close != null) {
			tokens.push(close);
		}
		tokens.push(close);
		let _g4 = 0;
		while(_g4 < tokens.length) {
			let token = tokens[_g4];
			++_g4;
			if(this.parsedCode.isOriginalNewlineBefore(token)) {
				this.lineEndBefore(token);
				this.additionalIndent(token,addIndent);
			} else {
				this.noLineEndBefore(token);
				this.wrapBefore(token,false);
			}
		}
	}
	keep(open,close,addIndent) {
		this.noWrappingBetween(open,close);
		let _g = 0;
		let _g1 = open.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let last = false;
			let _g2 = child.tok;
			switch(_g2._hx_index) {
			case 6:
				if(_g2.op._hx_index == 7) {
					continue;
				}
				break;
			case 10:case 14:
				continue;
			case 16:case 18:case 20:
				last = true;
				break;
			default:
			}
			if(this.parsedCode.isOriginalNewlineBefore(child)) {
				this.lineEndBefore(child);
				this.additionalIndent(child,addIndent);
			} else {
				this.noLineEndBefore(child);
				this.wrapBefore(child,false);
			}
			if(last) {
				break;
			}
		}
		if(!this.parsedCode.isOriginalNewlineBefore(open)) {
			this.noLineEndBefore(open);
		}
	}
	wrapChildOneLineEach2(open,close,items,addIndent,location,keepFirst) {
		if(keepFirst == null) {
			keepFirst = false;
		}
		if(addIndent == null) {
			addIndent = 0;
		}
		if(items.length <= 0) {
			return;
		}
		switch(location) {
		case "afterLast":
			let _g = 0;
			while(_g < items.length) {
				let item = items[_g];
				++_g;
				this.additionalIndent(item.first,addIndent);
				this.lineEndBefore(item.first);
				let _g1 = item.last.tok;
				if(_g1._hx_index == 3) {
					let _g = _g1.s;
					this.lineEndBefore(item.last);
				}
			}
			break;
		case "beforeLast":
			let item = items[0];
			this.additionalIndent(item.first,addIndent);
			this.lineEndBefore(item.first);
			item = items.pop();
			let _g1 = 0;
			while(_g1 < items.length) {
				let it = items[_g1];
				++_g1;
				this.additionalIndent(it.last,addIndent);
				this.lineEndBefore(it.last);
			}
			items.push(item);
			break;
		}
		if(keepFirst) {
			if(open != null) {
				this.noLineEndAfter(open);
			}
			let lastToken = items[items.length - 1].last;
			if(lastToken.tok._hx_index != 10) {
				let next = this.getNextToken(lastToken);
				if(next == null) {
					this.noLineEndAfter(lastToken);
					return;
				}
				let _g = next.token.tok;
				switch(_g._hx_index) {
				case 1:
					switch(_g.k._hx_index) {
					case 22:case 23:case 36:
						this.noLineEndAfter(lastToken);
						break;
					default:
					}
					break;
				case 10:
					break;
				default:
					this.noLineEndAfter(lastToken);
				}
			}
		} else {
			let lastToken = items[items.length - 1].last;
			let next = this.getNextToken(lastToken);
			if(next == null) {
				this.lineEndAfter(lastToken);
				return;
			}
			let _g = next.token.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 22:case 23:case 36:
					this.lineEndAfter(lastToken);
					break;
				default:
				}
				break;
			case 10:
				break;
			case 15:case 17:case 19:
				break;
			default:
				this.lineEndAfter(lastToken);
			}
		}
	}
	wrapChildOneLineEach(open,close,addIndent,keepFirst) {
		if(keepFirst == null) {
			keepFirst = false;
		}
		if(addIndent == null) {
			addIndent = 0;
		}
		if(!keepFirst) {
			this.lineEndAfter(open);
		}
		let _g = 0;
		let _g1 = open.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			switch(_g2._hx_index) {
			case 3:
				let _g3 = _g2.s;
				this.wrapChildOneLineEachSharp(child,addIndent,keepFirst);
				break;
			case 6:
				if(_g2.op._hx_index == 7) {
					if(keepFirst) {
						this.noLineEndBefore(child);
					}
					return;
				} else {
					this.additionalIndent(child,addIndent);
				}
				break;
			case 8:
				let _g4 = _g2.s;
				let prev = this.getPreviousToken(child);
				if(prev != null) {
					if(this.parsedCode.isOriginalSameLine(child,prev.token)) {
						this.noLineEndBefore(child);
					}
				}
				this.lineEndAfter(child);
				this.additionalIndent(child,addIndent);
				continue;
			case 16:case 18:case 20:
				if(keepFirst) {
					this.noLineEndBefore(child);
				}
				return;
			default:
				this.additionalIndent(child,addIndent);
			}
			let lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
			if(lastChild == null) {
				this.lineEndAfter(child);
			} else {
				this.lineEndAfter(lastChild);
			}
		}
		if(close == null) {
			return;
		}
		switch(close.tok._hx_index) {
		case 16:case 18:case 20:
			this.lineEndBefore(close);
			break;
		default:
		}
	}
	wrapChildOneLineEachSharp(sharp,addIndent,keepFirst) {
		if(keepFirst == null) {
			keepFirst = false;
		}
		if(addIndent == null) {
			addIndent = 0;
		}
		let children = sharp.children;
		let skipFirst = false;
		this.lineEndBefore(sharp);
		let _g = sharp.tok;
		if(_g._hx_index == 3) {
			switch(_g.s) {
			case "else":
				this.lineEndAfter(sharp);
				break;
			case "elseif":
				this.lineEndAfter(tokentree_utils_TokenTreeCheckUtils.getLastToken(sharp.getFirstChild()));
				skipFirst = true;
				break;
			case "end":
				this.lineEndAfter(sharp);
				return;
			case "if":
				this.lineEndAfter(tokentree_utils_TokenTreeCheckUtils.getLastToken(sharp.getFirstChild()));
				skipFirst = true;
				break;
			default:
			}
		}
		let _g1 = 0;
		while(_g1 < children.length) {
			let child = children[_g1];
			++_g1;
			if(skipFirst) {
				skipFirst = false;
				continue;
			}
			let _g = child.tok;
			switch(_g._hx_index) {
			case 3:
				let _g2 = _g.s;
				this.wrapChildOneLineEachSharp(child,addIndent,keepFirst);
				break;
			case 6:
				if(_g.op._hx_index == 7) {
					if(keepFirst) {
						this.whitespace(child,"noneBefore");
					}
					return;
				} else {
					this.additionalIndent(child,addIndent);
				}
				break;
			case 8:
				let _g3 = _g.s;
				let prev = this.getPreviousToken(child);
				if(prev != null) {
					if(this.parsedCode.isOriginalSameLine(child,prev.token)) {
						this.noLineEndBefore(child);
					}
				}
				this.lineEndAfter(child);
				this.additionalIndent(child,addIndent);
				continue;
			case 16:case 18:case 20:
				if(keepFirst) {
					this.whitespace(child,"noneBefore");
				}
				return;
			default:
				this.additionalIndent(child,addIndent);
			}
		}
	}
	wrapFillLine2AfterLast(open,close,items,maxLineLength,addIndent,useTrailing) {
		if(useTrailing == null) {
			useTrailing = false;
		}
		if(addIndent == null) {
			addIndent = 0;
		}
		if(items.length <= 0) {
			return;
		}
		let lineStart = open;
		if(lineStart == null) {
			lineStart = items[0].first;
		}
		lineStart = this.findLineStartToken(lineStart);
		if(lineStart == null) {
			return;
		}
		let indent = this.indenter.calcIndent(lineStart);
		let lineLength = this.calcLineLengthBefore(open) + this.indenter.calcAbsoluteIndent(indent) + this.calcTokenLength(open);
		let first = false;
		let _g = 0;
		while(_g < items.length) {
			let item = items[_g];
			++_g;
			let tokenLength = item.firstLineLength;
			if(!first && lineLength + tokenLength >= maxLineLength) {
				this.lineEndBefore(item.first);
				this.additionalIndent(item.first,addIndent);
				lineLength = this.indenter.calcAbsoluteIndent(indent + 1 + addIndent);
				if(item.multiline) {
					lineLength = item.lastLineLength;
				} else {
					lineLength += item.firstLineLength;
				}
				continue;
			} else {
				this.noLineEndBefore(item.first);
				lineLength += tokenLength;
				first = false;
				if(item.multiline) {
					lineLength = item.lastLineLength;
				}
			}
		}
		if(useTrailing) {
			let lastItem = items[items.length - 1];
			let lengthAfter = this.calcLineLengthAfter(lastItem.last);
			if(lineLength + lengthAfter >= maxLineLength) {
				this.lineEndBefore(lastItem.first);
				this.additionalIndent(lastItem.first,addIndent);
			}
		}
		this.noLineEndAfter(open);
		this.wrapAfter(open,false);
	}
	wrapFillLineWithLeading2AfterLast(open,close,items,maxLineLength,addIndent) {
		if(addIndent == null) {
			addIndent = 0;
		}
		if(items.length <= 0) {
			return;
		}
		let lineStart = open;
		if(lineStart == null) {
			lineStart = items[0].first;
		}
		lineStart = this.findLineStartToken(lineStart);
		if(lineStart == null) {
			return;
		}
		let indent = this.indenter.calcIndent(lineStart);
		let lineLength = this.indenter.calcAbsoluteIndent(indent + 1 + addIndent);
		let first = true;
		let _g = 0;
		while(_g < items.length) {
			let item = items[_g];
			++_g;
			let tokenLength = item.firstLineLength;
			if(lineLength + tokenLength >= maxLineLength) {
				this.lineEndBefore(item.first);
				this.additionalIndent(item.first,addIndent);
				lineLength = this.indenter.calcAbsoluteIndent(indent + 1 + addIndent);
				if(item.multiline) {
					lineLength = item.lastLineLength;
				} else {
					lineLength += item.firstLineLength;
				}
				continue;
			} else {
				if(!first) {
					this.noLineEndBefore(item.first);
				} else {
					this.lineEndBefore(item.first);
				}
				lineLength += tokenLength;
				first = false;
				if(item.multiline) {
					lineLength = item.lastLineLength;
				}
			}
		}
		let lastItem = items[items.length - 1];
		switch(lastItem.last.tok._hx_index) {
		case 10:
			break;
		case 12:
			break;
		case 16:case 18:case 20:
			if(this.isNewLineAfter(lastItem.last)) {
				this.lineEndAfter(lastItem.last);
			}
			break;
		default:
			this.lineEndAfter(lastItem.last);
		}
	}
	wrapFillLine2BeforeLast(open,close,items,maxLineLength,addIndent,useTrailing) {
		if(useTrailing == null) {
			useTrailing = false;
		}
		if(addIndent == null) {
			addIndent = 0;
		}
		if(items.length <= 0) {
			return;
		}
		let lineStart = open;
		if(lineStart == null) {
			lineStart = items[0].first;
		}
		lineStart = this.findLineStartToken(lineStart);
		if(lineStart == null) {
			return;
		}
		let indent = this.indenter.calcIndent(lineStart);
		let lineLength = this.calcLineLengthBefore(open) + this.indenter.calcAbsoluteIndent(indent) + this.calcTokenLength(open);
		let first = true;
		let _g = 0;
		while(_g < items.length) {
			let item = items[_g];
			++_g;
			let tokenLength = item.firstLineLength;
			if(!first && lineLength + tokenLength >= maxLineLength) {
				lineLength = this.indenter.calcAbsoluteIndent(indent + 1 + addIndent);
				let prev = this.getPreviousToken(item.first);
				if(prev != null) {
					this.lineEndBefore(prev.token);
					this.additionalIndent(prev.token,addIndent);
					lineLength += prev.text.length;
				}
				if(item.multiline) {
					lineLength += item.lastLineLength;
				} else {
					lineLength += item.firstLineLength;
				}
				continue;
			} else {
				if(first) {
					this.noLineEndBefore(item.first);
				} else {
					let prev = this.getPreviousToken(item.first);
					if(prev != null) {
						this.noLineEndBefore(prev.token);
					}
				}
				lineLength += tokenLength;
				first = false;
				if(item.multiline) {
					lineLength = this.indenter.calcAbsoluteIndent(indent + 1 + addIndent) + item.lastLineLength;
				}
			}
		}
		if(useTrailing) {
			let lastItem = items[items.length - 1];
			let lengthAfter = this.calcLineLengthAfter(lastItem.last);
			let prev = this.getPreviousToken(lastItem.first);
			if(prev != null && lineLength + lengthAfter >= maxLineLength) {
				this.lineEndBefore(prev.token);
				this.additionalIndent(prev.token,addIndent);
			}
		}
		this.noLineEndAfter(open);
		this.wrapAfter(open,false);
	}
	wrapFillLine(open,close,maxLineLength,addIndent,useTrailing) {
		if(useTrailing == null) {
			useTrailing = false;
		}
		if(addIndent == null) {
			addIndent = 0;
		}
		let lineStart = this.findLineStartToken(open);
		if(lineStart == null) {
			return;
		}
		let indent = this.indenter.calcIndent(lineStart);
		let lineLength = this.calcLineLengthBefore(open) + this.indenter.calcAbsoluteIndent(indent + addIndent);
		let first = true;
		let _g = 0;
		let _g1 = open.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			switch(_g2._hx_index) {
			case 1:
				if(_g2.k._hx_index == 0) {
					continue;
				} else {
					this.additionalIndent(child,addIndent);
				}
				break;
			case 6:
				if(_g2.op._hx_index == 7) {
					this.whitespace(child,"noneBefore");
					return;
				} else {
					this.additionalIndent(child,addIndent);
				}
				break;
			case 8:
				let _g3 = _g2.s;
				let prev = this.getPreviousToken(child);
				if(prev != null) {
					if(this.parsedCode.isOriginalSameLine(child,prev.token)) {
						this.noLineEndBefore(child);
					}
				}
				this.lineEndAfter(child);
				this.additionalIndent(child,addIndent);
				continue;
			case 17:
				continue;
			case 16:case 18:case 20:
				this.whitespace(child,"noneBefore");
				if(useTrailing) {
					let trailing = this.calcLineLengthAfter(child);
					if(trailing + lineLength > maxLineLength) {
						let prev = child.previousSibling;
						if(prev == null) {
							return;
						}
						this.lineEndBefore(prev);
						this.additionalIndent(prev,addIndent);
					}
				}
				return;
			default:
				this.additionalIndent(child,addIndent);
			}
			let tokenLength = this.calcLength(child);
			let lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
			if(lastChild == null) {
				lastChild = child;
			}
			lineLength += tokenLength;
			if(lineLength > maxLineLength) {
				this.lineEndBefore(child);
				this.noLineEndAfter(lastChild);
				indent = this.indenter.calcIndent(child);
				lineLength = tokenLength + this.indenter.calcAbsoluteIndent(indent);
			} else {
				this.noLineEndAfter(lastChild);
			}
			if(first) {
				first = false;
				this.noLineEndBefore(child);
			}
		}
	}
	calcLineLength(token) {
		let indent = this.indenter.calcIndent(token);
		return super.calcLineLength(token) + this.indenter.calcAbsoluteIndent(indent);
	}
	hasEmptyFunctionBody(token) {
		let last = token.getLastChild();
		if(last.tok._hx_index == 10) {
			return true;
		}
		let body = token.nextSibling;
		if(body == null) {
			return true;
		}
		if(body.is(tokentree_TokenTreeDef.DblDot)) {
			body = body.nextSibling;
		}
		while(body != null && body.is(tokentree_TokenTreeDef.At)) body = body.nextSibling;
		if(body == null) {
			return true;
		}
		switch(body.tok._hx_index) {
		case 10:
			return true;
		case 17:
			let brClose = body.getFirstChild();
			if(brClose == null) {
				return false;
			}
			return brClose.is(tokentree_TokenTreeDef.BrClose);
		default:
			return false;
		}
	}
	makeWrappableItems(token) {
		let items = [];
		let lastIndex = -1;
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			switch(_g2._hx_index) {
			case 6:
				if(_g2.op._hx_index == 7) {
					return items;
				}
				break;
			case 16:case 18:case 20:
				return items;
			default:
			}
			if(child.index <= lastIndex) {
				continue;
			}
			let endToken = this.findItemEnd(child);
			if(endToken == null) {
				continue;
			}
			lastIndex = endToken.index;
			let sameLine = this.isSameLineBetween(child,endToken,false);
			let firstLineLength = this.calcLengthUntilNewline(child,endToken);
			if(this.isMultilineToken(endToken)) {
				sameLine = false;
			}
			let lastLineLength = 0;
			if(!sameLine) {
				lastLineLength = this.calcLineLengthAfter(endToken);
			}
			let item = { first : child, last : endToken, multiline : !sameLine, firstLineLength : firstLineLength, lastLineLength : lastLineLength};
			items.push(item);
		}
		return items;
	}
	findItemEnd(child) {
		let endToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
		if(endToken == null) {
			return null;
		}
		if(endToken.tok._hx_index == 14) {
			let next = this.getNextToken(endToken);
			if(next == null) {
				return endToken;
			}
			let _g = next.token.tok;
			switch(_g._hx_index) {
			case 7:
				let s = _g.s;
				if(this.parsedCode.isOriginalSameLine(endToken,next.token)) {
					return next.token;
				}
				break;
			case 8:
				let s1 = _g.s;
				if(this.parsedCode.isOriginalSameLine(endToken,next.token)) {
					return next.token;
				}
				break;
			default:
			}
			return endToken;
		}
		let next = this.getNextToken(endToken);
		if(next == null) {
			return endToken;
		}
		let _g = next.token.tok;
		switch(_g._hx_index) {
		case 6:
			if(_g.op._hx_index == 7) {
				if(tokentree_TokenTreeAccessHelper.is(tokentree_TokenTreeAccessHelper.parent(next.token),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpLt)) != null) {
					return endToken;
				}
				return this.findItemEnd(next.token);
			} else {
				return this.findItemEnd(next.token);
			}
			break;
		case 7:
			let _g1 = _g.s;
			return this.findItemEnd(next.token);
		case 8:
			let _g2 = _g.s;
			return this.findItemEnd(next.token);
		default:
		}
		return endToken;
	}
	determineWrapType2(rules,token,items) {
		let itemCount = items.length;
		if(items.length <= 0) {
			return { conditions : [], type : rules.defaultWrap, location : rules.defaultLocation, additionalIndent : rules.defaultAdditionalIndent};
		}
		let maxItemLength = 0;
		let totalItemLength = 0;
		let lineLength = this.calcLineLength(token);
		let hasMultiLineItem = false;
		let _g = 0;
		while(_g < items.length) {
			let item = items[_g];
			++_g;
			totalItemLength += item.firstLineLength + item.lastLineLength;
			if(item.multiline) {
				hasMultiLineItem = true;
			}
			let length = Math.floor(Math.max(item.firstLineLength,item.lastLineLength));
			if(length > maxItemLength) {
				maxItemLength = length;
			}
		}
		let _g1 = 0;
		let _g2 = rules.rules;
		while(_g1 < _g2.length) {
			let rule = _g2[_g1];
			++_g1;
			if(this.matchesRule(rule,itemCount,maxItemLength,totalItemLength,lineLength,hasMultiLineItem)) {
				return rule;
			}
		}
		return { conditions : [], type : rules.defaultWrap, location : rules.defaultLocation, additionalIndent : rules.defaultAdditionalIndent};
	}
	determineWrapType(rules,itemCount,maxItemLength,totalItemLength,lineLength) {
		let _g = 0;
		let _g1 = rules.rules;
		while(_g < _g1.length) {
			let rule = _g1[_g];
			++_g;
			if(this.matchesRule(rule,itemCount,maxItemLength,totalItemLength,lineLength,false)) {
				return rule;
			}
		}
		return { conditions : [], type : rules.defaultWrap, location : rules.defaultLocation, additionalIndent : rules.defaultAdditionalIndent};
	}
	matchesRule(rule,itemCount,maxItemLength,totalItemLength,lineLength,hasMultiLineItem) {
		let _g = 0;
		let _g1 = rule.conditions;
		while(_g < _g1.length) {
			let cond = _g1[_g];
			++_g;
			switch(cond.cond) {
			case "anyItemLength <= n":
				if(maxItemLength > cond.value) {
					return false;
				}
				break;
			case "anyItemLength >= n":
				if(maxItemLength < cond.value) {
					return false;
				}
				break;
			case "exceedsMaxLineLength":
				if(cond.value == 1) {
					if(lineLength <= this.config.wrapping.maxLineLength) {
						return false;
					}
				} else if(lineLength > this.config.wrapping.maxLineLength) {
					return false;
				}
				break;
			case "hasMultilineItems":
				if(cond.value == 1) {
					if(!hasMultiLineItem) {
						return false;
					}
				} else if(hasMultiLineItem) {
					return false;
				}
				break;
			case "itemCount <= n":
				if(itemCount > cond.value) {
					return false;
				}
				break;
			case "itemCount >= n":
				if(itemCount < cond.value) {
					return false;
				}
				break;
			case "lineLength <= n":
				if(lineLength > cond.value) {
					return false;
				}
				break;
			case "lineLength >= n":
				if(lineLength < cond.value) {
					return false;
				}
				break;
			case "totalItemLength <= n":
				if(totalItemLength > cond.value) {
					return false;
				}
				break;
			case "totalItemLength >= n":
				if(totalItemLength < cond.value) {
					return false;
				}
				break;
			}
		}
		return true;
	}
	applyRule(rule,open,close,items,addIndent,useTrailing) {
		let location = "afterLast";
		if(rule.location != null) {
			location = rule.location;
		}
		switch(rule.type) {
		case "equalNumber":
			break;
		case "fillLine":
			switch(location) {
			case "afterLast":
				this.wrapFillLine2AfterLast(open,close,items,this.config.wrapping.maxLineLength,addIndent,useTrailing);
				break;
			case "beforeLast":
				this.wrapFillLine2BeforeLast(open,close,items,this.config.wrapping.maxLineLength,addIndent,useTrailing);
				break;
			}
			break;
		case "fillLineWithLeadingBreak":
			switch(location) {
			case "afterLast":
				this.wrapFillLineWithLeading2AfterLast(open,close,items,this.config.wrapping.maxLineLength,addIndent);
				break;
			case "beforeLast":
				this.wrapFillLine2BeforeLast(open,close,items,this.config.wrapping.maxLineLength,addIndent,useTrailing);
				break;
			}
			break;
		case "keep":
			this.keep2(open,close,items,addIndent,location);
			break;
		case "noWrap":
			this.noWrappingBetween(open,close,false);
			break;
		case "onePerLine":
			this.wrapChildOneLineEach2(open,close,items,addIndent,location);
			break;
		case "onePerLineAfterFirst":
			this.wrapChildOneLineEach2(open,close,items,addIndent,location,true);
			break;
		}
	}
	applyWrappingQueue() {
		let _g = 0;
		let _g1 = this.wrappingQueue;
		while(_g < _g1.length) {
			let place = _g1[_g];
			++_g;
			this.applyWrappingPlace(place);
		}
	}
	applyWrappingPlace(place) {
		let rule = this.determineWrapType2(place.rules,place.start,place.items);
		let additionalIndent = rule.additionalIndent;
		if(place.overrideAdditionalIndent != null) {
			additionalIndent = place.overrideAdditionalIndent;
		}
		this.applyRule(rule,place.start,place.end,place.items,additionalIndent,place.useTrailing);
	}
	queueWrapping(place,name) {
		if(place.items == null || place.items.length <= 0) {
			return;
		}
		let startIndex = this.getPlaceStartIndex(place);
		let endIndex = this.getPlaceEndIndex(place);
		if(startIndex < 0 || endIndex < 0) {
			return;
		}
		let index = 0;
		let _g = 0;
		let _g1 = this.wrappingQueue.length;
		while(_g < _g1) {
			let index = _g++;
			let p = this.wrappingQueue[index];
			let itemStart = this.getPlaceStartIndex(p);
			if(startIndex > itemStart) {
				continue;
			}
			if(startIndex == itemStart) {
				let itemEnd = this.getPlaceEndIndex(p);
				if(endIndex > itemEnd) {
					this.wrappingQueue.splice(index,0,place);
					return;
				}
				continue;
			}
			this.wrappingQueue.splice(index,0,place);
			return;
		}
		this.wrappingQueue.push(place);
	}
	getPlaceStartIndex(place) {
		if(place.items == null || place.items.length <= 0) {
			return -1;
		}
		if(place.start != null) {
			return place.start.index;
		} else {
			return place.items[0].first.index;
		}
	}
	getPlaceEndIndex(place) {
		if(place.items == null || place.items.length <= 0) {
			return -1;
		}
		if(place.end != null) {
			return place.end.index;
		} else {
			return place.items[place.items.length - 1].last.index;
		}
	}
}
$hxClasses["formatter.marker.wrapping.MarkWrappingBase"] = formatter_marker_wrapping_MarkWrappingBase;
formatter_marker_wrapping_MarkWrappingBase.__name__ = "formatter.marker.wrapping.MarkWrappingBase";
formatter_marker_wrapping_MarkWrappingBase.__super__ = formatter_marker_MarkerBase;
Object.assign(formatter_marker_wrapping_MarkWrappingBase.prototype, {
	__class__: formatter_marker_wrapping_MarkWrappingBase
	,wrappingQueue: null
});
class formatter_marker_wrapping_MarkWrapping extends formatter_marker_wrapping_MarkWrappingBase {
	constructor(config,parsedCode,indenter) {
		super(config,parsedCode,indenter);
	}
	run() {
		let _gthis = this;
		let wrappableTokens = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			switch(_g._hx_index) {
			case 6:
				switch(_g.op._hx_index) {
				case 0:
					return tokentree_FilterResult.FoundGoDeeper;
				case 9:
					return tokentree_FilterResult.FoundGoDeeper;
				case 22:
					return tokentree_FilterResult.FoundGoDeeper;
				default:
				}
				break;
			case 8:
				let _g1 = _g.s;
				return tokentree_FilterResult.FoundGoDeeper;
			case 11:
				return tokentree_FilterResult.FoundGoDeeper;
			case 13:
				return tokentree_FilterResult.FoundGoDeeper;
			case 14:
				_gthis.wrapAfter(token,true);
				return tokentree_FilterResult.GoDeeper;
			case 15:
				return tokentree_FilterResult.FoundGoDeeper;
			case 17:
				return tokentree_FilterResult.FoundGoDeeper;
			case 19:
				return tokentree_FilterResult.FoundGoDeeper;
			default:
			}
			return tokentree_FilterResult.GoDeeper;
		});
		wrappableTokens.reverse();
		let _g = 0;
		while(_g < wrappableTokens.length) {
			let token = wrappableTokens[_g];
			++_g;
			let _g1 = token.tok;
			switch(_g1._hx_index) {
			case 6:
				switch(_g1.op._hx_index) {
				case 0:
					this.wrapAfter(token,true);
					break;
				case 9:
					if(tokentree_utils_TokenTreeCheckUtils.isTypeParameter(token)) {
						this.wrapTypeParameter(token);
					}
					break;
				case 22:
					this.wrapAfter(token,true);
					break;
				default:
				}
				break;
			case 8:
				let _g2 = _g1.s;
				this.wrapBefore(token,false);
				break;
			case 11:
				break;
			case 13:
				this.wrapAfter(token,true);
				break;
			case 15:
				this.arrayWrapping(token);
				break;
			case 17:
				this.markBrWrapping(token);
				break;
			case 19:
				this.markPWrapping(token);
				break;
			default:
			}
		}
		this.markMethodChaining(this.parsedCode.root);
		this.markMultiVarChaining();
		this.markImplementsExtendsChaining();
		this.markOpBoolChaining();
		this.markOpAddChaining();
		this.markCasePatternChaining();
		this.applyWrappingQueue();
	}
	wrapTypeParameter(token) {
		let close = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt));
		if(token.children == null || token.children.length <= 0) {
			return;
		}
		let items = this.makeWrappableItems(token);
		this.queueWrapping({ start : token, end : null, items : items, rules : this.config.wrapping.typeParameter, useTrailing : true, overrideAdditionalIndent : null},"wrapTypeParameter");
	}
	markBrWrapping(token) {
		switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(token)._hx_index) {
		case 0:
			break;
		case 1:
			this.typedefWrapping(token);
			break;
		case 2:
			this.objectLiteralWrapping(token);
			break;
		case 3:
			this.anonTypeWrapping(token);
			break;
		case 4:
			break;
		}
	}
	typedefWrapping(token) {
		let brClose = this.getCloseToken(token);
		if(this.isNewLineBefore(token)) {
			return;
		}
		if(this.parsedCode.isOriginalSameLine(token,brClose)) {
			this.noWrap(token,brClose);
			return;
		}
	}
	anonTypeWrapping(token) {
		let brClose = this.getCloseToken(token);
		if(token.children == null || token.children.length <= 0) {
			return;
		}
		if(token.index + 1 == brClose.index) {
			this.whitespace(token,"noneAfter");
			this.whitespace(brClose,"noneBefore");
			return;
		}
		let next = this.getNextToken(brClose);
		if(next != null) {
			let _g = next.token.tok;
			switch(_g._hx_index) {
			case 1:
				let _g1 = _g.k;
				this.lineEndAfter(brClose);
				break;
			case 2:
				let _g2 = _g.c;
				if(_g2._hx_index == 3) {
					switch(_g2.s) {
					case "from":case "to":
						this.noLineEndAfter(brClose);
						break;
					default:
						this.lineEndAfter(brClose);
					}
				} else {
					this.lineEndAfter(brClose);
				}
				break;
			case 6:
				if(_g.op._hx_index == 7) {
					this.noLineEndAfter(brClose);
				}
				break;
			case 17:
				switch(this.config.lineEnds.leftCurly) {
				case "after":case "none":
					this.noLineEndAfter(brClose);
					break;
				case "before":case "both":
					break;
				}
				break;
			default:
			}
		}
		if(!this.parsedCode.isOriginalSameLine(token,brClose)) {
			this.wrapChildOneLineEach(token,brClose,0);
			return;
		}
		let maxLength = 0;
		let totalLength = 0;
		let itemCount = 0;
		let _g = 0;
		let _g1 = token.children;
		_hx_loop1: while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			switch(_g2._hx_index) {
			case 8:
				let _g3 = _g2.s;
				this.wrapChildOneLineEach(token,brClose,0);
				return;
			case 18:
				break _hx_loop1;
			default:
			}
			let length = this.calcLength(child);
			totalLength += length;
			if(length > maxLength) {
				maxLength = length;
			}
			++itemCount;
		}
		let lineLength = this.calcLineLength(token);
		let rule = this.determineWrapType(this.config.wrapping.anonType,itemCount,maxLength,totalLength,lineLength);
		switch(rule.type) {
		case "equalNumber":
			break;
		case "fillLine":
			this.wrapFillLine(token,brClose,this.config.wrapping.maxLineLength,rule.additionalIndent);
			break;
		case "fillLineWithLeadingBreak":
			this.wrapFillLine(token,brClose,this.config.wrapping.maxLineLength,rule.additionalIndent);
			break;
		case "keep":
			this.keep(token,brClose,rule.additionalIndent);
			break;
		case "noWrap":
			this.noWrap(token,brClose);
			let prev = this.getPreviousToken(token);
			if(prev == null) {
				return;
			}
			switch(prev.whitespaceAfter._hx_index) {
			case 0:
				break;
			case 1:
				break;
			case 2:
				prev.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
				break;
			}
			break;
		case "onePerLine":
			this.wrapChildOneLineEach(token,brClose,rule.additionalIndent);
			break;
		case "onePerLineAfterFirst":
			this.wrapChildOneLineEach(token,brClose,rule.additionalIndent,true);
			break;
		}
	}
	objectLiteralWrapping(token) {
		let brClose = this.getCloseToken(token);
		if(token.children == null || token.children.length <= 1) {
			return;
		}
		if(token.index + 1 == brClose.index) {
			this.whitespace(token,"noneAfter");
			this.whitespace(brClose,"noneBefore");
			return;
		}
		if(!this.parsedCode.isOriginalSameLine(token,brClose)) {
			this.wrapChildOneLineEach(token,brClose,0);
			return;
		}
		let maxLength = 0;
		let totalLength = 0;
		let itemCount = 0;
		let _g = 0;
		let _g1 = token.children;
		_hx_loop1: while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			switch(_g2._hx_index) {
			case 8:
				let _g3 = _g2.s;
				this.wrapChildOneLineEach(token,brClose,0);
				return;
			case 18:
				break _hx_loop1;
			default:
			}
			let length = this.calcLength(child);
			totalLength += length;
			if(length > maxLength) {
				maxLength = length;
			}
			++itemCount;
		}
		let lineLength = this.calcLineLength(token);
		let rule = this.determineWrapType(this.config.wrapping.objectLiteral,itemCount,maxLength,totalLength,lineLength);
		switch(rule.type) {
		case "equalNumber":
			break;
		case "fillLine":
			this.wrapFillLine(token,brClose,this.config.wrapping.maxLineLength,rule.additionalIndent);
			break;
		case "fillLineWithLeadingBreak":
			this.wrapFillLine(token,brClose,this.config.wrapping.maxLineLength,rule.additionalIndent);
			break;
		case "keep":
			this.keep(token,brClose,rule.additionalIndent);
			break;
		case "noWrap":
			this.noWrap(token,brClose);
			let next = this.getNextToken(brClose);
			if(next != null) {
				switch(next.token.tok._hx_index) {
				case 12:
					this.noLineEndAfter(brClose);
					break;
				case 11:case 14:
					this.whitespace(brClose,"noneAfter");
					break;
				default:
				}
			}
			let prev = this.getPreviousToken(token);
			if(prev != null) {
				let _g = prev.token.tok;
				switch(_g._hx_index) {
				case 1:
					let _g1 = _g.k;
					this.noLineEndBefore(token);
					this.whitespace(token,"before");
					break;
				case 6:
					let _g2 = _g.op;
					this.noLineEndBefore(token);
					break;
				case 14:case 19:
					this.noLineEndBefore(token);
					break;
				default:
				}
			}
			break;
		case "onePerLine":
			this.wrapChildOneLineEach(token,brClose,rule.additionalIndent);
			break;
		case "onePerLineAfterFirst":
			this.wrapChildOneLineEach(token,brClose,rule.additionalIndent,true);
			break;
		}
	}
	markPWrapping(token) {
		let pClose = this.getCloseToken(token);
		switch(tokentree_utils_TokenTreeCheckUtils.getPOpenType(token)._hx_index) {
		case 0:
			this.wrapMetadataCallParameter(token);
			break;
		case 1:
			this.wrapFunctionSignature(token);
			break;
		case 2:
			this.wrapCallParameter(token);
			break;
		case 3:
			break;
		case 4:
			break;
		case 5:
			break;
		case 6:
			break;
		case 7:
			break;
		case 8:
			break;
		case 9:
			break;
		}
	}
	arrayWrapping(token) {
		let bkClose = this.getCloseToken(token);
		if(token.children == null || token.children.length <= 0) {
			return;
		}
		let items = this.makeWrappableItems(token);
		let itemsWithoutMetadata = [];
		let _g = 0;
		while(_g < items.length) {
			let item = items[_g];
			++_g;
			let _g1 = item.first.tok;
			switch(_g1._hx_index) {
			case 1:
				switch(_g1.k._hx_index) {
				case 5:case 7:
					if(this.config.sameLine.comprehensionFor == "keep") {
						return;
					}
					itemsWithoutMetadata.push(item);
					break;
				default:
					itemsWithoutMetadata.push(item);
				}
				break;
			case 22:
				if(item.firstLineLength > 30) {
					this.lineEndBefore(token);
					this.lineEndBefore(item.first);
				}
				break;
			default:
				itemsWithoutMetadata.push(item);
			}
		}
		if(this.config.wrapping.arrayMatrixWrap != "noMatrixWrap") {
			if(this.tryMatrixWrap(token,bkClose,itemsWithoutMetadata)) {
				return;
			}
		}
		this.applyWrappingPlace({ start : token, end : bkClose, items : itemsWithoutMetadata, rules : this.config.wrapping.arrayWrap, useTrailing : true, overrideAdditionalIndent : null});
	}
	tryMatrixWrap(open,close,items) {
		let prev = null;
		let run = 1;
		let lineRun = 0;
		let _g = 0;
		let _g1 = items.length;
		while(_g < _g1) {
			let index = _g++;
			let item = items[index];
			if(prev == null) {
				prev = item;
				continue;
			}
			if(item.multiline) {
				return false;
			}
			if(this.parsedCode.isOriginalSameLine(prev.first,item.first)) {
				++run;
				prev = item;
				continue;
			}
			if(lineRun != 0) {
				if(lineRun != run) {
					return false;
				}
			}
			lineRun = run;
			run = 1;
			prev = item;
		}
		if(lineRun <= 1) {
			return false;
		}
		if(lineRun != run) {
			return false;
		}
		this.lineEndAfter(open);
		if(this.config.wrapping.arrayMatrixWrap == "matrixWrapWithAlign") {
			let _g = [];
			let _g1 = 0;
			let _g2 = lineRun;
			while(_g1 < _g2) {
				let i = _g1++;
				_g.push(0);
			}
			let maxCols = _g;
			let _g3 = 0;
			let _g4 = items.length;
			while(_g3 < _g4) {
				let index = _g3++;
				let item = items[index];
				let col = index % lineRun;
				if(item.firstLineLength > maxCols[col]) {
					maxCols[col] = item.firstLineLength;
				}
			}
			let _g5 = 0;
			let _g6 = items.length;
			while(_g5 < _g6) {
				let index = _g5++;
				let item = items[index];
				let expectedLength = maxCols[index % lineRun];
				if(index == items.length - 1) {
					if(item.last.tok._hx_index == 14) {
						--expectedLength;
					} else {
						expectedLength -= 2;
					}
				}
				if(item.firstLineLength < expectedLength) {
					this.spacesBefore(item.first,expectedLength - item.firstLineLength);
				}
			}
		}
		let index = lineRun - 1;
		while(index < items.length) {
			let item = items[index];
			this.lineEndAfter(item.last);
			index += lineRun;
		}
		return true;
	}
	calcLineLength(token) {
		if(token == null) {
			return 0;
		}
		return super.calcLineLength(token);
	}
	wrapFunctionSignature(token) {
		let pClose = this.getCloseToken(token);
		if(token.children == null || token.children.length <= 0) {
			return;
		}
		let rules = this.config.wrapping.functionSignature;
		let _g = token.parent.tok;
		if(_g._hx_index == 1) {
			if(_g.k._hx_index == 0) {
				rules = this.config.wrapping.anonFunctionSignature;
			}
		}
		let emptyBody = this.hasEmptyFunctionBody(token);
		let items = this.makeWrappableItems(token);
		let addIndent = null;
		if(emptyBody) {
			addIndent = 0;
		}
		this.queueWrapping({ start : token, end : pClose, items : items, rules : rules, useTrailing : true, overrideAdditionalIndent : addIndent},"wrapFunctionSignature");
	}
	wrapCallParameter(token) {
		let pClose = this.getCloseToken(token);
		if(token.children == null || token.children.length <= 0) {
			return;
		}
		let items = this.makeWrappableItems(token);
		this.queueWrapping({ start : token, end : pClose, items : items, rules : this.config.wrapping.callParameter, useTrailing : true, overrideAdditionalIndent : null},"wrapCallParameter");
	}
	wrapMetadataCallParameter(token) {
		let pClose = this.getCloseToken(token);
		if(token.children == null || token.children.length <= 0) {
			return;
		}
		let items = this.makeWrappableItems(token);
		this.queueWrapping({ start : token, end : pClose, items : items, rules : this.config.wrapping.metadataCallParameter, useTrailing : false, overrideAdditionalIndent : null},"wrapMetadataCallParameter");
	}
	markMethodChaining(startToken) {
		let _gthis = this;
		if(startToken == null) {
			return;
		}
		let chainStarts = startToken.filterCallback(function(token,index) {
			if(token.tok._hx_index == 11) {
				let prev = _gthis.getPreviousToken(token);
				_hx_loop1: while(prev != null) {
					let _g = prev.token.tok;
					switch(_g._hx_index) {
					case 7:
						let _g1 = _g.s;
						break;
					case 8:
						let _g2 = _g.s;
						break;
					case 20:
						_gthis.wrapBefore(token,true);
						return tokentree_FilterResult.FoundSkipSubtree;
					default:
						break _hx_loop1;
					}
					prev = _gthis.getPreviousToken(prev.token);
				}
			}
			return tokentree_FilterResult.GoDeeper;
		});
		let _g = 0;
		while(_g < chainStarts.length) {
			let chainStart = chainStarts[_g];
			++_g;
			this.markInternalMethodChaining(chainStart);
			this.markSingleMethodChain(chainStart);
		}
	}
	markInternalMethodChaining(startToken) {
		let _gthis = this;
		startToken.filterCallback(function(token,index) {
			switch(token.tok._hx_index) {
			case 15:case 17:case 19:
				_gthis.markMethodChaining(token);
				break;
			default:
			}
			return tokentree_FilterResult.GoDeeper;
		});
	}
	markSingleMethodChain(chainStart) {
		let _gthis = this;
		let chainedCalls = chainStart.filterCallback(function(token,index) {
			switch(token.tok._hx_index) {
			case 11:
				let prev = _gthis.getPreviousToken(token);
				_hx_loop1: while(prev != null) {
					let _g = prev.token.tok;
					switch(_g._hx_index) {
					case 7:
						let _g1 = _g.s;
						break;
					case 8:
						let _g2 = _g.s;
						break;
					case 20:
						return tokentree_FilterResult.FoundGoDeeper;
					default:
						break _hx_loop1;
					}
					prev = _gthis.getPreviousToken(prev.token);
				}
				return tokentree_FilterResult.GoDeeper;
			case 15:case 17:case 19:
				return tokentree_FilterResult.SkipSubtree;
			default:
			}
			return tokentree_FilterResult.GoDeeper;
		});
		let firstMethodCall = tokentree_TokenTreeAccessHelper.is(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.parent(chainStart))),tokentree_TokenTreeDef.Dot);
		if(firstMethodCall != null) {
			chainedCalls.unshift(firstMethodCall);
			chainStart = firstMethodCall;
		}
		let items = [];
		let chainEnd = tokentree_utils_TokenTreeCheckUtils.getLastToken(chainStart);
		let info = this.getPreviousToken(chainStart);
		let chainOpen = chainStart.parent;
		if(info != null) {
			chainOpen = info.token;
		}
		let _g = 0;
		let _g1 = chainedCalls.length;
		while(_g < _g1) {
			let index = _g++;
			let child = chainedCalls[index];
			let endToken = chainEnd;
			if(index + 1 < chainedCalls.length) {
				let next = chainedCalls[index + 1];
				info = this.getPreviousToken(next);
				if(info != null) {
					endToken = info.token;
				}
			}
			items.push(this.makeWrappableItem(child,endToken));
		}
		chainEnd = null;
		if(chainOpen != null) {
			chainEnd = this.getCloseToken(chainOpen);
		}
		this.queueWrapping({ start : chainOpen, end : chainEnd, items : items, rules : this.config.wrapping.methodChain, useTrailing : false, overrideAdditionalIndent : null},"markSingleMethodChain");
	}
	markOpBoolChaining() {
		let chainStarts = this.parsedCode.root.filterCallback(function(token,index) {
			if(!token.hasChildren()) {
				return tokentree_FilterResult.SkipSubtree;
			}
			let _g = 0;
			let _g1 = token.children;
			while(_g < _g1.length) {
				let child = _g1[_g];
				++_g;
				let _g2 = child.tok;
				if(_g2._hx_index == 6) {
					switch(_g2.op._hx_index) {
					case 14:case 15:
						return tokentree_FilterResult.FoundGoDeeper;
					default:
					}
				}
			}
			return tokentree_FilterResult.GoDeeper;
		});
		let _g = 0;
		while(_g < chainStarts.length) {
			let chainStart = chainStarts[_g];
			++_g;
			this.markSingleOpBoolChain(chainStart);
		}
	}
	markSingleOpBoolChain(itemStart) {
		let items = [];
		let firstItemStart = itemStart;
		let _g = itemStart.tok;
		if(_g._hx_index == 6) {
			let _g1 = _g.op;
			if(itemStart.previousSibling != null) {
				firstItemStart = itemStart.previousSibling;
			}
		}
		let prev = this.getPreviousToken(firstItemStart);
		let chainStart = itemStart;
		if(prev != null) {
			chainStart = prev.token;
		}
		let chainEnd = itemStart.getLastChild();
		if(chainEnd != null) {
			chainEnd = tokentree_utils_TokenTreeCheckUtils.getLastToken(chainEnd);
			switch(chainEnd.tok._hx_index) {
			case 10:case 14:case 20:
				break;
			default:
				let next = this.getNextToken(chainEnd);
				if(next != null) {
					chainEnd = next.token;
				}
			}
		}
		let first = true;
		let _g1 = 0;
		let _g2 = itemStart.children;
		while(_g1 < _g2.length) {
			let child = _g2[_g1];
			++_g1;
			let _g = child.tok;
			if(_g._hx_index == 6) {
				switch(_g.op._hx_index) {
				case 14:case 15:
					if(first) {
						itemStart = firstItemStart;
						first = false;
					}
					items.push(this.makeWrappableItem(itemStart,child));
					let next = this.getNextToken(child);
					if(next == null) {
						return;
					}
					itemStart = next.token;
					break;
				default:
					continue;
				}
			} else {
				continue;
			}
		}
		items.push(this.makeWrappableItem(itemStart,tokentree_utils_TokenTreeCheckUtils.getLastToken(itemStart)));
		this.queueWrapping({ start : chainStart, end : chainEnd, items : items, rules : this.config.wrapping.opBoolChain, useTrailing : false, overrideAdditionalIndent : null},"markSingleOpBoolChain");
	}
	markCasePatternChaining() {
		let chainStarts = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 15) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < chainStarts.length) {
			let chainStart = chainStarts[_g];
			++_g;
			this.markSingleCasePatternChain(chainStart);
		}
	}
	markSingleCasePatternChain(itemContainer) {
		let items = [];
		let chainStart = itemContainer;
		let chainEnd = tokentree_TokenTreeAccessHelper.firstOf(itemContainer,tokentree_TokenTreeDef.DblDot);
		let next = this.getNextToken(chainStart);
		if(next == null) {
			return;
		}
		let itemStart = next.token;
		let _g = 0;
		let _g1 = itemContainer.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			if(child.tok._hx_index == 12) {
				break;
			} else {
				let lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
				items.push(this.makeWrappableItem(child,lastToken));
			}
		}
		this.queueWrapping({ start : chainStart, end : chainEnd, items : items, rules : this.config.wrapping.casePattern, useTrailing : false, overrideAdditionalIndent : null},"markSingleCasePatternChain");
	}
	markOpAddChaining() {
		let chainStarts = this.parsedCode.root.filterCallback(function(token,index) {
			if(!token.hasChildren()) {
				return tokentree_FilterResult.SkipSubtree;
			}
			let _g = 0;
			let _g1 = token.children;
			while(_g < _g1.length) {
				let child = _g1[_g];
				++_g;
				let _g2 = child.tok;
				if(_g2._hx_index == 6) {
					switch(_g2.op._hx_index) {
					case 0:case 3:
						return tokentree_FilterResult.FoundGoDeeper;
					default:
					}
				}
			}
			return tokentree_FilterResult.GoDeeper;
		});
		let _g = 0;
		while(_g < chainStarts.length) {
			let chainStart = chainStarts[_g];
			++_g;
			this.markSingleOpAddChain(chainStart);
		}
	}
	markSingleOpAddChain(itemContainer) {
		let items = [];
		let prev = this.getPreviousToken(this.findOpAddItemStart(itemContainer));
		let chainStart = this.findOpAddItemStart(itemContainer);
		let chainEnd = itemContainer.getLastChild();
		if(chainStart.tok._hx_index == 19) {
			let type = tokentree_utils_TokenTreeCheckUtils.getPOpenType(chainStart);
			switch(type._hx_index) {
			case 0:
				return;
			case 1:
				break;
			case 2:
				break;
			case 3:
				break;
			case 4:
				break;
			case 5:
				break;
			case 6:
				break;
			case 7:
				break;
			case 8:
				break;
			case 9:
				break;
			}
		}
		if(chainEnd != null) {
			chainEnd = tokentree_utils_TokenTreeCheckUtils.getLastToken(chainEnd);
			switch(chainEnd.tok._hx_index) {
			case 10:case 14:
				break;
			default:
				let next = this.getNextToken(chainEnd);
				if(next != null) {
					chainEnd = next.token;
				}
			}
		}
		let next = this.getNextToken(chainStart);
		if(next == null) {
			return;
		}
		let itemStart = next.token;
		let _g = 0;
		let _g1 = itemContainer.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			if(_g2._hx_index == 6) {
				switch(_g2.op._hx_index) {
				case 0:case 3:
					items.push(this.makeWrappableItem(itemStart,child));
					let next = this.getNextToken(child);
					if(next == null) {
						continue;
					}
					itemStart = next.token;
					break;
				default:
					continue;
				}
			} else {
				continue;
			}
		}
		items.push(this.makeWrappableItem(itemStart,tokentree_utils_TokenTreeCheckUtils.getLastToken(itemStart)));
		this.queueWrapping({ start : chainStart, end : null, items : items, rules : this.config.wrapping.opAddSubChain, useTrailing : false, overrideAdditionalIndent : null},"markSingleOpAddChain");
	}
	findOpAddItemStart(itemStart) {
		if(itemStart == null || itemStart.tok == tokentree_TokenTreeDef.Root) {
			return itemStart;
		}
		let parent = itemStart;
		while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) {
			let _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 23:case 28:case 36:
					break;
				default:
					return parent;
				}
				break;
			case 6:
				let _g1 = _g.op;
				switch(_g1._hx_index) {
				case 4:
					return parent;
				case 20:
					let _g2 = _g1.op;
					return parent;
				default:
				}
				break;
			case 15:case 17:case 19:
				return parent;
			default:
			}
			itemStart = parent;
			parent = parent.parent;
		}
		return itemStart;
	}
	makeWrappableItem(start,end) {
		let sameLine = this.isSameLineBetween(start,end,false);
		let firstLineLength = 0;
		let lastLineLength = 0;
		if(sameLine) {
			firstLineLength = this.calcLengthBetween(start,end) + this.calcTokenLength(end);
		} else {
			firstLineLength = this.calcLengthUntilNewline(start,end);
			lastLineLength = this.calcLineLengthBefore(end) + this.calcTokenLength(end);
		}
		return { first : start, last : end, multiline : !sameLine, firstLineLength : firstLineLength, lastLineLength : lastLineLength};
	}
	markImplementsExtendsChaining() {
		let classesAndInterfaces = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 1:case 27:
					return tokentree_FilterResult.FoundSkipSubtree;
				case 26:case 31:case 39:
					return tokentree_FilterResult.SkipSubtree;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < classesAndInterfaces.length) {
			let type = classesAndInterfaces[_g];
			++_g;
			let items = [];
			let impls = type.filterCallback(function(token,index) {
				let _g = token.tok;
				if(_g._hx_index == 1) {
					switch(_g.k._hx_index) {
					case 0:case 2:
						return tokentree_FilterResult.SkipSubtree;
					case 11:case 12:
						return tokentree_FilterResult.FoundSkipSubtree;
					default:
						return tokentree_FilterResult.GoDeeper;
					}
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			});
			let _g1 = 0;
			while(_g1 < impls.length) {
				let impl = impls[_g1];
				++_g1;
				let endToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(impl);
				items.push(this.makeWrappableItem(impl,endToken));
			}
			if(items.length <= 0) {
				continue;
			}
			let chainOpen = items[0].first;
			let prev = this.getPreviousToken(items[0].first);
			if(prev != null) {
				chainOpen = prev.token;
			}
			let chainEnd = items[items.length - 1].last;
			this.queueWrapping({ start : chainOpen, end : chainEnd, items : items, rules : this.config.wrapping.implementsExtends, useTrailing : false, overrideAdditionalIndent : null},"markImplementsExtendsChaining");
		}
	}
	markMultiVarChaining() {
		let allVars = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 2) {
					if(token.hasChildren() && token.children.length > 1) {
						return tokentree_FilterResult.FoundSkipSubtree;
					}
					return tokentree_FilterResult.SkipSubtree;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < allVars.length) {
			let v = allVars[_g];
			++_g;
			let items = [];
			let _g1 = 0;
			let _g2 = v.children;
			while(_g1 < _g2.length) {
				let child = _g2[_g1];
				++_g1;
				let endToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
				items.push(this.makeWrappableItem(child,endToken));
			}
			if(items.length <= 0) {
				continue;
			}
			let chainOpen = v;
			let chainEnd = tokentree_utils_TokenTreeCheckUtils.getLastToken(v);
			this.queueWrapping({ start : chainOpen, end : chainEnd, items : items, rules : this.config.wrapping.multiVar, useTrailing : false, overrideAdditionalIndent : null},"markMultiVarChaining");
		}
	}
}
$hxClasses["formatter.marker.wrapping.MarkWrapping"] = formatter_marker_wrapping_MarkWrapping;
formatter_marker_wrapping_MarkWrapping.__name__ = "formatter.marker.wrapping.MarkWrapping";
formatter_marker_wrapping_MarkWrapping.__super__ = formatter_marker_wrapping_MarkWrappingBase;
Object.assign(formatter_marker_wrapping_MarkWrapping.prototype, {
	__class__: formatter_marker_wrapping_MarkWrapping
});
var haxe_StackItem = $hxEnums["haxe.StackItem"] = { __ename__ : true, __constructs__ : ["CFunction","Module","FilePos","Method","LocalFunction"]
	,CFunction: {_hx_index:0,__enum__:"haxe.StackItem",toString:$estr}
	,Module: ($_=function(m) { return {_hx_index:1,m:m,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["m"],$_)
	,FilePos: ($_=function(s,file,line,column) { return {_hx_index:2,s:s,file:file,line:line,column:column,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["s","file","line","column"],$_)
	,Method: ($_=function(classname,method) { return {_hx_index:3,classname:classname,method:method,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["classname","method"],$_)
	,LocalFunction: ($_=function(v) { return {_hx_index:4,v:v,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["v"],$_)
};
class haxe_CallStack {
	static callStack() {
		return haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.callStack());
	}
	static exceptionStack() {
		let eStack = haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.exceptionStack());
		return haxe_CallStack.subtract(eStack,haxe_CallStack.callStack());
	}
	static toString(stack) {
		let b = new StringBuf();
		let _g = 0;
		let _g1 = stack;
		while(_g < _g1.length) {
			let s = _g1[_g];
			++_g;
			b.b += "\nCalled from ";
			haxe_CallStack.itemToString(b,s);
		}
		return b.b;
	}
	static subtract(this1,stack) {
		let startIndex = -1;
		let i = -1;
		while(++i < this1.length) {
			let _g = 0;
			let _g1 = stack.length;
			while(_g < _g1) {
				let j = _g++;
				if(haxe_CallStack.equalItems(this1[i],stack[j])) {
					if(startIndex < 0) {
						startIndex = i;
					}
					++i;
					if(i >= this1.length) {
						break;
					}
				} else {
					startIndex = -1;
				}
			}
			if(startIndex >= 0) {
				break;
			}
		}
		if(startIndex >= 0) {
			return this1.slice(0,startIndex);
		} else {
			return this1;
		}
	}
	static equalItems(item1,item2) {
		if(item1 == null) {
			if(item2 == null) {
				return true;
			} else {
				return false;
			}
		} else {
			switch(item1._hx_index) {
			case 0:
				if(item2 == null) {
					return false;
				} else if(item2._hx_index == 0) {
					return true;
				} else {
					return false;
				}
				break;
			case 1:
				if(item2 == null) {
					return false;
				} else if(item2._hx_index == 1) {
					let m1 = item1.m;
					let m2 = item2.m;
					return m1 == m2;
				} else {
					return false;
				}
				break;
			case 2:
				if(item2 == null) {
					return false;
				} else if(item2._hx_index == 2) {
					let item11 = item1.s;
					let file1 = item1.file;
					let line1 = item1.line;
					let col1 = item1.column;
					let col2 = item2.column;
					let line2 = item2.line;
					let file2 = item2.file;
					let item21 = item2.s;
					if(file1 == file2 && line1 == line2 && col1 == col2) {
						return haxe_CallStack.equalItems(item11,item21);
					} else {
						return false;
					}
				} else {
					return false;
				}
				break;
			case 3:
				if(item2 == null) {
					return false;
				} else if(item2._hx_index == 3) {
					let class1 = item1.classname;
					let method1 = item1.method;
					let method2 = item2.method;
					let class2 = item2.classname;
					if(class1 == class2) {
						return method1 == method2;
					} else {
						return false;
					}
				} else {
					return false;
				}
				break;
			case 4:
				if(item2 == null) {
					return false;
				} else if(item2._hx_index == 4) {
					let v1 = item1.v;
					let v2 = item2.v;
					return v1 == v2;
				} else {
					return false;
				}
				break;
			}
		}
	}
	static itemToString(b,s) {
		switch(s._hx_index) {
		case 0:
			b.b += "a C function";
			break;
		case 1:
			let m = s.m;
			b.b += "module ";
			b.b += m == null ? "null" : "" + m;
			break;
		case 2:
			let col = s.column;
			let line = s.line;
			let file = s.file;
			let s1 = s.s;
			if(s1 != null) {
				haxe_CallStack.itemToString(b,s1);
				b.b += " (";
			}
			b.b += file == null ? "null" : "" + file;
			b.b += " line ";
			b.b += line == null ? "null" : "" + line;
			if(col != null) {
				b.b += " column ";
				b.b += col == null ? "null" : "" + col;
			}
			if(s1 != null) {
				b.b += ")";
			}
			break;
		case 3:
			let meth = s.method;
			let cname = s.classname;
			b.b += Std.string(cname == null ? "<unknown>" : cname);
			b.b += ".";
			b.b += meth == null ? "null" : "" + meth;
			break;
		case 4:
			let n = s.v;
			b.b += "local function #";
			b.b += n == null ? "null" : "" + n;
			break;
		}
	}
}
class haxe_IMap {
}
$hxClasses["haxe.IMap"] = haxe_IMap;
haxe_IMap.__name__ = "haxe.IMap";
haxe_IMap.__isInterface__ = true;
class haxe_Exception extends Error {
	constructor(message,previous,native) {
		super(message);
		this.message = message;
		this.__previousException = previous;
		this.__nativeException = native != null ? native : this;
	}
	unwrap() {
		return this.__nativeException;
	}
	get_native() {
		return this.__nativeException;
	}
	static caught(value) {
		if(((value) instanceof haxe_Exception)) {
			return value;
		} else if(((value) instanceof Error)) {
			return new haxe_Exception(value.message,null,value);
		} else {
			return new haxe_ValueException(value,null,value);
		}
	}
	static thrown(value) {
		if(((value) instanceof haxe_Exception)) {
			return value.get_native();
		} else if(((value) instanceof Error)) {
			return value;
		} else {
			let e = new haxe_ValueException(value);
			return e;
		}
	}
}
$hxClasses["haxe.Exception"] = haxe_Exception;
haxe_Exception.__name__ = "haxe.Exception";
haxe_Exception.__super__ = Error;
Object.assign(haxe_Exception.prototype, {
	__class__: haxe_Exception
	,__skipStack: null
	,__nativeException: null
	,__previousException: null
});
class haxe_NativeStackTrace {
	static saveStack(e) {
		haxe_NativeStackTrace.lastError = e;
	}
	static callStack() {
		let e = new Error("");
		let stack = haxe_NativeStackTrace.tryHaxeStack(e);
		if(typeof(stack) == "undefined") {
			try {
				throw e;
			} catch( _g ) {
			}
			stack = e.stack;
		}
		return haxe_NativeStackTrace.normalize(stack,2);
	}
	static exceptionStack() {
		return haxe_NativeStackTrace.normalize(haxe_NativeStackTrace.tryHaxeStack(haxe_NativeStackTrace.lastError));
	}
	static toHaxe(s,skip) {
		if(skip == null) {
			skip = 0;
		}
		if(s == null) {
			return [];
		} else if(typeof(s) == "string") {
			let stack = s.split("\n");
			if(stack[0] == "Error") {
				stack.shift();
			}
			let m = [];
			let _g = 0;
			let _g1 = stack.length;
			while(_g < _g1) {
				let i = _g++;
				if(skip > i) {
					continue;
				}
				let line = stack[i];
				let matched = line.match(/^    at ([A-Za-z0-9_. ]+) \(([^)]+):([0-9]+):([0-9]+)\)$/);
				if(matched != null) {
					let path = matched[1].split(".");
					if(path[0] == "$hxClasses") {
						path.shift();
					}
					let meth = path.pop();
					let file = matched[2];
					let line = Std.parseInt(matched[3]);
					let column = Std.parseInt(matched[4]);
					m.push(haxe_StackItem.FilePos(meth == "Anonymous function" ? haxe_StackItem.LocalFunction() : meth == "Global code" ? null : haxe_StackItem.Method(path.join("."),meth),file,line,column));
				} else {
					m.push(haxe_StackItem.Module(StringTools.trim(line)));
				}
			}
			return m;
		} else if(skip > 0 && Array.isArray(s)) {
			return s.slice(skip);
		} else {
			return s;
		}
	}
	static tryHaxeStack(e) {
		if(e == null) {
			return [];
		}
		let oldValue = Error.prepareStackTrace;
		Error.prepareStackTrace = haxe_NativeStackTrace.prepareHxStackTrace;
		let stack = e.stack;
		Error.prepareStackTrace = oldValue;
		return stack;
	}
	static prepareHxStackTrace(e,callsites) {
		let stack = [];
		let _g = 0;
		while(_g < callsites.length) {
			let site = callsites[_g];
			++_g;
			if(haxe_NativeStackTrace.wrapCallSite != null) {
				site = haxe_NativeStackTrace.wrapCallSite(site);
			}
			let method = null;
			let fullName = site.getFunctionName();
			if(fullName != null) {
				let idx = fullName.lastIndexOf(".");
				if(idx >= 0) {
					let className = fullName.substring(0,idx);
					let methodName = fullName.substring(idx + 1);
					method = haxe_StackItem.Method(className,methodName);
				} else {
					method = haxe_StackItem.Method(null,fullName);
				}
			}
			let fileName = site.getFileName();
			let fileAddr = fileName == null ? -1 : fileName.indexOf("file:");
			if(haxe_NativeStackTrace.wrapCallSite != null && fileAddr > 0) {
				fileName = fileName.substring(fileAddr + 6);
			}
			stack.push(haxe_StackItem.FilePos(method,fileName,site.getLineNumber(),site.getColumnNumber()));
		}
		return stack;
	}
	static normalize(stack,skipItems) {
		if(skipItems == null) {
			skipItems = 0;
		}
		if(Array.isArray(stack) && skipItems > 0) {
			return stack.slice(skipItems);
		} else if(typeof(stack) == "string") {
			switch(stack.substring(0,6)) {
			case "Error\n":case "Error:":
				++skipItems;
				break;
			default:
			}
			return haxe_NativeStackTrace.skipLines(stack,skipItems);
		} else {
			return stack;
		}
	}
	static skipLines(stack,skip,pos) {
		if(pos == null) {
			pos = 0;
		}
		if(skip > 0) {
			pos = stack.indexOf("\n",pos);
			if(pos < 0) {
				return "";
			} else {
				return haxe_NativeStackTrace.skipLines(stack,--skip,pos + 1);
			}
		} else {
			return stack.substring(pos);
		}
	}
}
$hxClasses["haxe.NativeStackTrace"] = haxe_NativeStackTrace;
haxe_NativeStackTrace.__name__ = "haxe.NativeStackTrace";
class haxe_ValueException extends haxe_Exception {
	constructor(value,previous,native) {
		super(String(value),previous,native);
		this.value = value;
	}
	unwrap() {
		return this.value;
	}
}
$hxClasses["haxe.ValueException"] = haxe_ValueException;
haxe_ValueException.__name__ = "haxe.ValueException";
haxe_ValueException.__super__ = haxe_Exception;
Object.assign(haxe_ValueException.prototype, {
	__class__: haxe_ValueException
	,value: null
});
class haxe_ds_ArraySort {
	static sort(a,cmp) {
		haxe_ds_ArraySort.rec(a,cmp,0,a.length);
	}
	static rec(a,cmp,from,to) {
		let middle = from + to >> 1;
		if(to - from < 12) {
			if(to <= from) {
				return;
			}
			let _g = from + 1;
			let _g1 = to;
			while(_g < _g1) {
				let i = _g++;
				let j = i;
				while(j > from) {
					if(cmp(a[j],a[j - 1]) < 0) {
						haxe_ds_ArraySort.swap(a,j - 1,j);
					} else {
						break;
					}
					--j;
				}
			}
			return;
		}
		haxe_ds_ArraySort.rec(a,cmp,from,middle);
		haxe_ds_ArraySort.rec(a,cmp,middle,to);
		haxe_ds_ArraySort.doMerge(a,cmp,from,middle,to,middle - from,to - middle);
	}
	static doMerge(a,cmp,from,pivot,to,len1,len2) {
		let first_cut;
		let second_cut;
		let len11;
		let len22;
		if(len1 == 0 || len2 == 0) {
			return;
		}
		if(len1 + len2 == 2) {
			if(cmp(a[pivot],a[from]) < 0) {
				haxe_ds_ArraySort.swap(a,pivot,from);
			}
			return;
		}
		if(len1 > len2) {
			len11 = len1 >> 1;
			first_cut = from + len11;
			second_cut = haxe_ds_ArraySort.lower(a,cmp,pivot,to,first_cut);
			len22 = second_cut - pivot;
		} else {
			len22 = len2 >> 1;
			second_cut = pivot + len22;
			first_cut = haxe_ds_ArraySort.upper(a,cmp,from,pivot,second_cut);
			len11 = first_cut - from;
		}
		haxe_ds_ArraySort.rotate(a,cmp,first_cut,pivot,second_cut);
		let new_mid = first_cut + len22;
		haxe_ds_ArraySort.doMerge(a,cmp,from,first_cut,new_mid,len11,len22);
		haxe_ds_ArraySort.doMerge(a,cmp,new_mid,second_cut,to,len1 - len11,len2 - len22);
	}
	static rotate(a,cmp,from,mid,to) {
		if(from == mid || mid == to) {
			return;
		}
		let n = haxe_ds_ArraySort.gcd(to - from,mid - from);
		while(n-- != 0) {
			let val = a[from + n];
			let shift = mid - from;
			let p1 = from + n;
			let p2 = from + n + shift;
			while(p2 != from + n) {
				a[p1] = a[p2];
				p1 = p2;
				if(to - p2 > shift) {
					p2 += shift;
				} else {
					p2 = from + (shift - (to - p2));
				}
			}
			a[p1] = val;
		}
	}
	static gcd(m,n) {
		while(n != 0) {
			let t = m % n;
			m = n;
			n = t;
		}
		return m;
	}
	static upper(a,cmp,from,to,val) {
		let len = to - from;
		let half;
		let mid;
		while(len > 0) {
			half = len >> 1;
			mid = from + half;
			if(cmp(a[val],a[mid]) < 0) {
				len = half;
			} else {
				from = mid + 1;
				len = len - half - 1;
			}
		}
		return from;
	}
	static lower(a,cmp,from,to,val) {
		let len = to - from;
		let half;
		let mid;
		while(len > 0) {
			half = len >> 1;
			mid = from + half;
			if(cmp(a[mid],a[val]) < 0) {
				from = mid + 1;
				len = len - half - 1;
			} else {
				len = half;
			}
		}
		return from;
	}
	static swap(a,i,j) {
		let tmp = a[i];
		a[i] = a[j];
		a[j] = tmp;
	}
}
$hxClasses["haxe.ds.ArraySort"] = haxe_ds_ArraySort;
haxe_ds_ArraySort.__name__ = "haxe.ds.ArraySort";
class haxe_ds_IntMap {
	constructor() {
		this.h = { };
	}
}
$hxClasses["haxe.ds.IntMap"] = haxe_ds_IntMap;
haxe_ds_IntMap.__name__ = "haxe.ds.IntMap";
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
Object.assign(haxe_ds_IntMap.prototype, {
	__class__: haxe_ds_IntMap
	,h: null
});
class haxe_ds_List {
	constructor() {
		this.length = 0;
	}
	push(item) {
		let x = new haxe_ds__$List_ListNode(item,this.h);
		this.h = x;
		if(this.q == null) {
			this.q = x;
		}
		this.length++;
	}
	remove(v) {
		let prev = null;
		let l = this.h;
		while(l != null) {
			if(l.item == v) {
				if(prev == null) {
					this.h = l.next;
				} else {
					prev.next = l.next;
				}
				if(this.q == l) {
					this.q = prev;
				}
				this.length--;
				return true;
			}
			prev = l;
			l = l.next;
		}
		return false;
	}
}
$hxClasses["haxe.ds.List"] = haxe_ds_List;
haxe_ds_List.__name__ = "haxe.ds.List";
Object.assign(haxe_ds_List.prototype, {
	__class__: haxe_ds_List
	,h: null
	,q: null
	,length: null
});
class haxe_ds__$List_ListNode {
	constructor(item,next) {
		this.item = item;
		this.next = next;
	}
}
$hxClasses["haxe.ds._List.ListNode"] = haxe_ds__$List_ListNode;
haxe_ds__$List_ListNode.__name__ = "haxe.ds._List.ListNode";
Object.assign(haxe_ds__$List_ListNode.prototype, {
	__class__: haxe_ds__$List_ListNode
	,item: null
	,next: null
});
class haxe_ds_StringMap {
	constructor() {
		this.h = Object.create(null);
	}
	static keysIterator(h) {
		let keys = Object.keys(h);
		let len = keys.length;
		let idx = 0;
		return { hasNext : function() {
			return idx < len;
		}, next : function() {
			idx += 1;
			return keys[idx - 1];
		}};
	}
	static kvIterator(h) {
		let keys = Object.keys(h);
		let len = keys.length;
		let idx = 0;
		return { hasNext : function() {
			return idx < len;
		}, next : function() {
			idx += 1;
			let k = keys[idx - 1];
			return { key : k, value : h[k]};
		}};
	}
}
$hxClasses["haxe.ds.StringMap"] = haxe_ds_StringMap;
haxe_ds_StringMap.__name__ = "haxe.ds.StringMap";
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
Object.assign(haxe_ds_StringMap.prototype, {
	__class__: haxe_ds_StringMap
	,h: null
});
class haxe_io_Bytes {
	constructor(data) {
		this.length = data.byteLength;
		this.b = new Uint8Array(data);
		this.b.bufferValue = data;
		data.hxBytes = this;
		data.bytes = this.b;
	}
	sub(pos,len) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		return new haxe_io_Bytes(this.b.buffer.slice(pos + this.b.byteOffset,pos + this.b.byteOffset + len));
	}
	getString(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(encoding == null) {
			encoding = haxe_io_Encoding.UTF8;
		}
		let s = "";
		let b = this.b;
		let i = pos;
		let max = pos + len;
		switch(encoding._hx_index) {
		case 0:
			let debug = pos > 0;
			while(i < max) {
				let c = b[i++];
				if(c < 128) {
					if(c == 0) {
						break;
					}
					s += String.fromCodePoint(c);
				} else if(c < 224) {
					let code = (c & 63) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else if(c < 240) {
					let c2 = b[i++];
					let code = (c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else {
					let c2 = b[i++];
					let c3 = b[i++];
					let u = (c & 15) << 18 | (c2 & 127) << 12 | (c3 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(u);
				}
			}
			break;
		case 1:
			while(i < max) {
				let c = b[i++] | b[i++] << 8;
				s += String.fromCodePoint(c);
			}
			break;
		}
		return s;
	}
	toString() {
		return this.getString(0,this.length);
	}
	static ofString(s,encoding) {
		if(encoding == haxe_io_Encoding.RawNative) {
			let buf = new Uint8Array(s.length << 1);
			let _g = 0;
			let _g1 = s.length;
			while(_g < _g1) {
				let i = _g++;
				let c = s.charCodeAt(i);
				buf[i << 1] = c & 255;
				buf[i << 1 | 1] = c >> 8;
			}
			return new haxe_io_Bytes(buf.buffer);
		}
		let a = [];
		let i = 0;
		while(i < s.length) {
			let c = s.charCodeAt(i++);
			if(55296 <= c && c <= 56319) {
				c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
			}
			if(c <= 127) {
				a.push(c);
			} else if(c <= 2047) {
				a.push(192 | c >> 6);
				a.push(128 | c & 63);
			} else if(c <= 65535) {
				a.push(224 | c >> 12);
				a.push(128 | c >> 6 & 63);
				a.push(128 | c & 63);
			} else {
				a.push(240 | c >> 18);
				a.push(128 | c >> 12 & 63);
				a.push(128 | c >> 6 & 63);
				a.push(128 | c & 63);
			}
		}
		return new haxe_io_Bytes(new Uint8Array(a).buffer);
	}
}
$hxClasses["haxe.io.Bytes"] = haxe_io_Bytes;
haxe_io_Bytes.__name__ = "haxe.io.Bytes";
Object.assign(haxe_io_Bytes.prototype, {
	__class__: haxe_io_Bytes
	,length: null
	,b: null
});
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__ : true, __constructs__ : ["UTF8","RawNative"]
	,UTF8: {_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
class haxe_io_Eof {
	constructor() {
	}
	toString() {
		return "Eof";
	}
}
$hxClasses["haxe.io.Eof"] = haxe_io_Eof;
haxe_io_Eof.__name__ = "haxe.io.Eof";
Object.assign(haxe_io_Eof.prototype, {
	__class__: haxe_io_Eof
});
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__ : true, __constructs__ : ["Blocked","Overflow","OutsideBounds","Custom"]
	,Blocked: {_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_.__params__ = ["e"],$_)
};
class haxe_iterators_ArrayIterator {
	constructor(array) {
		this.current = 0;
		this.array = array;
	}
	hasNext() {
		return this.current < this.array.length;
	}
	next() {
		return this.array[this.current++];
	}
}
$hxClasses["haxe.iterators.ArrayIterator"] = haxe_iterators_ArrayIterator;
haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator";
Object.assign(haxe_iterators_ArrayIterator.prototype, {
	__class__: haxe_iterators_ArrayIterator
	,array: null
	,current: null
});
var haxe_macro_StringLiteralKind = $hxEnums["haxe.macro.StringLiteralKind"] = { __ename__ : true, __constructs__ : ["DoubleQuotes","SingleQuotes"]
	,DoubleQuotes: {_hx_index:0,__enum__:"haxe.macro.StringLiteralKind",toString:$estr}
	,SingleQuotes: {_hx_index:1,__enum__:"haxe.macro.StringLiteralKind",toString:$estr}
};
var haxe_macro_Constant = $hxEnums["haxe.macro.Constant"] = { __ename__ : true, __constructs__ : ["CInt","CFloat","CString","CIdent","CRegexp"]
	,CInt: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"haxe.macro.Constant",toString:$estr}; },$_.__params__ = ["v"],$_)
	,CFloat: ($_=function(f) { return {_hx_index:1,f:f,__enum__:"haxe.macro.Constant",toString:$estr}; },$_.__params__ = ["f"],$_)
	,CString: ($_=function(s,kind) { return {_hx_index:2,s:s,kind:kind,__enum__:"haxe.macro.Constant",toString:$estr}; },$_.__params__ = ["s","kind"],$_)
	,CIdent: ($_=function(s) { return {_hx_index:3,s:s,__enum__:"haxe.macro.Constant",toString:$estr}; },$_.__params__ = ["s"],$_)
	,CRegexp: ($_=function(r,opt) { return {_hx_index:4,r:r,opt:opt,__enum__:"haxe.macro.Constant",toString:$estr}; },$_.__params__ = ["r","opt"],$_)
};
var haxe_macro_Binop = $hxEnums["haxe.macro.Binop"] = { __ename__ : true, __constructs__ : ["OpAdd","OpMult","OpDiv","OpSub","OpAssign","OpEq","OpNotEq","OpGt","OpGte","OpLt","OpLte","OpAnd","OpOr","OpXor","OpBoolAnd","OpBoolOr","OpShl","OpShr","OpUShr","OpMod","OpAssignOp","OpInterval","OpArrow","OpIn"]
	,OpAdd: {_hx_index:0,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpMult: {_hx_index:1,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpDiv: {_hx_index:2,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpSub: {_hx_index:3,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAssign: {_hx_index:4,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpEq: {_hx_index:5,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpNotEq: {_hx_index:6,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpGt: {_hx_index:7,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpGte: {_hx_index:8,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpLt: {_hx_index:9,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpLte: {_hx_index:10,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAnd: {_hx_index:11,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpOr: {_hx_index:12,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpXor: {_hx_index:13,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpBoolAnd: {_hx_index:14,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpBoolOr: {_hx_index:15,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpShl: {_hx_index:16,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpShr: {_hx_index:17,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpUShr: {_hx_index:18,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpMod: {_hx_index:19,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAssignOp: ($_=function(op) { return {_hx_index:20,op:op,__enum__:"haxe.macro.Binop",toString:$estr}; },$_.__params__ = ["op"],$_)
	,OpInterval: {_hx_index:21,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpArrow: {_hx_index:22,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpIn: {_hx_index:23,__enum__:"haxe.macro.Binop",toString:$estr}
};
var haxe_macro_Unop = $hxEnums["haxe.macro.Unop"] = { __ename__ : true, __constructs__ : ["OpIncrement","OpDecrement","OpNot","OpNeg","OpNegBits"]
	,OpIncrement: {_hx_index:0,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpDecrement: {_hx_index:1,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNot: {_hx_index:2,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNeg: {_hx_index:3,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNegBits: {_hx_index:4,__enum__:"haxe.macro.Unop",toString:$estr}
};
class haxe_macro_Printer {
	constructor(tabString) {
		if(tabString == null) {
			tabString = "\t";
		}
		this.tabs = "";
		this.tabString = tabString;
	}
	printUnop(op) {
		switch(op._hx_index) {
		case 0:
			return "++";
		case 1:
			return "--";
		case 2:
			return "!";
		case 3:
			return "-";
		case 4:
			return "~";
		}
	}
	printBinop(op) {
		switch(op._hx_index) {
		case 0:
			return "+";
		case 1:
			return "*";
		case 2:
			return "/";
		case 3:
			return "-";
		case 4:
			return "=";
		case 5:
			return "==";
		case 6:
			return "!=";
		case 7:
			return ">";
		case 8:
			return ">=";
		case 9:
			return "<";
		case 10:
			return "<=";
		case 11:
			return "&";
		case 12:
			return "|";
		case 13:
			return "^";
		case 14:
			return "&&";
		case 15:
			return "||";
		case 16:
			return "<<";
		case 17:
			return ">>";
		case 18:
			return ">>>";
		case 19:
			return "%";
		case 20:
			let op1 = op.op;
			return this.printBinop(op1) + "=";
		case 21:
			return "...";
		case 22:
			return "=>";
		case 23:
			return "in";
		}
	}
}
$hxClasses["haxe.macro.Printer"] = haxe_macro_Printer;
haxe_macro_Printer.__name__ = "haxe.macro.Printer";
Object.assign(haxe_macro_Printer.prototype, {
	__class__: haxe_macro_Printer
	,tabs: null
	,tabString: null
});
class haxe_rtti_Meta {
	static getType(t) {
		let meta = haxe_rtti_Meta.getMeta(t);
		if(meta == null || meta.obj == null) {
			return { };
		} else {
			return meta.obj;
		}
	}
	static getMeta(t) {
		return t.__meta__;
	}
	static getFields(t) {
		let meta = haxe_rtti_Meta.getMeta(t);
		if(meta == null || meta.fields == null) {
			return { };
		} else {
			return meta.fields;
		}
	}
}
$hxClasses["haxe.rtti.Meta"] = haxe_rtti_Meta;
haxe_rtti_Meta.__name__ = "haxe.rtti.Meta";
var haxeparser_Keyword = $hxEnums["haxeparser.Keyword"] = { __ename__ : true, __constructs__ : ["KwdFunction","KwdClass","KwdVar","KwdIf","KwdElse","KwdWhile","KwdDo","KwdFor","KwdBreak","KwdContinue","KwdReturn","KwdExtends","KwdImplements","KwdImport","KwdSwitch","KwdCase","KwdDefault","KwdStatic","KwdPublic","KwdPrivate","KwdTry","KwdCatch","KwdNew","KwdThis","KwdThrow","KwdExtern","KwdEnum","KwdInterface","KwdUntyped","KwdCast","KwdOverride","KwdTypedef","KwdDynamic","KwdPackage","KwdInline","KwdUsing","KwdNull","KwdTrue","KwdFalse","KwdAbstract","KwdMacro","KwdFinal"]
	,KwdFunction: {_hx_index:0,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdClass: {_hx_index:1,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdVar: {_hx_index:2,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdIf: {_hx_index:3,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdElse: {_hx_index:4,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdWhile: {_hx_index:5,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdDo: {_hx_index:6,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdFor: {_hx_index:7,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdBreak: {_hx_index:8,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdContinue: {_hx_index:9,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdReturn: {_hx_index:10,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdExtends: {_hx_index:11,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdImplements: {_hx_index:12,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdImport: {_hx_index:13,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdSwitch: {_hx_index:14,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdCase: {_hx_index:15,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdDefault: {_hx_index:16,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdStatic: {_hx_index:17,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdPublic: {_hx_index:18,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdPrivate: {_hx_index:19,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdTry: {_hx_index:20,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdCatch: {_hx_index:21,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdNew: {_hx_index:22,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdThis: {_hx_index:23,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdThrow: {_hx_index:24,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdExtern: {_hx_index:25,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdEnum: {_hx_index:26,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdInterface: {_hx_index:27,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdUntyped: {_hx_index:28,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdCast: {_hx_index:29,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdOverride: {_hx_index:30,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdTypedef: {_hx_index:31,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdDynamic: {_hx_index:32,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdPackage: {_hx_index:33,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdInline: {_hx_index:34,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdUsing: {_hx_index:35,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdNull: {_hx_index:36,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdTrue: {_hx_index:37,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdFalse: {_hx_index:38,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdAbstract: {_hx_index:39,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdMacro: {_hx_index:40,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdFinal: {_hx_index:41,__enum__:"haxeparser.Keyword",toString:$estr}
};
var haxeparser_TokenDef = $hxEnums["haxeparser.TokenDef"] = { __ename__ : true, __constructs__ : ["Kwd","Const","Sharp","Dollar","Unop","Binop","Comment","CommentLine","IntInterval","Semicolon","Dot","DblDot","Arrow","Comma","BkOpen","BkClose","BrOpen","BrClose","POpen","PClose","Question","At","Eof"]
	,Kwd: ($_=function(k) { return {_hx_index:0,k:k,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["k"],$_)
	,Const: ($_=function(c) { return {_hx_index:1,c:c,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["c"],$_)
	,Sharp: ($_=function(s) { return {_hx_index:2,s:s,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,Dollar: ($_=function(s) { return {_hx_index:3,s:s,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,Unop: ($_=function(op) { return {_hx_index:4,op:op,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["op"],$_)
	,Binop: ($_=function(op) { return {_hx_index:5,op:op,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["op"],$_)
	,Comment: ($_=function(s) { return {_hx_index:6,s:s,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,CommentLine: ($_=function(s) { return {_hx_index:7,s:s,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,IntInterval: ($_=function(s) { return {_hx_index:8,s:s,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,Semicolon: {_hx_index:9,__enum__:"haxeparser.TokenDef",toString:$estr}
	,Dot: {_hx_index:10,__enum__:"haxeparser.TokenDef",toString:$estr}
	,DblDot: {_hx_index:11,__enum__:"haxeparser.TokenDef",toString:$estr}
	,Arrow: {_hx_index:12,__enum__:"haxeparser.TokenDef",toString:$estr}
	,Comma: {_hx_index:13,__enum__:"haxeparser.TokenDef",toString:$estr}
	,BkOpen: {_hx_index:14,__enum__:"haxeparser.TokenDef",toString:$estr}
	,BkClose: {_hx_index:15,__enum__:"haxeparser.TokenDef",toString:$estr}
	,BrOpen: {_hx_index:16,__enum__:"haxeparser.TokenDef",toString:$estr}
	,BrClose: {_hx_index:17,__enum__:"haxeparser.TokenDef",toString:$estr}
	,POpen: {_hx_index:18,__enum__:"haxeparser.TokenDef",toString:$estr}
	,PClose: {_hx_index:19,__enum__:"haxeparser.TokenDef",toString:$estr}
	,Question: {_hx_index:20,__enum__:"haxeparser.TokenDef",toString:$estr}
	,At: {_hx_index:21,__enum__:"haxeparser.TokenDef",toString:$estr}
	,Eof: {_hx_index:22,__enum__:"haxeparser.TokenDef",toString:$estr}
};
class haxeparser_TokenDefPrinter {
	static toString(def) {
		switch(def._hx_index) {
		case 0:
			let k = def.k;
			return HxOverrides.substr($hxEnums[k.__enum__].__constructs__[k._hx_index],3,null).toLowerCase();
		case 1:
			let _g = def.c;
			switch(_g._hx_index) {
			case 0:
				let s = _g.v;
				return s;
			case 1:
				let s1 = _g.f;
				return s1;
			case 2:
				let _g1 = _g.kind;
				let s2 = _g.s;
				return "\"" + s2 + "\"";
			case 3:
				let s3 = _g.s;
				return s3;
			case 4:
				let opt = _g.opt;
				let r = _g.r;
				return "~/" + r + "/" + opt;
			}
			break;
		case 2:
			let s4 = def.s;
			return "#" + s4;
		case 3:
			let s5 = def.s;
			return "$" + s5;
		case 4:
			let op = def.op;
			return new haxe_macro_Printer("").printUnop(op);
		case 5:
			let op1 = def.op;
			return new haxe_macro_Printer("").printBinop(op1);
		case 6:
			let s6 = def.s;
			return "/*" + s6 + "*/";
		case 7:
			let s7 = def.s;
			return "//" + s7;
		case 8:
			let s8 = def.s;
			return "" + s8 + "...";
		case 9:
			return ";";
		case 10:
			return ".";
		case 11:
			return ":";
		case 12:
			return "->";
		case 13:
			return ",";
		case 14:
			return "[";
		case 15:
			return "]";
		case 16:
			return "{";
		case 17:
			return "}";
		case 18:
			return "(";
		case 19:
			return ")";
		case 20:
			return "?";
		case 21:
			return "@";
		case 22:
			return "<eof>";
		}
	}
}
$hxClasses["haxeparser.TokenDefPrinter"] = haxeparser_TokenDefPrinter;
haxeparser_TokenDefPrinter.__name__ = "haxeparser.TokenDefPrinter";
class haxeparser_Token {
	constructor(tok,pos) {
		this.tok = tok;
		this.pos = pos;
	}
	toString() {
		return haxeparser_TokenDefPrinter.toString(this.tok);
	}
}
$hxClasses["haxeparser.Token"] = haxeparser_Token;
haxeparser_Token.__name__ = "haxeparser.Token";
Object.assign(haxeparser_Token.prototype, {
	__class__: haxeparser_Token
	,tok: null
	,pos: null
});
var haxeparser_LexerErrorMsg = $hxEnums["haxeparser.LexerErrorMsg"] = { __ename__ : true, __constructs__ : ["UnterminatedString","UnterminatedRegExp","UnclosedComment","UnterminatedEscapeSequence","InvalidEscapeSequence","UnknownEscapeSequence","UnclosedCode"]
	,UnterminatedString: {_hx_index:0,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}
	,UnterminatedRegExp: {_hx_index:1,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}
	,UnclosedComment: {_hx_index:2,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}
	,UnterminatedEscapeSequence: {_hx_index:3,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}
	,InvalidEscapeSequence: ($_=function(c) { return {_hx_index:4,c:c,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}; },$_.__params__ = ["c"],$_)
	,UnknownEscapeSequence: ($_=function(c) { return {_hx_index:5,c:c,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}; },$_.__params__ = ["c"],$_)
	,UnclosedCode: {_hx_index:6,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}
};
class haxeparser_LexerError {
	constructor(msg,pos) {
		this.msg = msg;
		this.pos = pos;
	}
}
$hxClasses["haxeparser.LexerError"] = haxeparser_LexerError;
haxeparser_LexerError.__name__ = "haxeparser.LexerError";
Object.assign(haxeparser_LexerError.prototype, {
	__class__: haxeparser_LexerError
	,msg: null
	,pos: null
});
class hxparse_Lexer {
	constructor(input,sourceName) {
		if(sourceName == null) {
			sourceName = "<null>";
		}
		this.current = "";
		this.input = input;
		this.source = sourceName;
		this.pos = 0;
	}
	token(ruleset) {
		if(this.pos == this.input.length) {
			if(ruleset.eofFunction != null) {
				return ruleset.eofFunction(this);
			} else {
				throw haxe_Exception.thrown(new haxe_io_Eof());
			}
		}
		let state = ruleset.state;
		let lastMatch = null;
		let lastMatchPos = this.pos;
		let start = this.pos;
		while(true) {
			if(state.finalId > -1) {
				lastMatch = state;
				lastMatchPos = this.pos;
			}
			if(this.pos == this.input.length) {
				break;
			}
			let i = this.input.b[this.pos];
			++this.pos;
			state = state.trans[i];
			if(state == null) {
				break;
			}
		}
		this.pos = lastMatchPos;
		this.current = this.input.getString(start,this.pos - start);
		if(lastMatch == null || lastMatch.finalId == -1) {
			let code = this.input.b[this.pos];
			throw haxe_Exception.thrown(new hxparse_UnexpectedChar(String.fromCodePoint(code),new hxparse_Position(this.source,this.pos - this.current.length,this.pos)));
		}
		return ruleset.functions[lastMatch.finalId](this);
	}
	static buildRuleset(rules,name) {
		if(name == null) {
			name = "";
		}
		let cases = [];
		let functions = [];
		let eofFunction = null;
		let _g = 0;
		while(_g < rules.length) {
			let rule = rules[_g];
			++_g;
			if(rule.rule == "") {
				eofFunction = rule.func;
			} else {
				cases.push(hxparse_LexEngine.parse(rule.rule));
				functions.push(rule.func);
			}
		}
		return new hxparse_Ruleset(new hxparse_LexEngine(cases).firstState(),functions,eofFunction,name);
	}
}
$hxClasses["hxparse.Lexer"] = hxparse_Lexer;
hxparse_Lexer.__name__ = "hxparse.Lexer";
Object.assign(hxparse_Lexer.prototype, {
	__class__: hxparse_Lexer
	,current: null
	,input: null
	,source: null
	,pos: null
});
class hxparse_RuleBuilder {
}
$hxClasses["hxparse.RuleBuilder"] = hxparse_RuleBuilder;
hxparse_RuleBuilder.__name__ = "hxparse.RuleBuilder";
hxparse_RuleBuilder.__isInterface__ = true;
class hxparse__$LexEngine_CharRange {
	constructor(min,max) {
		this.min = min;
		this.max = max;
	}
}
$hxClasses["hxparse._LexEngine.CharRange"] = hxparse__$LexEngine_CharRange;
hxparse__$LexEngine_CharRange.__name__ = "hxparse._LexEngine.CharRange";
Object.assign(hxparse__$LexEngine_CharRange.prototype, {
	__class__: hxparse__$LexEngine_CharRange
	,min: null
	,max: null
});
class hxparse_LexEngine {
	constructor(patterns) {
		this.nodes = [];
		this.finals = [];
		this.states = [];
		this.hstates = new haxe_ds_StringMap();
		this.uid = 0;
		let pid = 0;
		let _g = 0;
		while(_g < patterns.length) {
			let p = patterns[_g];
			++_g;
			let id = pid++;
			let f = new hxparse__$LexEngine_Node(this.uid++,id);
			let n = this.initNode(p,f,id);
			this.nodes.push(n);
			this.finals.push(f);
		}
		this.makeState(this.addNodes([],this.nodes));
	}
	firstState() {
		return this.states[0];
	}
	makeState(nodes) {
		let buf_b = "";
		let _gthis = this;
		let _g = 0;
		while(_g < nodes.length) {
			let n = nodes[_g];
			++_g;
			buf_b += Std.string(n.id);
			buf_b += String.fromCodePoint(45);
		}
		let key = buf_b;
		let s = this.hstates.h[key];
		if(s != null) {
			return s;
		}
		s = new hxparse_State();
		this.states.push(s);
		this.hstates.h[key] = s;
		let trans = this.getTransitions(nodes);
		let _g1 = 0;
		while(_g1 < trans.length) {
			let t = trans[_g1];
			++_g1;
			let target = this.makeState(t.n);
			let _g = 0;
			let _g2 = t.chars;
			while(_g < _g2.length) {
				let chr = _g2[_g];
				++_g;
				let _g1 = chr.min;
				let _g3 = chr.max + 1;
				while(_g1 < _g3) {
					let i = _g1++;
					s.trans[i] = target;
				}
			}
		}
		let setFinal = function() {
			let _g = 0;
			let _g1 = _gthis.finals;
			while(_g < _g1.length) {
				let f = _g1[_g];
				++_g;
				let _g2 = 0;
				while(_g2 < nodes.length) {
					let n = nodes[_g2];
					++_g2;
					if(n == f) {
						s.finalId = n.pid;
						return;
					}
				}
			}
		};
		if(s.finalId == -1) {
			setFinal();
		}
		return s;
	}
	getTransitions(nodes) {
		let tl = [];
		let _g = 0;
		while(_g < nodes.length) {
			let n = nodes[_g];
			++_g;
			let _g1 = 0;
			let _g2 = n.trans;
			while(_g1 < _g2.length) {
				let t = _g2[_g1];
				++_g1;
				tl.push(t);
			}
		}
		tl.sort(function(t1,t2) {
			return t1.n.id - t2.n.id;
		});
		let t0 = tl[0];
		let _g1 = 1;
		let _g2 = tl.length;
		while(_g1 < _g2) {
			let i = _g1++;
			let t1 = tl[i];
			if(t0.n == t1.n) {
				tl[i - 1] = null;
				t1 = { chars : hxparse_LexEngine.cunion(t0.chars,t1.chars), n : t1.n};
				tl[i] = t1;
			}
			t0 = t1;
		}
		while(HxOverrides.remove(tl,null)) {
		}
		let allChars = hxparse_LexEngine.EMPTY;
		let allStates = new haxe_ds_List();
		let _g3 = 0;
		while(_g3 < tl.length) {
			let t = tl[_g3];
			++_g3;
			let states = new haxe_ds_List();
			states.push({ chars : hxparse_LexEngine.cdiff(t.chars,allChars), n : [t.n]});
			let _g3_head = allStates.h;
			while(_g3_head != null) {
				let val = _g3_head.item;
				_g3_head = _g3_head.next;
				let s = val;
				let nodes = s.n.slice();
				nodes.push(t.n);
				states.push({ chars : hxparse_LexEngine.cinter(s.chars,t.chars), n : nodes});
				states.push({ chars : hxparse_LexEngine.cdiff(s.chars,t.chars), n : s.n});
			}
			let _g4_head = states.h;
			while(_g4_head != null) {
				let val = _g4_head.item;
				_g4_head = _g4_head.next;
				let s = val;
				if(s.chars.length == 0) {
					states.remove(s);
				}
			}
			allChars = hxparse_LexEngine.cunion(allChars,t.chars);
			allStates = states;
		}
		let states = [];
		let _g4_head = allStates.h;
		while(_g4_head != null) {
			let val = _g4_head.item;
			_g4_head = _g4_head.next;
			let s = val;
			states.push({ chars : s.chars, n : this.addNodes([],s.n)});
		}
		states.sort(function(s1,s2) {
			let a = s1.chars.length;
			let b = s2.chars.length;
			let _g = 0;
			let _g1 = a < b ? a : b;
			while(_g < _g1) {
				let i = _g++;
				let a = s1.chars[i];
				let b = s2.chars[i];
				if(a.min != b.min) {
					return b.min - a.min;
				}
				if(a.max != b.max) {
					return b.max - a.max;
				}
			}
			if(a < b) {
				return b - a;
			}
			return 0;
		});
		return states;
	}
	addNode(nodes,n) {
		let _g = 0;
		while(_g < nodes.length) {
			let n2 = nodes[_g];
			++_g;
			if(n == n2) {
				return;
			}
		}
		nodes.push(n);
		this.addNodes(nodes,n.epsilon);
	}
	addNodes(nodes,add) {
		let _g = 0;
		while(_g < add.length) {
			let n = add[_g];
			++_g;
			this.addNode(nodes,n);
		}
		return nodes;
	}
	initNode(p,finalId,pid) {
		switch(p._hx_index) {
		case 0:
			return finalId;
		case 1:
			let c = p.c;
			let n = new hxparse__$LexEngine_Node(this.uid++,pid);
			n.trans.push({ chars : c, n : finalId});
			return n;
		case 2:
			let p1 = p.p;
			let n1 = new hxparse__$LexEngine_Node(this.uid++,pid);
			let an = this.initNode(p1,n1,pid);
			n1.epsilon.push(an);
			n1.epsilon.push(finalId);
			return n1;
		case 3:
			let p2 = p.p;
			let n2 = new hxparse__$LexEngine_Node(this.uid++,pid);
			let an1 = this.initNode(p2,n2,pid);
			n2.epsilon.push(an1);
			n2.epsilon.push(finalId);
			return an1;
		case 4:
			let b = p.p2;
			let a = p.p1;
			return this.initNode(a,this.initNode(b,finalId,pid),pid);
		case 5:
			let b1 = p.p2;
			let a1 = p.p1;
			let n3 = new hxparse__$LexEngine_Node(this.uid++,pid);
			n3.epsilon.push(this.initNode(a1,finalId,pid));
			n3.epsilon.push(this.initNode(b1,finalId,pid));
			return n3;
		case 6:
			let p3 = p.p;
			return this.initNode(p3,finalId,pid);
		}
	}
	static parse(pattern) {
		let this1 = haxe_io_Bytes.ofString(pattern);
		let p = hxparse_LexEngine.parseInner(this1);
		if(p == null) {
			throw haxe_Exception.thrown("Invalid pattern '" + pattern + "'");
		}
		return p.pattern;
	}
	static next(a,b) {
		if(a == hxparse__$LexEngine_Pattern.Empty) {
			return b;
		} else {
			return hxparse__$LexEngine_Pattern.Next(a,b);
		}
	}
	static plus(r) {
		if(r._hx_index == 4) {
			let r2 = r.p2;
			let r1 = r.p1;
			return hxparse__$LexEngine_Pattern.Next(r1,hxparse_LexEngine.plus(r2));
		} else {
			return hxparse__$LexEngine_Pattern.Plus(r);
		}
	}
	static star(r) {
		if(r._hx_index == 4) {
			let r2 = r.p2;
			let r1 = r.p1;
			return hxparse__$LexEngine_Pattern.Next(r1,hxparse_LexEngine.star(r2));
		} else {
			return hxparse__$LexEngine_Pattern.Star(r);
		}
	}
	static opt(r) {
		if(r._hx_index == 4) {
			let r2 = r.p2;
			let r1 = r.p1;
			return hxparse__$LexEngine_Pattern.Next(r1,hxparse_LexEngine.opt(r2));
		} else {
			return hxparse__$LexEngine_Pattern.Choice(r,hxparse__$LexEngine_Pattern.Empty);
		}
	}
	static cinter(c1,c2) {
		return hxparse_LexEngine.ccomplement(hxparse_LexEngine.cunion(hxparse_LexEngine.ccomplement(c1),hxparse_LexEngine.ccomplement(c2)));
	}
	static cdiff(c1,c2) {
		return hxparse_LexEngine.ccomplement(hxparse_LexEngine.cunion(hxparse_LexEngine.ccomplement(c1),c2));
	}
	static ccomplement(c) {
		let first = c[0];
		let start = first != null && first.min == -1 ? c.shift().max + 1 : -1;
		let out = [];
		let _g = 0;
		while(_g < c.length) {
			let k = c[_g];
			++_g;
			out.push(new hxparse__$LexEngine_CharRange(start,k.min - 1));
			start = k.max + 1;
		}
		if(start <= 255) {
			out.push(new hxparse__$LexEngine_CharRange(start,255));
		}
		return out;
	}
	static cunion(ca,cb) {
		let i = 0;
		let j = 0;
		let out = [];
		let a = ca[i++];
		let b = cb[j++];
		while(true) {
			if(a == null) {
				out.push(b);
				while(j < cb.length) out.push(cb[j++]);
				break;
			}
			if(b == null) {
				out.push(a);
				while(i < ca.length) out.push(ca[i++]);
				break;
			}
			if(a.min <= b.min) {
				if(a.max + 1 < b.min) {
					out.push(a);
					a = ca[i++];
				} else if(a.max < b.max) {
					b = new hxparse__$LexEngine_CharRange(a.min,b.max);
					a = ca[i++];
				} else {
					b = cb[j++];
				}
			} else {
				let tmp = ca;
				ca = cb;
				cb = tmp;
				let tmp1 = j;
				j = i;
				i = tmp1;
				let tmp2 = a;
				a = b;
				b = tmp2;
			}
		}
		return out;
	}
	static parseInner(pattern,i,pDepth) {
		if(pDepth == null) {
			pDepth = 0;
		}
		if(i == null) {
			i = 0;
		}
		let readChar = function() {
			i += 1;
			let c = pattern.b[i - 1];
			if(c != c) {
				c = 92;
			} else if(c == 120) {
				c = Std.parseInt("0x" + pattern.getString(i,2));
				i += 2;
			} else if(c >= 48 && c <= 57) {
				let v = c - 48;
				while(true) {
					let cNext = pattern.b[i];
					if(cNext >= 48 && cNext <= 57) {
						v = v * 10 + (cNext - 48);
						i += 1;
					} else {
						break;
					}
				}
				c = v;
			}
			return c;
		};
		let r = hxparse__$LexEngine_Pattern.Empty;
		let l = pattern.length;
		while(i < l) {
			i += 1;
			let c = pattern.b[i - 1];
			if(c > 255) {
				throw haxe_Exception.thrown(c);
			}
			switch(c) {
			case 40:
				let r2 = hxparse_LexEngine.parseInner(pattern,i,pDepth + 1);
				i = r2.pos;
				r = hxparse_LexEngine.next(r,r2.pattern);
				break;
			case 41:
				if(r == hxparse__$LexEngine_Pattern.Empty) {
					throw haxe_Exception.thrown("Empty group");
				}
				return { pattern : hxparse__$LexEngine_Pattern.Group(r), pos : i};
			case 42:
				if(r != hxparse__$LexEngine_Pattern.Empty) {
					r = hxparse_LexEngine.star(r);
				} else {
					r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
				}
				break;
			case 43:
				if(r != hxparse__$LexEngine_Pattern.Empty) {
					r = hxparse_LexEngine.plus(r);
				} else {
					r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
				}
				break;
			case 46:
				r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match(hxparse_LexEngine.ALL_CHARS));
				break;
			case 63:
				if(r != hxparse__$LexEngine_Pattern.Empty) {
					r = hxparse_LexEngine.opt(r);
				} else {
					r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
				}
				break;
			case 91:
				if(pattern.length > 1) {
					let range = 0;
					let acc = [];
					let not = pattern.b[i] == 94;
					if(not) {
						i += 1;
					}
					while(true) {
						i += 1;
						let c = pattern.b[i - 1];
						if(c == 93) {
							if(range != 0) {
								return null;
							}
							break;
						} else if(c == 45) {
							if(range != 0) {
								return null;
							}
							let last = acc.pop();
							if(last == null) {
								acc.push(new hxparse__$LexEngine_CharRange(c,c));
							} else {
								if(last.min != last.max) {
									return null;
								}
								range = last.min;
							}
						} else {
							if(c == 92) {
								c = readChar();
							}
							if(range == 0) {
								acc.push(new hxparse__$LexEngine_CharRange(c,c));
							} else {
								acc.push(new hxparse__$LexEngine_CharRange(range,c));
								range = 0;
							}
						}
					}
					let g = [];
					let _g = 0;
					while(_g < acc.length) {
						let k = acc[_g];
						++_g;
						g = hxparse_LexEngine.cunion(g,[k]);
					}
					if(not) {
						g = hxparse_LexEngine.cdiff(hxparse_LexEngine.ALL_CHARS,g);
					}
					r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match(g));
				} else {
					r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
				}
				break;
			case 92:
				c = readChar();
				r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
				break;
			case 124:
				if(r != hxparse__$LexEngine_Pattern.Empty) {
					let r2 = hxparse_LexEngine.parseInner(pattern,i);
					return { pattern : hxparse__$LexEngine_Pattern.Choice(r,r2.pattern), pos : r2.pos};
				} else {
					r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
				}
				break;
			default:
				r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
			}
		}
		if(pDepth != 0) {
			throw haxe_Exception.thrown("Found unclosed parenthesis while parsing \"" + Std.string(pattern) + "\"");
		}
		return { pattern : r, pos : i};
	}
}
$hxClasses["hxparse.LexEngine"] = hxparse_LexEngine;
hxparse_LexEngine.__name__ = "hxparse.LexEngine";
Object.assign(hxparse_LexEngine.prototype, {
	__class__: hxparse_LexEngine
	,uid: null
	,nodes: null
	,finals: null
	,states: null
	,hstates: null
});
var hxparse__$LexEngine_Pattern = $hxEnums["hxparse._LexEngine.Pattern"] = { __ename__ : true, __constructs__ : ["Empty","Match","Star","Plus","Next","Choice","Group"]
	,Empty: {_hx_index:0,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}
	,Match: ($_=function(c) { return {_hx_index:1,c:c,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_.__params__ = ["c"],$_)
	,Star: ($_=function(p) { return {_hx_index:2,p:p,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_.__params__ = ["p"],$_)
	,Plus: ($_=function(p) { return {_hx_index:3,p:p,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_.__params__ = ["p"],$_)
	,Next: ($_=function(p1,p2) { return {_hx_index:4,p1:p1,p2:p2,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_.__params__ = ["p1","p2"],$_)
	,Choice: ($_=function(p1,p2) { return {_hx_index:5,p1:p1,p2:p2,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_.__params__ = ["p1","p2"],$_)
	,Group: ($_=function(p) { return {_hx_index:6,p:p,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_.__params__ = ["p"],$_)
};
class js_Boot {
	static getClass(o) {
		if(o == null) {
			return null;
		} else if(((o) instanceof Array)) {
			return Array;
		} else {
			let cl = o.__class__;
			if(cl != null) {
				return cl;
			}
			let name = js_Boot.__nativeClassName(o);
			if(name != null) {
				return js_Boot.__resolveNativeClass(name);
			}
			return null;
		}
	}
	static __string_rec(o,s) {
		if(o == null) {
			return "null";
		}
		if(s.length >= 5) {
			return "<...>";
		}
		let t = typeof(o);
		if(t == "function" && (o.__name__ || o.__ename__)) {
			t = "object";
		}
		switch(t) {
		case "function":
			return "<function>";
		case "object":
			if(o.__enum__) {
				let e = $hxEnums[o.__enum__];
				let n = e.__constructs__[o._hx_index];
				let con = e[n];
				if(con.__params__) {
					s = s + "\t";
					return n + "(" + ((function($this) {
						var $r;
						let _g = [];
						{
							let _g1 = 0;
							let _g2 = con.__params__;
							while(true) {
								if(!(_g1 < _g2.length)) {
									break;
								}
								let p = _g2[_g1];
								_g1 = _g1 + 1;
								_g.push(js_Boot.__string_rec(o[p],s));
							}
						}
						$r = _g;
						return $r;
					}(this))).join(",") + ")";
				} else {
					return n;
				}
			}
			if(((o) instanceof Array)) {
				let str = "[";
				s += "\t";
				let _g = 0;
				let _g1 = o.length;
				while(_g < _g1) {
					let i = _g++;
					str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
				}
				str += "]";
				return str;
			}
			let tostr;
			try {
				tostr = o.toString;
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				return "???";
			}
			if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
				let s2 = o.toString();
				if(s2 != "[object Object]") {
					return s2;
				}
			}
			let str = "{\n";
			s += "\t";
			let hasp = o.hasOwnProperty != null;
			let k = null;
			for( k in o ) {
			if(hasp && !o.hasOwnProperty(k)) {
				continue;
			}
			if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
				continue;
			}
			if(str.length != 2) {
				str += ", \n";
			}
			str += s + k + " : " + js_Boot.__string_rec(o[k],s);
			}
			s = s.substring(1);
			str += "\n" + s + "}";
			return str;
		case "string":
			return o;
		default:
			return String(o);
		}
	}
	static __interfLoop(cc,cl) {
		if(cc == null) {
			return false;
		}
		if(cc == cl) {
			return true;
		}
		let intf = cc.__interfaces__;
		if(intf != null && (cc.__super__ == null || cc.__super__.__interfaces__ != intf)) {
			let _g = 0;
			let _g1 = intf.length;
			while(_g < _g1) {
				let i = _g++;
				let i1 = intf[i];
				if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
					return true;
				}
			}
		}
		return js_Boot.__interfLoop(cc.__super__,cl);
	}
	static __instanceof(o,cl) {
		if(cl == null) {
			return false;
		}
		switch(cl) {
		case Array:
			return ((o) instanceof Array);
		case Bool:
			return typeof(o) == "boolean";
		case Dynamic:
			return o != null;
		case Float:
			return typeof(o) == "number";
		case Int:
			if(typeof(o) == "number") {
				return ((o | 0) === o);
			} else {
				return false;
			}
			break;
		case String:
			return typeof(o) == "string";
		default:
			if(o != null) {
				if(typeof(cl) == "function") {
					if(js_Boot.__downcastCheck(o,cl)) {
						return true;
					}
				} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
					if(((o) instanceof cl)) {
						return true;
					}
				}
			} else {
				return false;
			}
			if(cl == Class ? o.__name__ != null : false) {
				return true;
			}
			if(cl == Enum ? o.__ename__ != null : false) {
				return true;
			}
			return o.__enum__ != null ? $hxEnums[o.__enum__] == cl : false;
		}
	}
	static __downcastCheck(o,cl) {
		if(!((o) instanceof cl)) {
			if(cl.__isInterface__) {
				return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	static __cast(o,t) {
		if(o == null || js_Boot.__instanceof(o,t)) {
			return o;
		} else {
			throw haxe_Exception.thrown("Cannot cast " + Std.string(o) + " to " + Std.string(t));
		}
	}
	static __nativeClassName(o) {
		let name = js_Boot.__toStr.call(o).slice(8,-1);
		if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
			return null;
		}
		return name;
	}
	static __isNativeObj(o) {
		return js_Boot.__nativeClassName(o) != null;
	}
	static __resolveNativeClass(name) {
		return $global[name];
	}
}
$hxClasses["js.Boot"] = js_Boot;
js_Boot.__name__ = "js.Boot";
class hxparse__$LexEngine_Node {
	constructor(id,pid) {
		this.id = id;
		this.pid = pid;
		this.trans = [];
		this.epsilon = [];
	}
}
$hxClasses["hxparse._LexEngine.Node"] = hxparse__$LexEngine_Node;
hxparse__$LexEngine_Node.__name__ = "hxparse._LexEngine.Node";
Object.assign(hxparse__$LexEngine_Node.prototype, {
	__class__: hxparse__$LexEngine_Node
	,id: null
	,pid: null
	,trans: null
	,epsilon: null
});
class hxparse_Ruleset {
	constructor(state,functions,eofFunction,name) {
		if(name == null) {
			name = "";
		}
		this.state = state;
		this.functions = functions;
		this.eofFunction = eofFunction;
		this.name = name;
	}
}
$hxClasses["hxparse.Ruleset"] = hxparse_Ruleset;
hxparse_Ruleset.__name__ = "hxparse.Ruleset";
Object.assign(hxparse_Ruleset.prototype, {
	__class__: hxparse_Ruleset
	,state: null
	,functions: null
	,eofFunction: null
	,name: null
});
class hxparse_Position {
	constructor(source,min,max) {
		this.psource = source;
		this.pmin = min;
		this.pmax = max;
	}
	toString() {
		return "" + this.psource + ":characters " + this.pmin + "-" + this.pmax;
	}
	getLinePosition(input) {
		let lineMin = 1;
		let lineMax = 1;
		let posMin = 0;
		let posMax = 0;
		let cur = 0;
		while(cur < this.pmin) {
			if(input.b[cur] == 10) {
				++lineMin;
				posMin = cur + 1;
			}
			++cur;
		}
		lineMax = lineMin;
		posMax = posMin;
		posMin = cur - posMin;
		while(cur < this.pmax) {
			if(input.b[cur] == 10) {
				++lineMax;
				posMax = cur + 1;
			}
			++cur;
		}
		posMax = cur - posMax;
		return { lineMin : lineMin, lineMax : lineMax, posMin : posMin, posMax : posMax};
	}
	format(input) {
		let linePos = this.getLinePosition(input);
		if(linePos.lineMin != linePos.lineMax) {
			return "" + this.psource + ":lines " + linePos.lineMin + "-" + linePos.lineMax;
		} else {
			return "" + this.psource + ":" + linePos.lineMin + ": characters " + linePos.posMin + "-" + linePos.posMax;
		}
	}
}
$hxClasses["hxparse.Position"] = hxparse_Position;
hxparse_Position.__name__ = "hxparse.Position";
Object.assign(hxparse_Position.prototype, {
	__class__: hxparse_Position
	,psource: null
	,pmin: null
	,pmax: null
});
class haxeparser_HaxeLexer extends hxparse_Lexer {
	constructor(input,sourceName) {
		super(input,sourceName);
	}
	static mkPos(p) {
		return { file : p.psource, min : p.pmin, max : p.pmax};
	}
	static mk(lexer,td) {
		return new haxeparser_Token(td,haxeparser_HaxeLexer.mkPos(new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos)));
	}
	static unescape(s,pos) {
		let b_b = "";
		let i = 0;
		let esc = false;
		while(s.length != i) {
			let c = HxOverrides.cca(s,i);
			if(esc) {
				let iNext = i + 1;
				let _hx_tmp;
				if(c == null) {
					_hx_tmp = c >= 48 && c <= 51;
					if(_hx_tmp == true) {
						iNext += 2;
					} else {
						let c1 = c;
						throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnknownEscapeSequence("\\" + String.fromCodePoint(c1)),{ file : pos.file, min : pos.min + i, max : pos.min + i + 1}));
					}
				} else {
					switch(c) {
					case 34:case 39:case 92:
						b_b += String.fromCodePoint(c);
						break;
					case 110:
						b_b += "\n";
						break;
					case 114:
						b_b += "\r";
						break;
					case 116:
						b_b += "\t";
						break;
					case 117:
						_hx_tmp = c >= 48 && c <= 51;
						if(_hx_tmp == true) {
							iNext += 2;
						} else {
							let c;
							if(s.charAt(i + 1) == "{") {
								let endIndex = s.indexOf("}",i + 3);
								if(endIndex == -1) {
									throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedEscapeSequence,{ file : pos.file, min : pos.min + i, max : pos.min + i + 2}));
								}
								let l = endIndex - (i + 2);
								let chars = HxOverrides.substr(s,i + 2,l);
								if(!new EReg("^[0-9a-fA-F]+$","").match(chars)) {
									throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.InvalidEscapeSequence("\\u{" + chars + "}"),{ file : pos.file, min : pos.min + i, max : pos.min + i + (3 + l)}));
								}
								c = Std.parseInt("0x" + chars);
								if(c > 1114111) {
									throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.InvalidEscapeSequence("\\u{" + chars + "}"),{ file : pos.file, min : pos.min + i, max : pos.min + i + (3 + l)}));
								}
								iNext += 2 + l;
							} else {
								let chars = HxOverrides.substr(s,i + 1,4);
								if(!new EReg("^[0-9a-fA-F]{4}$","").match(chars)) {
									throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.InvalidEscapeSequence("\\u" + chars),{ file : pos.file, min : pos.min + i, max : pos.min + i + 5}));
								}
								c = Std.parseInt("0x" + chars);
								iNext += 4;
							}
							b_b += String.fromCodePoint(c);
						}
						break;
					case 120:
						_hx_tmp = c >= 48 && c <= 51;
						if(_hx_tmp == true) {
							iNext += 2;
						} else {
							let chars = HxOverrides.substr(s,i + 1,2);
							if(!new EReg("^[0-9a-fA-F]{2}$","").match(chars)) {
								throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.InvalidEscapeSequence("\\x" + chars),{ file : pos.file, min : pos.min + i, max : pos.min + i + 3}));
							}
							let c = Std.parseInt("0x" + chars);
							b_b += String.fromCodePoint(c);
							iNext += 2;
						}
						break;
					default:
						_hx_tmp = c >= 48 && c <= 51;
						if(_hx_tmp == true) {
							iNext += 2;
						} else {
							let c1 = c;
							throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnknownEscapeSequence("\\" + String.fromCodePoint(c1)),{ file : pos.file, min : pos.min + i, max : pos.min + i + 1}));
						}
					}
				}
				esc = false;
				i = iNext;
			} else if(c == null) {
				b_b += String.fromCodePoint(c);
				++i;
			} else if(c == 92) {
				++i;
				esc = true;
			} else {
				b_b += String.fromCodePoint(c);
				++i;
			}
		}
		return b_b;
	}
}
$hxClasses["haxeparser.HaxeLexer"] = haxeparser_HaxeLexer;
haxeparser_HaxeLexer.__name__ = "haxeparser.HaxeLexer";
haxeparser_HaxeLexer.__interfaces__ = [hxparse_RuleBuilder];
haxeparser_HaxeLexer.__super__ = hxparse_Lexer;
Object.assign(haxeparser_HaxeLexer.prototype, {
	__class__: haxeparser_HaxeLexer
});
class hxjsonast_Error {
	constructor(message,pos) {
		this.message = message;
		this.pos = pos;
	}
}
$hxClasses["hxjsonast.Error"] = hxjsonast_Error;
hxjsonast_Error.__name__ = "hxjsonast.Error";
Object.assign(hxjsonast_Error.prototype, {
	__class__: hxjsonast_Error
	,message: null
	,pos: null
});
class hxjsonast_Json {
	constructor(value,pos) {
		this.value = value;
		this.pos = pos;
	}
}
$hxClasses["hxjsonast.Json"] = hxjsonast_Json;
hxjsonast_Json.__name__ = "hxjsonast.Json";
Object.assign(hxjsonast_Json.prototype, {
	__class__: hxjsonast_Json
	,value: null
	,pos: null
});
var hxjsonast_JsonValue = $hxEnums["hxjsonast.JsonValue"] = { __ename__ : true, __constructs__ : ["JString","JNumber","JObject","JArray","JBool","JNull"]
	,JString: ($_=function(s) { return {_hx_index:0,s:s,__enum__:"hxjsonast.JsonValue",toString:$estr}; },$_.__params__ = ["s"],$_)
	,JNumber: ($_=function(s) { return {_hx_index:1,s:s,__enum__:"hxjsonast.JsonValue",toString:$estr}; },$_.__params__ = ["s"],$_)
	,JObject: ($_=function(fields) { return {_hx_index:2,fields:fields,__enum__:"hxjsonast.JsonValue",toString:$estr}; },$_.__params__ = ["fields"],$_)
	,JArray: ($_=function(values) { return {_hx_index:3,values:values,__enum__:"hxjsonast.JsonValue",toString:$estr}; },$_.__params__ = ["values"],$_)
	,JBool: ($_=function(b) { return {_hx_index:4,b:b,__enum__:"hxjsonast.JsonValue",toString:$estr}; },$_.__params__ = ["b"],$_)
	,JNull: {_hx_index:5,__enum__:"hxjsonast.JsonValue",toString:$estr}
};
class hxjsonast_JObjectField {
	constructor(name,namePos,value) {
		this.name = name;
		this.namePos = namePos;
		this.value = value;
	}
}
$hxClasses["hxjsonast.JObjectField"] = hxjsonast_JObjectField;
hxjsonast_JObjectField.__name__ = "hxjsonast.JObjectField";
Object.assign(hxjsonast_JObjectField.prototype, {
	__class__: hxjsonast_JObjectField
	,name: null
	,namePos: null
	,value: null
});
class hxjsonast_Parser {
	constructor(source,filename) {
		this.source = source;
		this.filename = filename;
		this.pos = 0;
	}
	parseRec() {
		while(true) {
			let c = this.source.charCodeAt(this.pos++);
			switch(c) {
			case 9:case 10:case 13:case 32:
				break;
			case 34:
				let save = this.pos;
				let s = this.parseString();
				return new hxjsonast_Json(hxjsonast_JsonValue.JString(s),new hxjsonast_Position(this.filename,save - 1,this.pos));
			case 45:case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
				let start = this.pos - 1;
				let minus = c == 45;
				let digit = !minus;
				let zero = c == 48;
				let point = false;
				let e = false;
				let pm = false;
				let end = false;
				while(true) {
					switch(this.source.charCodeAt(this.pos++)) {
					case 43:case 45:
						if(!e || pm) {
							this.invalidNumber(start);
						}
						digit = false;
						pm = true;
						break;
					case 46:
						if(minus || point) {
							this.invalidNumber(start);
						}
						digit = false;
						point = true;
						break;
					case 48:
						if(zero && !point) {
							this.invalidNumber(start);
						}
						if(minus) {
							minus = false;
							zero = true;
						}
						digit = true;
						break;
					case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
						if(zero && !point) {
							this.invalidNumber(start);
						}
						if(minus) {
							minus = false;
						}
						digit = true;
						zero = false;
						break;
					case 69:case 101:
						if(minus || zero || e) {
							this.invalidNumber(start);
						}
						digit = false;
						e = true;
						break;
					default:
						if(!digit) {
							this.invalidNumber(start);
						}
						this.pos--;
						end = true;
					}
					if(end) {
						break;
					}
				}
				let s1 = HxOverrides.substr(this.source,start,this.pos - start);
				return new hxjsonast_Json(hxjsonast_JsonValue.JNumber(s1),new hxjsonast_Position(this.filename,start,this.pos));
			case 91:
				let values = [];
				let comma = null;
				let startPos = this.pos - 1;
				while(true) switch(this.source.charCodeAt(this.pos++)) {
				case 9:case 10:case 13:case 32:
					break;
				case 44:
					if(comma) {
						comma = false;
					} else {
						this.invalidChar();
					}
					break;
				case 93:
					if(comma == false) {
						this.invalidChar();
					}
					return new hxjsonast_Json(hxjsonast_JsonValue.JArray(values),new hxjsonast_Position(this.filename,startPos,this.pos));
				default:
					if(comma) {
						this.invalidChar();
					}
					this.pos--;
					values.push(this.parseRec());
					comma = true;
				}
				break;
			case 102:
				let save1 = this.pos;
				if(this.source.charCodeAt(this.pos++) != 97 || this.source.charCodeAt(this.pos++) != 108 || this.source.charCodeAt(this.pos++) != 115 || this.source.charCodeAt(this.pos++) != 101) {
					this.pos = save1;
					this.invalidChar();
				}
				return new hxjsonast_Json(hxjsonast_JsonValue.JBool(false),new hxjsonast_Position(this.filename,save1 - 1,this.pos));
			case 110:
				let save2 = this.pos;
				if(this.source.charCodeAt(this.pos++) != 117 || this.source.charCodeAt(this.pos++) != 108 || this.source.charCodeAt(this.pos++) != 108) {
					this.pos = save2;
					this.invalidChar();
				}
				return new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position(this.filename,save2 - 1,this.pos));
			case 116:
				let save3 = this.pos;
				if(this.source.charCodeAt(this.pos++) != 114 || this.source.charCodeAt(this.pos++) != 117 || this.source.charCodeAt(this.pos++) != 101) {
					this.pos = save3;
					this.invalidChar();
				}
				return new hxjsonast_Json(hxjsonast_JsonValue.JBool(true),new hxjsonast_Position(this.filename,save3 - 1,this.pos));
			case 123:
				let fields = [];
				let names_h = Object.create(null);
				let field = null;
				let fieldPos = null;
				let comma1 = null;
				let startPos1 = this.pos - 1;
				while(true) switch(this.source.charCodeAt(this.pos++)) {
				case 9:case 10:case 13:case 32:
					break;
				case 34:
					if(comma1) {
						this.invalidChar();
					}
					let fieldStartPos = this.pos - 1;
					field = this.parseString();
					fieldPos = new hxjsonast_Position(this.filename,fieldStartPos,this.pos);
					if(Object.prototype.hasOwnProperty.call(names_h,field)) {
						throw haxe_Exception.thrown(new hxjsonast_Error("Duplicate field name \"" + field + "\"",fieldPos));
					} else {
						names_h[field] = true;
					}
					break;
				case 44:
					if(comma1) {
						comma1 = false;
					} else {
						this.invalidChar();
					}
					break;
				case 58:
					if(field == null) {
						this.invalidChar();
					}
					fields.push(new hxjsonast_JObjectField(field,fieldPos,this.parseRec()));
					field = null;
					fieldPos = null;
					comma1 = true;
					break;
				case 125:
					if(field != null || comma1 == false) {
						this.invalidChar();
					}
					return new hxjsonast_Json(hxjsonast_JsonValue.JObject(fields),new hxjsonast_Position(this.filename,startPos1,this.pos));
				default:
					this.invalidChar();
				}
				break;
			default:
				this.invalidChar();
			}
		}
	}
	parseString() {
		let start = this.pos;
		let buf = null;
		while(true) {
			let c = this.source.charCodeAt(this.pos++);
			if(c == 34) {
				break;
			}
			if(c == 92) {
				if(buf == null) {
					buf = new StringBuf();
				}
				let s = this.source;
				let len = this.pos - start - 1;
				buf.b += len == null ? HxOverrides.substr(s,start,null) : HxOverrides.substr(s,start,len);
				c = this.source.charCodeAt(this.pos++);
				switch(c) {
				case 34:case 47:case 92:
					buf.b += String.fromCodePoint(c);
					break;
				case 98:
					buf.b += String.fromCodePoint(8);
					break;
				case 102:
					buf.b += String.fromCodePoint(12);
					break;
				case 110:
					buf.b += String.fromCodePoint(10);
					break;
				case 114:
					buf.b += String.fromCodePoint(13);
					break;
				case 116:
					buf.b += String.fromCodePoint(9);
					break;
				case 117:
					let uc = Std.parseInt("0x" + HxOverrides.substr(this.source,this.pos,4));
					this.pos += 4;
					buf.b += String.fromCodePoint(uc);
					break;
				default:
					throw haxe_Exception.thrown(new hxjsonast_Error("Invalid escape sequence \\" + String.fromCodePoint(c),new hxjsonast_Position(this.filename,this.pos - 2,this.pos)));
				}
				start = this.pos;
			} else if(c != c) {
				this.pos--;
				throw haxe_Exception.thrown(new hxjsonast_Error("Unclosed string",new hxjsonast_Position(this.filename,start - 1,this.pos)));
			}
		}
		if(buf == null) {
			return HxOverrides.substr(this.source,start,this.pos - start - 1);
		} else {
			let s = this.source;
			let len = this.pos - start - 1;
			buf.b += len == null ? HxOverrides.substr(s,start,null) : HxOverrides.substr(s,start,len);
			return buf.b;
		}
	}
	invalidChar() {
		this.pos--;
		throw haxe_Exception.thrown(new hxjsonast_Error("Invalid character: " + this.source.charAt(this.pos),new hxjsonast_Position(this.filename,this.pos,this.pos + 1)));
	}
	invalidNumber(start) {
		throw haxe_Exception.thrown(new hxjsonast_Error("Invalid number: " + this.source.substring(start,this.pos),new hxjsonast_Position(this.filename,start,this.pos)));
	}
}
$hxClasses["hxjsonast.Parser"] = hxjsonast_Parser;
hxjsonast_Parser.__name__ = "hxjsonast.Parser";
Object.assign(hxjsonast_Parser.prototype, {
	__class__: hxjsonast_Parser
	,source: null
	,filename: null
	,pos: null
});
class hxjsonast_Position {
	constructor(file,min,max) {
		this.file = file;
		this.min = min;
		this.max = max;
	}
}
$hxClasses["hxjsonast.Position"] = hxjsonast_Position;
hxjsonast_Position.__name__ = "hxjsonast.Position";
Object.assign(hxjsonast_Position.prototype, {
	__class__: hxjsonast_Position
	,file: null
	,min: null
	,max: null
});
class hxparse_ParserError {
	constructor(pos) {
		this.pos = pos;
	}
}
$hxClasses["hxparse.ParserError"] = hxparse_ParserError;
hxparse_ParserError.__name__ = "hxparse.ParserError";
Object.assign(hxparse_ParserError.prototype, {
	__class__: hxparse_ParserError
	,pos: null
});
class hxparse_State {
	constructor() {
		this.finalId = -1;
		let this1 = new Array(256);
		this.trans = this1;
	}
}
$hxClasses["hxparse.State"] = hxparse_State;
hxparse_State.__name__ = "hxparse.State";
Object.assign(hxparse_State.prototype, {
	__class__: hxparse_State
	,trans: null
	,finalId: null
});
class hxparse_UnexpectedChar extends hxparse_ParserError {
	constructor(char,pos) {
		super(pos);
		this.char = char;
	}
	toString() {
		return "Unexpected " + this.char;
	}
}
$hxClasses["hxparse.UnexpectedChar"] = hxparse_UnexpectedChar;
hxparse_UnexpectedChar.__name__ = "hxparse.UnexpectedChar";
hxparse_UnexpectedChar.__super__ = hxparse_ParserError;
Object.assign(hxparse_UnexpectedChar.prototype, {
	__class__: hxparse_UnexpectedChar
	,char: null
});
var json2object_Error = $hxEnums["json2object.Error"] = { __ename__ : true, __constructs__ : ["IncorrectType","IncorrectEnumValue","InvalidEnumConstructor","UninitializedVariable","UnknownVariable","ParserError"]
	,IncorrectType: ($_=function(variable,expected,pos) { return {_hx_index:0,variable:variable,expected:expected,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_.__params__ = ["variable","expected","pos"],$_)
	,IncorrectEnumValue: ($_=function(value,expected,pos) { return {_hx_index:1,value:value,expected:expected,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_.__params__ = ["value","expected","pos"],$_)
	,InvalidEnumConstructor: ($_=function(value,expected,pos) { return {_hx_index:2,value:value,expected:expected,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_.__params__ = ["value","expected","pos"],$_)
	,UninitializedVariable: ($_=function(variable,pos) { return {_hx_index:3,variable:variable,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_.__params__ = ["variable","pos"],$_)
	,UnknownVariable: ($_=function(variable,pos) { return {_hx_index:4,variable:variable,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_.__params__ = ["variable","pos"],$_)
	,ParserError: ($_=function(message,pos) { return {_hx_index:5,message:message,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_.__params__ = ["message","pos"],$_)
};
class json2object_PositionUtils {
	constructor(content) {
		this.linesInfo = [];
		let s = 0;
		let e = 0;
		let i = 0;
		let lineCount = 0;
		while(i < content.length) switch(content.charAt(i)) {
		case "\n":
			e = i;
			this.linesInfo.push({ number : lineCount, start : s, end : e});
			++lineCount;
			++i;
			s = i;
			break;
		case "\r":
			e = i;
			if(content.charAt(i + 1) == "\n") {
				++e;
			}
			this.linesInfo.push({ number : lineCount, start : s, end : e});
			++lineCount;
			i = e + 1;
			s = i;
			break;
		default:
			++i;
		}
		this.linesInfo.push({ number : lineCount, start : s, end : i});
	}
	convertPosition(position) {
		let file = position.file;
		let min = position.min;
		let max = position.max;
		let pos = { file : file, min : min + 1, max : max + 1, lines : []};
		let lastLine = this.linesInfo.length - 1;
		let bounds_min = 0;
		let bounds_max = lastLine;
		if(min > this.linesInfo[0].end) {
			while(bounds_max > bounds_min) {
				let i = (bounds_min + bounds_max) / 2 | 0;
				let line = this.linesInfo[i];
				if(line.start == min) {
					bounds_min = i;
					bounds_max = i;
				}
				if(line.end < min) {
					bounds_min = i + 1;
				}
				if(line.start > min || line.end >= min && line.start < min) {
					bounds_max = i;
				}
			}
		}
		let _g = bounds_min;
		let _g1 = this.linesInfo.length;
		while(_g < _g1) {
			let i = _g++;
			let line = this.linesInfo[i];
			if(line.start <= min && line.end >= max) {
				pos.lines.push({ number : line.number + 1, start : min - line.start + 1, end : max - line.start + 1});
				break;
			}
			if(line.start <= min && min <= line.end) {
				pos.lines.push({ number : line.number + 1, start : min - line.start + 1, end : line.end + 1});
			}
			if(line.start <= max && max <= line.end) {
				pos.lines.push({ number : line.number + 1, start : line.start + 1, end : max - line.start + 1});
			}
			if(line.start >= max || line.end >= max) {
				break;
			}
		}
		return pos;
	}
}
$hxClasses["json2object.PositionUtils"] = json2object_PositionUtils;
json2object_PositionUtils.__name__ = "json2object.PositionUtils";
Object.assign(json2object_PositionUtils.prototype, {
	__class__: json2object_PositionUtils
	,linesInfo: null
});
class markdown_Node {
}
$hxClasses["markdown.Node"] = markdown_Node;
markdown_Node.__name__ = "markdown.Node";
markdown_Node.__isInterface__ = true;
Object.assign(markdown_Node.prototype, {
	__class__: markdown_Node
	,accept: null
});
class markdown_NodeVisitor {
}
$hxClasses["markdown.NodeVisitor"] = markdown_NodeVisitor;
markdown_NodeVisitor.__name__ = "markdown.NodeVisitor";
markdown_NodeVisitor.__isInterface__ = true;
Object.assign(markdown_NodeVisitor.prototype, {
	__class__: markdown_NodeVisitor
	,visitText: null
	,visitElementBefore: null
	,visitElementAfter: null
});
class markdown_ElementNode {
	constructor(tag,children) {
		this.tag = tag;
		this.children = children;
		this.attributes = new haxe_ds_StringMap();
	}
	accept(visitor) {
		if(visitor.visitElementBefore(this)) {
			let _g = 0;
			let _g1 = this.children;
			while(_g < _g1.length) {
				let child = _g1[_g];
				++_g;
				child.accept(visitor);
			}
			visitor.visitElementAfter(this);
		}
	}
	static empty(tag) {
		return new markdown_ElementNode(tag,null);
	}
	static text(tag,text) {
		return new markdown_ElementNode(tag,[new markdown_TextNode(text)]);
	}
}
$hxClasses["markdown.ElementNode"] = markdown_ElementNode;
markdown_ElementNode.__name__ = "markdown.ElementNode";
markdown_ElementNode.__interfaces__ = [markdown_Node];
Object.assign(markdown_ElementNode.prototype, {
	__class__: markdown_ElementNode
	,tag: null
	,children: null
	,attributes: null
});
class markdown_TextNode {
	constructor(text) {
		this.text = text;
	}
	accept(visitor) {
		visitor.visitText(this);
	}
}
$hxClasses["markdown.TextNode"] = markdown_TextNode;
markdown_TextNode.__name__ = "markdown.TextNode";
markdown_TextNode.__interfaces__ = [markdown_Node];
Object.assign(markdown_TextNode.prototype, {
	__class__: markdown_TextNode
	,text: null
});
class markdown_BlockParser {
	constructor(lines,document) {
		this.lines = lines;
		this.document = document;
		this.pos = 0;
	}
	get_next() {
		if(this.pos >= this.lines.length - 1) {
			return null;
		}
		return this.lines[this.pos + 1];
	}
	advance() {
		this.pos++;
	}
	matches(ereg) {
		if(this.pos >= this.lines.length) {
			return false;
		}
		return ereg.match(this.lines[this.pos]);
	}
	matchesNext(ereg) {
		if(this.get_next() == null) {
			return false;
		}
		return ereg.match(this.get_next());
	}
}
$hxClasses["markdown.BlockParser"] = markdown_BlockParser;
markdown_BlockParser.__name__ = "markdown.BlockParser";
Object.assign(markdown_BlockParser.prototype, {
	__class__: markdown_BlockParser
	,lines: null
	,document: null
	,pos: null
});
class markdown_BlockSyntax {
	constructor() {
	}
	get_pattern() {
		return null;
	}
	get_canEndBlock() {
		return true;
	}
	canParse(parser) {
		return this.get_pattern().match(parser.lines[parser.pos]);
	}
	parse(parser) {
		return null;
	}
	static get_syntaxes() {
		if(markdown_BlockSyntax.syntaxes == null) {
			markdown_BlockSyntax.syntaxes = [new markdown_EmptyBlockSyntax(),new markdown_BlockHtmlSyntax(),new markdown_SetextHeaderSyntax(),new markdown_HeaderSyntax(),new markdown_CodeBlockSyntax(),new markdown_GitHubCodeBlockSyntax(),new markdown_BlockquoteSyntax(),new markdown_HorizontalRuleSyntax(),new markdown_UnorderedListSyntax(),new markdown_OrderedListSyntax(),new markdown_TableSyntax(),new markdown_ParagraphSyntax()];
		}
		return markdown_BlockSyntax.syntaxes;
	}
	static isAtBlockEnd(parser) {
		if(parser.pos >= parser.lines.length) {
			return true;
		}
		let _g = 0;
		let _g1 = markdown_BlockSyntax.get_syntaxes();
		while(_g < _g1.length) {
			let syntax = _g1[_g];
			++_g;
			if(syntax.canParse(parser) && syntax.get_canEndBlock()) {
				return true;
			}
		}
		return false;
	}
}
$hxClasses["markdown.BlockSyntax"] = markdown_BlockSyntax;
markdown_BlockSyntax.__name__ = "markdown.BlockSyntax";
Object.assign(markdown_BlockSyntax.prototype, {
	__class__: markdown_BlockSyntax
});
class markdown_EmptyBlockSyntax extends markdown_BlockSyntax {
	constructor() {
		super();
	}
	get_pattern() {
		return markdown_BlockSyntax.RE_EMPTY;
	}
	parse(parser) {
		parser.advance();
		return null;
	}
}
$hxClasses["markdown.EmptyBlockSyntax"] = markdown_EmptyBlockSyntax;
markdown_EmptyBlockSyntax.__name__ = "markdown.EmptyBlockSyntax";
markdown_EmptyBlockSyntax.__super__ = markdown_BlockSyntax;
Object.assign(markdown_EmptyBlockSyntax.prototype, {
	__class__: markdown_EmptyBlockSyntax
});
class markdown_SetextHeaderSyntax extends markdown_BlockSyntax {
	constructor() {
		super();
	}
	canParse(parser) {
		return parser.matchesNext(markdown_BlockSyntax.RE_SETEXT);
	}
	parse(parser) {
		let re = markdown_BlockSyntax.RE_SETEXT;
		re.match(parser.get_next());
		let tag = re.matched(1).charAt(0) == "=" ? "h1" : "h2";
		let contents = parser.document.parseInline(parser.lines[parser.pos]);
		parser.advance();
		parser.advance();
		return new markdown_ElementNode(tag,contents);
	}
}
$hxClasses["markdown.SetextHeaderSyntax"] = markdown_SetextHeaderSyntax;
markdown_SetextHeaderSyntax.__name__ = "markdown.SetextHeaderSyntax";
markdown_SetextHeaderSyntax.__super__ = markdown_BlockSyntax;
Object.assign(markdown_SetextHeaderSyntax.prototype, {
	__class__: markdown_SetextHeaderSyntax
});
class markdown_HeaderSyntax extends markdown_BlockSyntax {
	constructor() {
		super();
	}
	get_pattern() {
		return markdown_BlockSyntax.RE_HEADER;
	}
	parse(parser) {
		this.get_pattern().match(parser.lines[parser.pos]);
		parser.advance();
		let level = this.get_pattern().matched(1).length;
		let contents = parser.document.parseInline(StringTools.trim(this.get_pattern().matched(2)));
		return new markdown_ElementNode("h" + level,contents);
	}
}
$hxClasses["markdown.HeaderSyntax"] = markdown_HeaderSyntax;
markdown_HeaderSyntax.__name__ = "markdown.HeaderSyntax";
markdown_HeaderSyntax.__super__ = markdown_BlockSyntax;
Object.assign(markdown_HeaderSyntax.prototype, {
	__class__: markdown_HeaderSyntax
});
class markdown_BlockquoteSyntax extends markdown_BlockSyntax {
	constructor() {
		super();
	}
	get_pattern() {
		return markdown_BlockSyntax.RE_BLOCKQUOTE;
	}
	parseChildLines(parser) {
		let childLines = [];
		while(parser.pos < parser.lines.length) if(this.get_pattern().match(parser.lines[parser.pos])) {
			childLines.push(this.get_pattern().matched(1));
			parser.advance();
		} else {
			let nextMatch = parser.get_next() != null && this.get_pattern().match(parser.get_next());
			if(StringTools.trim(parser.lines[parser.pos]) == "" && nextMatch) {
				childLines.push("");
				childLines.push(this.get_pattern().matched(1));
				parser.advance();
				parser.advance();
			} else {
				break;
			}
		}
		return childLines;
	}
	parse(parser) {
		let childLines = this.parseChildLines(parser);
		let children = parser.document.parseLines(childLines);
		return new markdown_ElementNode("blockquote",children);
	}
}
$hxClasses["markdown.BlockquoteSyntax"] = markdown_BlockquoteSyntax;
markdown_BlockquoteSyntax.__name__ = "markdown.BlockquoteSyntax";
markdown_BlockquoteSyntax.__super__ = markdown_BlockSyntax;
Object.assign(markdown_BlockquoteSyntax.prototype, {
	__class__: markdown_BlockquoteSyntax
});
class markdown_CodeBlockSyntax extends markdown_BlockSyntax {
	constructor() {
		super();
	}
	get_pattern() {
		return markdown_BlockSyntax.RE_INDENT;
	}
	parseChildLines(parser) {
		let childLines = [];
		while(parser.pos < parser.lines.length) if(this.get_pattern().match(parser.lines[parser.pos])) {
			childLines.push(this.get_pattern().matched(1));
			parser.advance();
		} else {
			let nextMatch = parser.get_next() != null && this.get_pattern().match(parser.get_next());
			if(StringTools.trim(parser.lines[parser.pos]) == "" && nextMatch) {
				childLines.push("");
				childLines.push(this.get_pattern().matched(1));
				parser.advance();
				parser.advance();
			} else {
				break;
			}
		}
		return childLines;
	}
	parse(parser) {
		let childLines = this.parseChildLines(parser);
		childLines.push("");
		let escaped = StringTools.htmlEscape(childLines.join("\n"));
		return new markdown_ElementNode("pre",[markdown_ElementNode.text("code",escaped)]);
	}
}
$hxClasses["markdown.CodeBlockSyntax"] = markdown_CodeBlockSyntax;
markdown_CodeBlockSyntax.__name__ = "markdown.CodeBlockSyntax";
markdown_CodeBlockSyntax.__super__ = markdown_BlockSyntax;
Object.assign(markdown_CodeBlockSyntax.prototype, {
	__class__: markdown_CodeBlockSyntax
});
class markdown_GitHubCodeBlockSyntax extends markdown_BlockSyntax {
	constructor() {
		super();
	}
	get_pattern() {
		return markdown_BlockSyntax.RE_CODE;
	}
	parseChildLines(parser) {
		let childLines = [];
		parser.advance();
		while(parser.pos < parser.lines.length) if(!this.get_pattern().match(parser.lines[parser.pos])) {
			childLines.push(parser.lines[parser.pos]);
			parser.advance();
		} else {
			parser.advance();
			break;
		}
		return childLines;
	}
	parse(parser) {
		let syntax = this.get_pattern().matched(1);
		let childLines = this.parseChildLines(parser);
		let code = null;
		let source = childLines.join("\n");
		if(Object.prototype.hasOwnProperty.call(parser.document.codeBlockSyntaxes.h,syntax)) {
			let format = parser.document.codeBlockSyntaxes.h[syntax];
			code = markdown_ElementNode.text("code",format(source));
		} else {
			code = markdown_ElementNode.text("code",StringTools.htmlEscape(source));
			if(syntax != null && syntax.length > 0) {
				code.attributes.h["class"] = "prettyprint " + syntax;
			}
		}
		return new markdown_ElementNode("pre",[code]);
	}
}
$hxClasses["markdown.GitHubCodeBlockSyntax"] = markdown_GitHubCodeBlockSyntax;
markdown_GitHubCodeBlockSyntax.__name__ = "markdown.GitHubCodeBlockSyntax";
markdown_GitHubCodeBlockSyntax.__super__ = markdown_BlockSyntax;
Object.assign(markdown_GitHubCodeBlockSyntax.prototype, {
	__class__: markdown_GitHubCodeBlockSyntax
});
class markdown_HorizontalRuleSyntax extends markdown_BlockSyntax {
	constructor() {
		super();
	}
	get_pattern() {
		return markdown_BlockSyntax.RE_HR;
	}
	parse(parser) {
		parser.advance();
		return markdown_ElementNode.empty("hr");
	}
}
$hxClasses["markdown.HorizontalRuleSyntax"] = markdown_HorizontalRuleSyntax;
markdown_HorizontalRuleSyntax.__name__ = "markdown.HorizontalRuleSyntax";
markdown_HorizontalRuleSyntax.__super__ = markdown_BlockSyntax;
Object.assign(markdown_HorizontalRuleSyntax.prototype, {
	__class__: markdown_HorizontalRuleSyntax
});
class markdown_BlockHtmlSyntax extends markdown_BlockSyntax {
	constructor() {
		super();
	}
	get_pattern() {
		return markdown_BlockSyntax.RE_HTML;
	}
	get_canEndBlock() {
		return false;
	}
	parse(parser) {
		let childLines = [];
		while(parser.pos < parser.lines.length && !parser.matches(markdown_BlockSyntax.RE_EMPTY)) {
			childLines.push(parser.lines[parser.pos]);
			parser.advance();
		}
		return new markdown_TextNode(childLines.join("\n"));
	}
}
$hxClasses["markdown.BlockHtmlSyntax"] = markdown_BlockHtmlSyntax;
markdown_BlockHtmlSyntax.__name__ = "markdown.BlockHtmlSyntax";
markdown_BlockHtmlSyntax.__super__ = markdown_BlockSyntax;
Object.assign(markdown_BlockHtmlSyntax.prototype, {
	__class__: markdown_BlockHtmlSyntax
});
class markdown_ListItem {
	constructor(lines) {
		this.forceBlock = false;
		this.lines = lines;
	}
}
$hxClasses["markdown.ListItem"] = markdown_ListItem;
markdown_ListItem.__name__ = "markdown.ListItem";
Object.assign(markdown_ListItem.prototype, {
	__class__: markdown_ListItem
	,forceBlock: null
	,lines: null
});
class markdown_ParagraphSyntax extends markdown_BlockSyntax {
	constructor() {
		super();
	}
	get_canEndBlock() {
		return false;
	}
	canParse(parser) {
		return true;
	}
	parse(parser) {
		let childLines = [];
		while(!markdown_BlockSyntax.isAtBlockEnd(parser)) {
			childLines.push(StringTools.ltrim(parser.lines[parser.pos]));
			parser.advance();
		}
		let contents = parser.document.parseInline(childLines.join("\n"));
		return new markdown_ElementNode("p",contents);
	}
}
$hxClasses["markdown.ParagraphSyntax"] = markdown_ParagraphSyntax;
markdown_ParagraphSyntax.__name__ = "markdown.ParagraphSyntax";
markdown_ParagraphSyntax.__super__ = markdown_BlockSyntax;
Object.assign(markdown_ParagraphSyntax.prototype, {
	__class__: markdown_ParagraphSyntax
});
class markdown_ListSyntax extends markdown_BlockSyntax {
	constructor(listTag) {
		super();
		this.listTag = listTag;
	}
	get_canEndBlock() {
		return false;
	}
	parse(parser) {
		let items = [];
		let childLines = [];
		let endItem = function() {
			if(childLines.length > 0) {
				items.push(new markdown_ListItem(childLines));
				childLines = [];
			}
		};
		let match;
		let tryMatch = function(pattern) {
			match = pattern;
			return pattern.match(parser.lines[parser.pos]);
		};
		while(parser.pos < parser.lines.length) {
			if(tryMatch(markdown_BlockSyntax.RE_EMPTY)) {
				childLines.push("");
			} else if(tryMatch(markdown_BlockSyntax.RE_UL) || tryMatch(markdown_BlockSyntax.RE_OL)) {
				endItem();
				childLines.push(match.matched(1));
			} else if(tryMatch(markdown_BlockSyntax.RE_INDENT)) {
				childLines.push(match.matched(1));
			} else if(markdown_BlockSyntax.isAtBlockEnd(parser)) {
				break;
			} else {
				if(childLines.length > 0 && childLines[childLines.length - 1] == "") {
					break;
				}
				childLines.push(parser.lines[parser.pos]);
			}
			parser.advance();
		}
		endItem();
		let _g = 0;
		let _g1 = items.length;
		while(_g < _g1) {
			let i = _g++;
			let len = items[i].lines.length;
			let _g1 = 1;
			let _g2 = len + 1;
			while(_g1 < _g2) {
				let jj = _g1++;
				let j = len - jj;
				if(markdown_BlockSyntax.RE_EMPTY.match(items[i].lines[j])) {
					if(i < items.length - 1) {
						items[i].forceBlock = true;
						items[i + 1].forceBlock = true;
					}
					items[i].lines.pop();
				} else {
					break;
				}
			}
		}
		let itemNodes = [];
		let _g2 = 0;
		while(_g2 < items.length) {
			let item = items[_g2];
			++_g2;
			let blockItem = item.forceBlock || item.lines.length > 1;
			let blocksInList = [markdown_BlockSyntax.RE_BLOCKQUOTE,markdown_BlockSyntax.RE_HEADER,markdown_BlockSyntax.RE_HR,markdown_BlockSyntax.RE_INDENT,markdown_BlockSyntax.RE_UL,markdown_BlockSyntax.RE_OL];
			if(!blockItem) {
				let _g = 0;
				while(_g < blocksInList.length) {
					let pattern = blocksInList[_g];
					++_g;
					if(pattern.match(item.lines[0])) {
						blockItem = true;
						break;
					}
				}
			}
			if(blockItem) {
				let children = parser.document.parseLines(item.lines);
				if(!item.forceBlock && children.length == 1) {
					if(((children[0]) instanceof markdown_ElementNode)) {
						let node = children[0];
						if(node.tag == "p") {
							children = node.children;
						}
					}
				}
				itemNodes.push(new markdown_ElementNode("li",children));
			} else {
				let contents = parser.document.parseInline(item.lines[0]);
				itemNodes.push(new markdown_ElementNode("li",contents));
			}
		}
		return new markdown_ElementNode(this.listTag,itemNodes);
	}
}
$hxClasses["markdown.ListSyntax"] = markdown_ListSyntax;
markdown_ListSyntax.__name__ = "markdown.ListSyntax";
markdown_ListSyntax.__super__ = markdown_BlockSyntax;
Object.assign(markdown_ListSyntax.prototype, {
	__class__: markdown_ListSyntax
	,listTag: null
});
class markdown_UnorderedListSyntax extends markdown_ListSyntax {
	constructor() {
		super("ul");
	}
	get_pattern() {
		return markdown_BlockSyntax.RE_UL;
	}
}
$hxClasses["markdown.UnorderedListSyntax"] = markdown_UnorderedListSyntax;
markdown_UnorderedListSyntax.__name__ = "markdown.UnorderedListSyntax";
markdown_UnorderedListSyntax.__super__ = markdown_ListSyntax;
Object.assign(markdown_UnorderedListSyntax.prototype, {
	__class__: markdown_UnorderedListSyntax
});
class markdown_OrderedListSyntax extends markdown_ListSyntax {
	constructor() {
		super("ol");
	}
	get_pattern() {
		return markdown_BlockSyntax.RE_OL;
	}
}
$hxClasses["markdown.OrderedListSyntax"] = markdown_OrderedListSyntax;
markdown_OrderedListSyntax.__name__ = "markdown.OrderedListSyntax";
markdown_OrderedListSyntax.__super__ = markdown_ListSyntax;
Object.assign(markdown_OrderedListSyntax.prototype, {
	__class__: markdown_OrderedListSyntax
});
class markdown_TableSyntax extends markdown_BlockSyntax {
	constructor() {
		super();
	}
	get_pattern() {
		return markdown_TableSyntax.TABLE_PATTERN;
	}
	get_canEndBlock() {
		return false;
	}
	parse(parser) {
		let lines = [];
		while(parser.pos < parser.lines.length && parser.matches(markdown_TableSyntax.TABLE_PATTERN)) {
			lines.push(parser.lines[parser.pos]);
			parser.advance();
		}
		let heads = [];
		let rows = [];
		let headLine = lines.shift();
		let alignLine = lines.shift();
		let aligns = [];
		if(alignLine != null) {
			markdown_TableSyntax.CELL_PATTERN.map(alignLine,function(e) {
				let text = e.matched(2);
				let align = text.charAt(0) == ":" ? text.charAt(text.length - 1) == ":" ? "center" : "left" : text.charAt(text.length - 1) == ":" ? "right" : "left";
				aligns.push(align);
				return "";
			});
		}
		let index = 0;
		markdown_TableSyntax.CELL_PATTERN.map(headLine,function(e) {
			let text = StringTools.trim(e.matched(2));
			let cell = new markdown_ElementNode("th",parser.document.parseInline(text));
			if(aligns[index] != "left") {
				cell.attributes.h["align"] = aligns[index];
			}
			heads.push(cell);
			index += 1;
			return "";
		});
		let _g = 0;
		while(_g < lines.length) {
			let line = lines[_g];
			++_g;
			let cols = [];
			rows.push(new markdown_ElementNode("tr",cols));
			let index = 0;
			markdown_TableSyntax.CELL_PATTERN.map(line,function(e) {
				let text = StringTools.trim(e.matched(2));
				let cell = new markdown_ElementNode("td",parser.document.parseInline(text));
				if(aligns[index] != "left") {
					cell.attributes.h["align"] = aligns[index];
				}
				cols.push(cell);
				index += 1;
				return "";
			});
		}
		return new markdown_ElementNode("table",[new markdown_ElementNode("thead",heads),new markdown_ElementNode("tbody",rows)]);
	}
}
$hxClasses["markdown.TableSyntax"] = markdown_TableSyntax;
markdown_TableSyntax.__name__ = "markdown.TableSyntax";
markdown_TableSyntax.__super__ = markdown_BlockSyntax;
Object.assign(markdown_TableSyntax.prototype, {
	__class__: markdown_TableSyntax
});
class markdown_HtmlRenderer {
	constructor() {
	}
	render(nodes) {
		this.buffer = new StringBuf();
		let _g = 0;
		while(_g < nodes.length) {
			let node = nodes[_g];
			++_g;
			node.accept(this);
		}
		return this.buffer.b;
	}
	visitText(text) {
		this.buffer.b += Std.string(text.text);
	}
	visitElementBefore(element) {
		if(this.buffer.b != "" && markdown_HtmlRenderer.BLOCK_TAGS.match(element.tag)) {
			this.buffer.b += "\n";
		}
		this.buffer.b += Std.string("<" + element.tag);
		let _g = [];
		let k = haxe_ds_StringMap.keysIterator(element.attributes.h);
		while(k.hasNext()) {
			let k1 = k.next();
			_g.push(k1);
		}
		let attributeNames = _g;
		attributeNames.sort(markdown_HtmlRenderer.sortAttributes);
		let _g1 = 0;
		while(_g1 < attributeNames.length) {
			let name = attributeNames[_g1];
			++_g1;
			this.buffer.b += Std.string(" " + name + "=\"" + element.attributes.h[name] + "\"");
		}
		if(element.children == null) {
			this.buffer.b += " />";
			return false;
		} else {
			this.buffer.b += ">";
			return true;
		}
	}
	visitElementAfter(element) {
		this.buffer.b += Std.string("</" + element.tag + ">");
	}
	static sortAttributes(a,b) {
		let ia = markdown_HtmlRenderer.attributeOrder.indexOf(a);
		let ib = markdown_HtmlRenderer.attributeOrder.indexOf(a);
		if(ia > -1 && ib > -1) {
			return ia - ib;
		}
		return Reflect.compare(a,b);
	}
}
$hxClasses["markdown.HtmlRenderer"] = markdown_HtmlRenderer;
markdown_HtmlRenderer.__name__ = "markdown.HtmlRenderer";
markdown_HtmlRenderer.__interfaces__ = [markdown_NodeVisitor];
Object.assign(markdown_HtmlRenderer.prototype, {
	__class__: markdown_HtmlRenderer
	,buffer: null
});
class markdown_InlineSyntax {
	constructor(pattern) {
		this.pattern = new EReg(pattern,"m");
	}
	tryMatch(parser) {
		if(this.pattern.match(parser.get_currentSource()) && this.pattern.matchedPos().pos == 0) {
			parser.writeText();
			if(this.onMatch(parser)) {
				parser.consume(this.pattern.matched(0).length);
			}
			return true;
		}
		return false;
	}
	onMatch(parser) {
		return false;
	}
}
$hxClasses["markdown.InlineSyntax"] = markdown_InlineSyntax;
markdown_InlineSyntax.__name__ = "markdown.InlineSyntax";
Object.assign(markdown_InlineSyntax.prototype, {
	__class__: markdown_InlineSyntax
	,pattern: null
});
class markdown_AutolinkSyntaxWithoutBrackets extends markdown_InlineSyntax {
	constructor() {
		super("\\b((http|https|ftp)://[^\\s]*)\\b");
	}
	tryMatch(parser) {
		return super.tryMatch(parser);
	}
	onMatch(parser) {
		let url = this.pattern.matched(1);
		let anchor = markdown_ElementNode.text("a",StringTools.htmlEscape(url));
		anchor.attributes.h["href"] = url;
		parser.addNode(anchor);
		return true;
	}
}
$hxClasses["markdown.AutolinkSyntaxWithoutBrackets"] = markdown_AutolinkSyntaxWithoutBrackets;
markdown_AutolinkSyntaxWithoutBrackets.__name__ = "markdown.AutolinkSyntaxWithoutBrackets";
markdown_AutolinkSyntaxWithoutBrackets.__super__ = markdown_InlineSyntax;
Object.assign(markdown_AutolinkSyntaxWithoutBrackets.prototype, {
	__class__: markdown_AutolinkSyntaxWithoutBrackets
});
class markdown_TextSyntax extends markdown_InlineSyntax {
	constructor(pattern,substitute) {
		super(pattern);
		this.substitute = substitute;
	}
	onMatch(parser) {
		if(this.substitute == null) {
			parser.advanceBy(this.pattern.matched(0).length);
			return false;
		}
		parser.addNode(parser.createText(this.substitute));
		return true;
	}
}
$hxClasses["markdown.TextSyntax"] = markdown_TextSyntax;
markdown_TextSyntax.__name__ = "markdown.TextSyntax";
markdown_TextSyntax.__super__ = markdown_InlineSyntax;
Object.assign(markdown_TextSyntax.prototype, {
	__class__: markdown_TextSyntax
	,substitute: null
});
class markdown_AutolinkSyntax extends markdown_InlineSyntax {
	constructor() {
		super("<((http|https|ftp)://[^>]*)>");
	}
	onMatch(parser) {
		let url = this.pattern.matched(1);
		let anchor = markdown_ElementNode.text("a",StringTools.htmlEscape(url));
		anchor.attributes.h["href"] = url;
		parser.addNode(anchor);
		return true;
	}
}
$hxClasses["markdown.AutolinkSyntax"] = markdown_AutolinkSyntax;
markdown_AutolinkSyntax.__name__ = "markdown.AutolinkSyntax";
markdown_AutolinkSyntax.__super__ = markdown_InlineSyntax;
Object.assign(markdown_AutolinkSyntax.prototype, {
	__class__: markdown_AutolinkSyntax
});
class markdown_TagSyntax extends markdown_InlineSyntax {
	constructor(pattern,tag,end) {
		super(pattern);
		this.tag = tag;
		this.endPattern = new EReg(end == null ? pattern : end,"m");
	}
	onMatch(parser) {
		parser.stack.push(new markdown_TagState(parser.pos,parser.pos + this.pattern.matched(0).length,this));
		return true;
	}
	onMatchEnd(parser,state) {
		parser.addNode(new markdown_ElementNode(this.tag,state.children));
		return true;
	}
}
$hxClasses["markdown.TagSyntax"] = markdown_TagSyntax;
markdown_TagSyntax.__name__ = "markdown.TagSyntax";
markdown_TagSyntax.__super__ = markdown_InlineSyntax;
Object.assign(markdown_TagSyntax.prototype, {
	__class__: markdown_TagSyntax
	,endPattern: null
	,tag: null
});
class markdown_LinkSyntax extends markdown_TagSyntax {
	constructor(linkResolver) {
		super("\\[",null,markdown_LinkSyntax.linkPattern);
		this.linkResolver = linkResolver;
	}
	onMatchEnd(parser,state) {
		let url;
		let title;
		if(this.endPattern.matched(1) == null || this.endPattern.matched(1) == "") {
			if(this.linkResolver == null) {
				return false;
			}
			if(state.children.length != 1) {
				return false;
			}
			if(!((state.children[0]) instanceof markdown_TextNode)) {
				return false;
			}
			let link = state.children[0];
			let node = this.linkResolver(link.text);
			if(node == null) {
				return false;
			}
			parser.addNode(node);
			return true;
		}
		if(this.endPattern.matched(3) != null && this.endPattern.matched(3) != "") {
			url = this.endPattern.matched(3);
			title = this.endPattern.matched(4);
			if(StringTools.startsWith(url,"<") && StringTools.endsWith(url,">")) {
				url = url.substring(1,url.length - 1);
			}
		} else {
			let id = this.endPattern.matched(2);
			if(id == "") {
				id = parser.source.substring(state.startPos + 1,parser.pos);
			}
			id = id.toLowerCase();
			let link = parser.document.refLinks.h[id];
			if(link == null) {
				return false;
			}
			url = link.url;
			title = link.title;
		}
		let anchor = new markdown_ElementNode("a",state.children);
		let this1 = anchor.attributes;
		let value = StringTools.htmlEscape(url);
		this1.h["href"] = value;
		if(title != null && title != "") {
			let this1 = anchor.attributes;
			let value = StringTools.htmlEscape(title);
			this1.h["title"] = value;
		}
		parser.addNode(anchor);
		return true;
	}
}
$hxClasses["markdown.LinkSyntax"] = markdown_LinkSyntax;
markdown_LinkSyntax.__name__ = "markdown.LinkSyntax";
markdown_LinkSyntax.__super__ = markdown_TagSyntax;
Object.assign(markdown_LinkSyntax.prototype, {
	__class__: markdown_LinkSyntax
	,linkResolver: null
});
class markdown_ImgSyntax extends markdown_TagSyntax {
	constructor(linkResolver) {
		super("!\\[",null,markdown_ImgSyntax.linkPattern);
		this.linkResolver = linkResolver;
	}
	onMatchEnd(parser,state) {
		let url;
		let title;
		if(this.endPattern.matched(1) == null || this.endPattern.matched(1) == "") {
			if(this.linkResolver == null) {
				return false;
			}
			if(state.children.length != 1) {
				return false;
			}
			if(!((state.children[0]) instanceof markdown_TextNode)) {
				return false;
			}
			let link = state.children[0];
			let node = this.linkResolver(link.text);
			if(node == null) {
				return false;
			}
			parser.addNode(node);
			return true;
		}
		if(this.endPattern.matched(3) != null && this.endPattern.matched(3) != "") {
			url = this.endPattern.matched(3);
			title = this.endPattern.matched(4);
			if(StringTools.startsWith(url,"<") && StringTools.endsWith(url,">")) {
				url = url.substring(1,url.length - 1);
			}
		} else {
			let id = this.endPattern.matched(2);
			if(id == "") {
				id = parser.source.substring(state.startPos + 1,parser.pos);
			}
			id = id.toLowerCase();
			let link = parser.document.refLinks.h[id];
			if(link == null) {
				return false;
			}
			url = link.url;
			title = link.title;
		}
		let img = new markdown_ElementNode("img",null);
		let this1 = img.attributes;
		let value = StringTools.htmlEscape(url);
		this1.h["src"] = value;
		if(state.children.length == 1 && ((state.children[0]) instanceof markdown_TextNode)) {
			let alt = state.children[0];
			img.attributes.h["alt"] = alt.text;
		}
		if(title != null && title != "") {
			let this1 = img.attributes;
			let value = StringTools.htmlEscape(title);
			this1.h["title"] = value;
		}
		parser.addNode(img);
		return true;
	}
}
$hxClasses["markdown.ImgSyntax"] = markdown_ImgSyntax;
markdown_ImgSyntax.__name__ = "markdown.ImgSyntax";
markdown_ImgSyntax.__super__ = markdown_TagSyntax;
Object.assign(markdown_ImgSyntax.prototype, {
	__class__: markdown_ImgSyntax
	,linkResolver: null
});
class markdown_CodeSyntax extends markdown_InlineSyntax {
	constructor(pattern) {
		super(pattern);
	}
	onMatch(parser) {
		parser.addNode(markdown_ElementNode.text("code",StringTools.htmlEscape(this.pattern.matched(1))));
		return true;
	}
}
$hxClasses["markdown.CodeSyntax"] = markdown_CodeSyntax;
markdown_CodeSyntax.__name__ = "markdown.CodeSyntax";
markdown_CodeSyntax.__super__ = markdown_InlineSyntax;
Object.assign(markdown_CodeSyntax.prototype, {
	__class__: markdown_CodeSyntax
});
class markdown_InlineParser {
	constructor(source,document) {
		this.start = 0;
		this.pos = 0;
		this.source = source;
		this.document = document;
		this.stack = [];
		if(document.inlineSyntaxes != null) {
			this.syntaxes = [];
			let _g = 0;
			let _g1 = document.inlineSyntaxes;
			while(_g < _g1.length) {
				let syntax = _g1[_g];
				++_g;
				this.syntaxes.push(syntax);
			}
			let _g2 = 0;
			let _g3 = markdown_InlineParser.defaultSyntaxes;
			while(_g2 < _g3.length) {
				let syntax = _g3[_g2];
				++_g2;
				this.syntaxes.push(syntax);
			}
		} else {
			this.syntaxes = markdown_InlineParser.defaultSyntaxes;
		}
		let _this = this.syntaxes;
		let x = new markdown_LinkSyntax(document.linkResolver);
		_this.splice(1,0,x);
	}
	parse() {
		this.stack.push(new markdown_TagState(0,0,null));
		while(!this.get_isDone()) {
			let matched = false;
			let _g = 1;
			let _g1 = this.stack.length;
			while(_g < _g1) {
				let i = _g++;
				if(this.stack[this.stack.length - i].tryMatch(this)) {
					matched = true;
					break;
				}
			}
			if(matched) {
				continue;
			}
			let _g2 = 0;
			let _g3 = this.syntaxes;
			while(_g2 < _g3.length) {
				let syntax = _g3[_g2];
				++_g2;
				if(syntax.tryMatch(this)) {
					matched = true;
					break;
				}
			}
			if(matched) {
				continue;
			}
			this.advanceBy(1);
		}
		return this.stack[0].close(this);
	}
	writeText() {
		this.writeTextRange(this.start,this.pos);
		this.start = this.pos;
	}
	writeTextRange(start,end) {
		if(end > start) {
			let text = this.source.substring(start,end);
			let nodes = this.stack[this.stack.length - 1].children;
			if(nodes.length > 0 && ((nodes[nodes.length - 1]) instanceof markdown_TextNode)) {
				let lastNode = nodes[nodes.length - 1];
				let newNode = this.createText("" + lastNode.text + text);
				nodes[nodes.length - 1] = newNode;
			} else {
				nodes.push(this.createText(text));
			}
		}
	}
	createText(text) {
		return new markdown_TextNode(this.unescape(text));
	}
	addNode(node) {
		this.stack[this.stack.length - 1].children.push(node);
	}
	get_currentSource() {
		return this.source.substring(this.pos,this.source.length);
	}
	get_isDone() {
		return this.pos == this.source.length;
	}
	advanceBy(length) {
		this.pos += length;
	}
	consume(length) {
		this.pos += length;
		this.start = this.pos;
	}
	unescape(text) {
		let _this_r = new RegExp("\\\\([\\\\`*_{}\\[\\]()#+-.!])","g".split("u").join(""));
		text = text.replace(_this_r,"$1");
		text = StringTools.replace(text,"\t","    ");
		return text;
	}
}
$hxClasses["markdown.InlineParser"] = markdown_InlineParser;
markdown_InlineParser.__name__ = "markdown.InlineParser";
Object.assign(markdown_InlineParser.prototype, {
	__class__: markdown_InlineParser
	,source: null
	,document: null
	,syntaxes: null
	,pos: null
	,start: null
	,stack: null
});
class markdown_TagState {
	constructor(startPos,endPos,syntax) {
		this.startPos = startPos;
		this.endPos = endPos;
		this.syntax = syntax;
		this.children = [];
	}
	tryMatch(parser) {
		if(this.syntax.endPattern.match(parser.get_currentSource()) && this.syntax.endPattern.matchedPos().pos == 0) {
			this.close(parser);
			return true;
		}
		return false;
	}
	close(parser) {
		let index = parser.stack.indexOf(this);
		let unmatchedTags = parser.stack.splice(index + 1,parser.stack.length - index);
		let _g = 0;
		while(_g < unmatchedTags.length) {
			let unmatched = unmatchedTags[_g];
			++_g;
			parser.writeTextRange(unmatched.startPos,unmatched.endPos);
			let _g1 = 0;
			let _g2 = unmatched.children;
			while(_g1 < _g2.length) {
				let child = _g2[_g1];
				++_g1;
				this.children.push(child);
			}
		}
		parser.writeText();
		parser.stack.pop();
		if(parser.stack.length == 0) {
			return this.children;
		}
		if(this.syntax.onMatchEnd(parser,this)) {
			parser.consume(this.syntax.endPattern.matched(0).length);
		} else {
			parser.start = this.startPos;
			parser.advanceBy(this.syntax.endPattern.matched(0).length);
		}
		return null;
	}
}
$hxClasses["markdown.TagState"] = markdown_TagState;
markdown_TagState.__name__ = "markdown.TagState";
Object.assign(markdown_TagState.prototype, {
	__class__: markdown_TagState
	,startPos: null
	,endPos: null
	,syntax: null
	,children: null
});
class tokentree_ToTokenTreeDef {
	static _new(tok) {
		let this1 = tok;
		return this1;
	}
	static toTokenTreeDef(this1) {
		return this1;
	}
	static fromTokenDef(tok) {
		let tmp;
		switch(tok._hx_index) {
		case 0:
			let k = tok.k;
			tmp = tokentree_TokenTreeDef.Kwd(k);
			break;
		case 1:
			let c = tok.c;
			tmp = tokentree_TokenTreeDef.Const(c);
			break;
		case 2:
			let s = tok.s;
			tmp = tokentree_TokenTreeDef.Sharp(s);
			break;
		case 3:
			let s1 = tok.s;
			tmp = tokentree_TokenTreeDef.Dollar(s1);
			break;
		case 4:
			let op = tok.op;
			tmp = tokentree_TokenTreeDef.Unop(op);
			break;
		case 5:
			let op1 = tok.op;
			tmp = tokentree_TokenTreeDef.Binop(op1);
			break;
		case 6:
			let s2 = tok.s;
			tmp = tokentree_TokenTreeDef.Comment(s2);
			break;
		case 7:
			let s3 = tok.s;
			tmp = tokentree_TokenTreeDef.CommentLine(s3);
			break;
		case 8:
			let s4 = tok.s;
			tmp = tokentree_TokenTreeDef.IntInterval(s4);
			break;
		case 9:
			tmp = tokentree_TokenTreeDef.Semicolon;
			break;
		case 10:
			tmp = tokentree_TokenTreeDef.Dot;
			break;
		case 11:
			tmp = tokentree_TokenTreeDef.DblDot;
			break;
		case 12:
			tmp = tokentree_TokenTreeDef.Arrow;
			break;
		case 13:
			tmp = tokentree_TokenTreeDef.Comma;
			break;
		case 14:
			tmp = tokentree_TokenTreeDef.BkOpen;
			break;
		case 15:
			tmp = tokentree_TokenTreeDef.BkClose;
			break;
		case 16:
			tmp = tokentree_TokenTreeDef.BrOpen;
			break;
		case 17:
			tmp = tokentree_TokenTreeDef.BrClose;
			break;
		case 18:
			tmp = tokentree_TokenTreeDef.POpen;
			break;
		case 19:
			tmp = tokentree_TokenTreeDef.PClose;
			break;
		case 20:
			tmp = tokentree_TokenTreeDef.Question;
			break;
		case 21:
			tmp = tokentree_TokenTreeDef.At;
			break;
		case 22:
			tmp = tokentree_TokenTreeDef.Eof;
			break;
		}
		return tokentree_ToTokenTreeDef._new(tmp);
	}
}
var tokentree_TokenStreamMode = $hxEnums["tokentree.TokenStreamMode"] = { __ename__ : true, __constructs__ : ["Strict","Relaxed"]
	,Strict: {_hx_index:0,__enum__:"tokentree.TokenStreamMode",toString:$estr}
	,Relaxed: {_hx_index:1,__enum__:"tokentree.TokenStreamMode",toString:$estr}
};
class tokentree_TokenStream {
	constructor(tokens,bytes) {
		this.tokens = tokens;
		this.bytes = bytes;
		this.sharpIfStack = [];
		this.tempStore = [];
		this.current = 0;
	}
	hasMore() {
		return this.current < this.tokens.length;
	}
	consumeToken() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("no more tokens");
			case 1:
				return this.createDummyToken(tokentree_TokenTreeDef.CommentLine("auto insert"));
			}
		}
		let token = this.tokens[this.current];
		this.current++;
		let space = "";
		return new tokentree_TokenTree(tokentree_ToTokenTreeDef.toTokenTreeDef(tokentree_ToTokenTreeDef.fromTokenDef(token.tok)),space,token.pos,this.current - 1);
	}
	consumeConstIdent() {
		let _g = this.token();
		switch(_g._hx_index) {
		case 2:
			let _g1 = _g.c;
			if(_g1._hx_index == 3) {
				let _g = _g1.s;
				return this.consumeToken();
			} else {
				switch(tokentree_TokenStream.MODE._hx_index) {
				case 0:
					let s = "bad token " + Std.string(this.token()) + " != Const(CIdent(_))";
					throw haxe_Exception.thrown(this.formatCurrentPos() + ": " + s);
				case 1:
					return this.createDummyToken(tokentree_TokenTreeDef.Const(haxe_macro_Constant.CIdent("autoInsert")));
				}
			}
			break;
		case 4:
			let _g2 = _g.s;
			return this.consumeToken();
		default:
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				let s1 = "bad token " + Std.string(this.token()) + " != Const(CIdent(_))";
				throw haxe_Exception.thrown(this.formatCurrentPos() + ": " + s1);
			case 1:
				return this.createDummyToken(tokentree_TokenTreeDef.Const(haxe_macro_Constant.CIdent("autoInsert")));
			}
		}
	}
	consumeConst() {
		let _g = this.token();
		if(_g._hx_index == 2) {
			let _g1 = _g.c;
			return this.consumeToken();
		} else {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				let s = "bad token " + Std.string(this.token()) + " != Const(_)";
				throw haxe_Exception.thrown(this.formatCurrentPos() + ": " + s);
			case 1:
				return this.createDummyToken(tokentree_TokenTreeDef.Const(haxe_macro_Constant.CString("autoInsert")));
			}
		}
	}
	consumeTokenDef(tokenDef) {
		if(this.is(tokenDef)) {
			return this.consumeToken();
		}
		switch(tokentree_TokenStream.MODE._hx_index) {
		case 0:
			let s = "bad token " + Std.string(this.token()) + " != " + Std.string(tokenDef);
			throw haxe_Exception.thrown(this.formatCurrentPos() + ": " + s);
		case 1:
			return this.createDummyToken(tokenDef);
		}
	}
	consumeToTempStore() {
		this.tempStore.push(this.consumeToken());
	}
	addToTempStore(token) {
		this.tempStore.push(token);
	}
	applyTempStore(parent) {
		while(this.tempStore.length > 0) parent.addChild(this.tempStore.shift());
	}
	getTempStore() {
		return this.tempStore;
	}
	clearTempStore() {
		this.tempStore = [];
	}
	formatCurrentPos() {
		let pos = this.tokens[this.current].pos;
		return new hxparse_Position(pos.file,pos.min,pos.max).format(this.bytes);
	}
	is(tokenDef) {
		if(this.current < 0 || this.current >= this.tokens.length) {
			return false;
		}
		let token = this.tokens[this.current];
		return Type.enumEq(tokenDef,tokentree_ToTokenTreeDef.toTokenTreeDef(tokentree_ToTokenTreeDef.fromTokenDef(token.tok)));
	}
	isSharp() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			return false;
		}
		let token = this.tokens[this.current];
		let _g = token.tok;
		if(_g._hx_index == 2) {
			let _g1 = _g.s;
			return true;
		} else {
			return false;
		}
	}
	isTypedParam() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			return false;
		}
		let index = this.current + 1;
		let token = this.tokens[this.current];
		let _g = token.tok;
		if(_g._hx_index == 5) {
			if(_g.op._hx_index != 9) {
				return false;
			}
		} else {
			return false;
		}
		while(true) {
			token = this.tokens[index++];
			let _g = token.tok;
			switch(_g._hx_index) {
			case 0:
				let _g1 = _g.k;
				break;
			case 1:
				let _g2 = _g.c;
				break;
			case 3:
				let _g3 = _g.s;
				break;
			case 5:
				switch(_g.op._hx_index) {
				case 7:
					return true;
				case 9:
					break;
				default:
					return false;
				}
				break;
			case 10:
				break;
			case 11:
				break;
			case 13:
				break;
			default:
				return false;
			}
		}
	}
	token() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("no more tokens");
			case 1:
				return tokentree_TokenTreeDef.CommentLine("auto insert");
			}
		}
		return tokentree_ToTokenTreeDef.toTokenTreeDef(tokentree_ToTokenTreeDef.fromTokenDef(this.tokens[this.current].tok));
	}
	peekNonCommentToken() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("no more tokens");
			case 1:
				return tokentree_TokenTreeDef.Const(haxe_macro_Constant.CString("auto insert"));
			}
		}
		let index = this.current;
		while(index < this.tokens.length) {
			let token = this.tokens[index++];
			if(haxeparser_Token == null) {
				continue;
			}
			let _g = token.tok;
			switch(_g._hx_index) {
			case 6:
				let _g1 = _g.s;
				break;
			case 7:
				let _g2 = _g.s;
				break;
			default:
				return tokentree_ToTokenTreeDef.toTokenTreeDef(tokentree_ToTokenTreeDef.fromTokenDef(token.tok));
			}
		}
		return tokentree_TokenTreeDef.Root;
	}
	getTokenPos() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			return null;
		}
		return this.tokens[this.current].pos;
	}
	getStreamIndex() {
		return this.current;
	}
	rewindTo(pos) {
		this.current = pos;
	}
	consumeOpGt() {
		let tok = this.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt));
		let _g = this.token();
		if(_g._hx_index == 6) {
			switch(_g.op._hx_index) {
			case 4:
				let assignTok = this.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign));
				return new tokentree_TokenTree(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGte),tok.space + assignTok.space,{ file : tok.pos.file, min : tok.pos.min, max : assignTok.pos.max},tok.index);
			case 7:
				return this.consumeOpShr(tok);
			default:
				return tok;
			}
		} else {
			return tok;
		}
	}
	consumeOpShr(parent) {
		let tok = this.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt));
		let _g = this.token();
		if(_g._hx_index == 6) {
			switch(_g.op._hx_index) {
			case 4:
				let assignTok = this.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign));
				return new tokentree_TokenTree(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpShr)),assignTok.space,{ file : parent.pos.file, min : parent.pos.min, max : assignTok.pos.max},parent.index);
			case 7:
				let innerGt = this.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt));
				if(this.is(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign))) {
					let assignTok = this.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign));
					return new tokentree_TokenTree(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpUShr)),assignTok.space,{ file : parent.pos.file, min : parent.pos.min, max : assignTok.pos.max},parent.index);
				}
				return new tokentree_TokenTree(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpUShr),innerGt.space,{ file : parent.pos.file, min : parent.pos.min, max : innerGt.pos.max},parent.index);
			default:
				return new tokentree_TokenTree(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpShr),tok.space,{ file : parent.pos.file, min : parent.pos.min, max : tok.pos.max},parent.index);
			}
		} else {
			return new tokentree_TokenTree(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpShr),tok.space,{ file : parent.pos.file, min : parent.pos.min, max : tok.pos.max},parent.index);
		}
	}
	consumeOpSub(parent) {
		let tok = this.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpSub));
		let _g = this.token();
		if(_g._hx_index == 2) {
			let _g1 = _g.c;
			switch(_g1._hx_index) {
			case 0:
				let _g2 = _g1.v;
				break;
			case 1:
				let _g3 = _g1.f;
				break;
			default:
				return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
			}
		} else {
			return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
		}
		let previous = this.current - 2;
		if(previous < 0) {
			throw haxe_Exception.thrown("no more tokens");
		}
		let prevTok = this.tokens[previous];
		let _g1 = prevTok.tok;
		switch(_g1._hx_index) {
		case 0:
			switch(_g1.k._hx_index) {
			case 3:case 4:case 5:case 6:case 7:case 10:case 15:case 29:
				break;
			default:
				return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
			}
			break;
		case 4:
			let _g2 = _g1.op;
			break;
		case 5:
			let _g3 = _g1.op;
			break;
		case 8:
			let _g4 = _g1.s;
			break;
		case 9:case 11:case 13:case 14:case 16:case 18:case 20:
			break;
		case 19:
			if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
				return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
			}
			let _g5 = parent.tok;
			if(_g5._hx_index == 1) {
				switch(_g5.k._hx_index) {
				case 3:case 4:case 5:case 6:case 7:case 21:
					break;
				default:
					return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
				}
			} else {
				return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
			}
			break;
		default:
			return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
		}
		let _g6 = this.token();
		if(_g6._hx_index == 2) {
			let _g = _g6.c;
			switch(_g._hx_index) {
			case 0:
				let n = _g.v;
				let $const = this.consumeConst();
				return new tokentree_TokenTree(tokentree_TokenTreeDef.Const(haxe_macro_Constant.CInt("-" + n)),$const.space,{ file : tok.pos.file, min : tok.pos.min, max : $const.pos.max},tok.index);
			case 1:
				let n1 = _g.f;
				let const1 = this.consumeConst();
				return new tokentree_TokenTree(tokentree_TokenTreeDef.Const(haxe_macro_Constant.CFloat("-" + n1)),const1.space,{ file : tok.pos.file, min : tok.pos.min, max : const1.pos.max},tok.index);
			default:
				throw haxe_Exception.thrown("no more tokens");
			}
		} else {
			throw haxe_Exception.thrown("no more tokens");
		}
	}
	pushSharpIf(token) {
		this.sharpIfStack.push(token);
	}
	popSharpIf() {
		let token = this.sharpIfStack.pop();
		if(token == null) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("no more tokens");
			case 1:
				return this.createDummyToken(tokentree_TokenTreeDef.CommentLine("dummy token"));
			}
		}
		return token;
	}
	peekSharpIf() {
		if(this.sharpIfStack.length <= 0) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("no more tokens");
			case 1:
				return this.createDummyToken(tokentree_TokenTreeDef.CommentLine("dummy token"));
			}
		}
		return this.sharpIfStack[this.sharpIfStack.length - 1];
	}
	createDummyToken(tokDef) {
		let pos;
		if(this.current < 0 || this.current >= this.tokens.length) {
			let prevPos = this.tokens[this.tokens.length - 1].pos;
			pos = { min : prevPos.max, max : prevPos.max, file : prevPos.file};
		} else {
			let prevPos = this.tokens[this.current].pos;
			pos = { min : prevPos.min, max : prevPos.min, file : prevPos.file};
		}
		return new tokentree_TokenTree(tokDef,"",pos,-1,true);
	}
}
$hxClasses["tokentree.TokenStream"] = tokentree_TokenStream;
tokentree_TokenStream.__name__ = "tokentree.TokenStream";
Object.assign(tokentree_TokenStream.prototype, {
	__class__: tokentree_TokenStream
	,tokens: null
	,current: null
	,bytes: null
	,sharpIfStack: null
	,tempStore: null
});
class tokentree_TokenStreamProgress {
	constructor(stream) {
		this.stream = stream;
		this.pos = -1;
	}
	streamHasChanged() {
		if(this.pos == -1) {
			this.pos = this.stream.getStreamIndex();
			return true;
		}
		let oldPos = this.pos;
		this.pos = this.stream.getStreamIndex();
		return this.pos != oldPos;
	}
}
$hxClasses["tokentree.TokenStreamProgress"] = tokentree_TokenStreamProgress;
tokentree_TokenStreamProgress.__name__ = "tokentree.TokenStreamProgress";
Object.assign(tokentree_TokenStreamProgress.prototype, {
	__class__: tokentree_TokenStreamProgress
	,stream: null
	,pos: null
});
class tokentree_TokenTree {
	constructor(tok,space,pos,index,inserted) {
		if(inserted == null) {
			inserted = false;
		}
		this.tok = tok;
		this.pos = pos;
		this.index = index;
		this.inserted = inserted;
		this.space = space;
		this.tokenTypeCache = { };
	}
	is(tokenDef) {
		return Type.enumEq(tokenDef,this.tok);
	}
	isCIdent() {
		let _g = this.tok;
		if(_g._hx_index == 2) {
			let _g1 = _g.c;
			if(_g1._hx_index == 3) {
				let _g = _g1.s;
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}
	isCIdentOrCString() {
		let _g = this.tok;
		if(_g._hx_index == 2) {
			let _g1 = _g.c;
			switch(_g1._hx_index) {
			case 2:
				let _g2 = _g1.kind;
				let _g3 = _g1.s;
				return true;
			case 3:
				let _g4 = _g1.s;
				return true;
			default:
				return false;
			}
		} else {
			return false;
		}
	}
	addChild(child) {
		if(child == null) {
			return;
		}
		if(this.children == null) {
			this.children = [];
		}
		if(this.children.length > 0) {
			child.previousSibling = this.children[this.children.length - 1];
			this.children[this.children.length - 1].nextSibling = child;
		}
		this.children.push(child);
		child.parent = this;
	}
	hasChildren() {
		if(this.children == null) {
			return false;
		}
		return this.children.length > 0;
	}
	getFirstChild() {
		if(!this.hasChildren()) {
			return null;
		}
		return this.children[0];
	}
	getLastChild() {
		if(!this.hasChildren()) {
			return null;
		}
		return this.children[this.children.length - 1];
	}
	getPos() {
		if(this.children == null || this.children.length <= 0) {
			return this.pos;
		}
		let fullPos = { file : this.pos.file, min : this.pos.min, max : this.pos.max};
		let childPos;
		let _g = 0;
		let _g1 = this.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			childPos = child.getPos();
			if(childPos.min < fullPos.min) {
				fullPos.min = childPos.min;
			}
			if(childPos.max > fullPos.max) {
				fullPos.max = childPos.max;
			}
		}
		return fullPos;
	}
	filter(searchFor,mode,maxLevel) {
		if(maxLevel == null) {
			maxLevel = 9999;
		}
		return this.filterCallback(function(token,depth) {
			if(depth > maxLevel) {
				return tokentree_FilterResult.SkipSubtree;
			}
			if(token.matchesAny(searchFor)) {
				if(mode == tokentree_TokenFilterMode.All) {
					return tokentree_FilterResult.FoundGoDeeper;
				}
				return tokentree_FilterResult.FoundSkipSubtree;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
	}
	filterCallback(callback) {
		let results = [];
		this.internalFilterCallback(callback,results,0);
		return results;
	}
	internalFilterCallback(callback,results,depth) {
		if(depth == null) {
			depth = 0;
		}
		if(this.tok._hx_index != 0) {
			switch(callback(this,depth)._hx_index) {
			case 0:
				results.push(this);
				return;
			case 1:
				results.push(this);
				break;
			case 2:
				return;
			case 3:
				break;
			}
		}
		if(this.children == null) {
			return;
		}
		let _g = 0;
		let _g1 = this.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			if(_g2._hx_index == 3) {
				let _g = _g2.s;
				child.internalFilterCallback(callback,results,depth);
			} else {
				child.internalFilterCallback(callback,results,depth + 1);
			}
		}
	}
	matchesAny(searchFor) {
		if(searchFor == null || this.tok == tokentree_TokenTreeDef.Root) {
			return false;
		}
		let _g = 0;
		while(_g < searchFor.length) {
			let search = searchFor[_g];
			++_g;
			if(Type.enumEq(this.tok,search)) {
				return true;
			}
		}
		return false;
	}
	toString() {
		return tokentree_TokenTreeDefPrinter.toString(this.tok);
	}
}
$hxClasses["tokentree.TokenTree"] = tokentree_TokenTree;
tokentree_TokenTree.__name__ = "tokentree.TokenTree";
Object.assign(tokentree_TokenTree.prototype, {
	__class__: tokentree_TokenTree
	,tok: null
	,pos: null
	,parent: null
	,previousSibling: null
	,nextSibling: null
	,children: null
	,index: null
	,inserted: null
	,space: null
	,tokenTypeCache: null
});
var tokentree_TokenFilterMode = $hxEnums["tokentree.TokenFilterMode"] = { __ename__ : true, __constructs__ : ["All","First"]
	,All: {_hx_index:0,__enum__:"tokentree.TokenFilterMode",toString:$estr}
	,First: {_hx_index:1,__enum__:"tokentree.TokenFilterMode",toString:$estr}
};
var tokentree_FilterResult = $hxEnums["tokentree.FilterResult"] = { __ename__ : true, __constructs__ : ["FoundSkipSubtree","FoundGoDeeper","SkipSubtree","GoDeeper"]
	,FoundSkipSubtree: {_hx_index:0,__enum__:"tokentree.FilterResult",toString:$estr}
	,FoundGoDeeper: {_hx_index:1,__enum__:"tokentree.FilterResult",toString:$estr}
	,SkipSubtree: {_hx_index:2,__enum__:"tokentree.FilterResult",toString:$estr}
	,GoDeeper: {_hx_index:3,__enum__:"tokentree.FilterResult",toString:$estr}
};
class tokentree_TokenTreeAccessHelper {
	static parent(this1) {
		if(this1 != null) {
			return this1.parent;
		} else {
			return null;
		}
	}
	static previousSibling(this1) {
		if(this1 != null) {
			return this1.previousSibling;
		} else {
			return null;
		}
	}
	static firstChild(this1) {
		if(this1 != null) {
			return this1.getFirstChild();
		} else {
			return null;
		}
	}
	static lastChild(this1) {
		if(this1 != null) {
			return this1.getLastChild();
		} else {
			return null;
		}
	}
	static firstOf(this1,tokenDef) {
		if(this1 == null || this1.children == null) {
			return null;
		}
		let _g = 0;
		let _g1 = this1.children;
		while(_g < _g1.length) {
			let tok = _g1[_g];
			++_g;
			if(tok.is(tokenDef)) {
				return tok;
			}
		}
		return null;
	}
	static lastOf(this1,tokenDef) {
		if(this1 == null || this1.children == null) {
			return null;
		}
		let found = null;
		let _g = 0;
		let _g1 = this1.children;
		while(_g < _g1.length) {
			let tok = _g1[_g];
			++_g;
			if(tok.is(tokenDef)) {
				found = tok;
			}
		}
		return found;
	}
	static child(this1,index) {
		if(this1 != null && this1.children != null) {
			return this1.children[index];
		} else {
			return null;
		}
	}
	static is(this1,tokenDef) {
		if(this1 != null && this1.is(tokenDef)) {
			return this1;
		} else {
			return null;
		}
	}
	static isCIdent(this1) {
		if(this1 != null && this1.isCIdent()) {
			return this1;
		} else {
			return null;
		}
	}
}
class tokentree_TokenTreeBuilder {
	static buildTokenTree(tokens,bytes,entryPoint) {
		if(entryPoint == null) {
			entryPoint = tokentree_TokenTreeEntryPoint.TypeLevel;
		}
		return tokentree_TokenTreeBuilder.buildTokenTreeFromStream(new tokentree_TokenStream(tokens,bytes),entryPoint);
	}
	static buildTokenTreeFromStream(stream,entryPoint) {
		let root = new tokentree_TokenTree(tokentree_TokenTreeDef.Root,"",null,-1);
		switch(entryPoint._hx_index) {
		case 0:
			tokentree_walk_WalkFile.walkFile(stream,root);
			break;
		case 1:
			tokentree_walk_WalkClass.walkClassBody(stream,root);
			break;
		case 2:
			tokentree_walk_WalkStatement.walkStatement(stream,root);
			break;
		case 3:
			tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,root);
			break;
		}
		if(stream.hasMore()) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("invalid token tree structure - found:" + Std.string(stream.token()));
			case 1:
				let progress = new tokentree_TokenStreamProgress(stream);
				while(progress.streamHasChanged()) tokentree_walk_WalkStatement.walkStatement(stream,root);
				if(stream.hasMore()) {
					throw haxe_Exception.thrown("invalid token tree structure - found:" + Std.string(stream.token()));
				}
				break;
			}
		}
		let tempStore = stream.getTempStore();
		switch(tokentree_TokenStream.MODE._hx_index) {
		case 0:
			if(tempStore.length != 0) {
				throw haxe_Exception.thrown("invalid token tree structure - tokens in temp store:" + tempStore.join(", "));
			}
			break;
		case 1:
			let _g = 0;
			while(_g < tempStore.length) {
				let stored = tempStore[_g];
				++_g;
				root.addChild(stored);
			}
			break;
		}
		return root;
	}
}
$hxClasses["tokentree.TokenTreeBuilder"] = tokentree_TokenTreeBuilder;
tokentree_TokenTreeBuilder.__name__ = "tokentree.TokenTreeBuilder";
var tokentree_TokenTreeEntryPoint = $hxEnums["tokentree.TokenTreeEntryPoint"] = { __ename__ : true, __constructs__ : ["TypeLevel","FieldLevel","ExpressionLevel","TypeHintLevel"]
	,TypeLevel: {_hx_index:0,__enum__:"tokentree.TokenTreeEntryPoint",toString:$estr}
	,FieldLevel: {_hx_index:1,__enum__:"tokentree.TokenTreeEntryPoint",toString:$estr}
	,ExpressionLevel: {_hx_index:2,__enum__:"tokentree.TokenTreeEntryPoint",toString:$estr}
	,TypeHintLevel: {_hx_index:3,__enum__:"tokentree.TokenTreeEntryPoint",toString:$estr}
};
var tokentree_TokenTreeDef = $hxEnums["tokentree.TokenTreeDef"] = { __ename__ : true, __constructs__ : ["Root","Kwd","Const","Sharp","Dollar","Unop","Binop","Comment","CommentLine","IntInterval","Semicolon","Dot","DblDot","Arrow","Comma","BkOpen","BkClose","BrOpen","BrClose","POpen","PClose","Question","At","Eof"]
	,Root: {_hx_index:0,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,Kwd: ($_=function(k) { return {_hx_index:1,k:k,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_.__params__ = ["k"],$_)
	,Const: ($_=function(c) { return {_hx_index:2,c:c,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_.__params__ = ["c"],$_)
	,Sharp: ($_=function(s) { return {_hx_index:3,s:s,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,Dollar: ($_=function(s) { return {_hx_index:4,s:s,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,Unop: ($_=function(op) { return {_hx_index:5,op:op,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_.__params__ = ["op"],$_)
	,Binop: ($_=function(op) { return {_hx_index:6,op:op,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_.__params__ = ["op"],$_)
	,Comment: ($_=function(s) { return {_hx_index:7,s:s,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,CommentLine: ($_=function(s) { return {_hx_index:8,s:s,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,IntInterval: ($_=function(s) { return {_hx_index:9,s:s,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,Semicolon: {_hx_index:10,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,Dot: {_hx_index:11,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,DblDot: {_hx_index:12,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,Arrow: {_hx_index:13,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,Comma: {_hx_index:14,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,BkOpen: {_hx_index:15,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,BkClose: {_hx_index:16,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,BrOpen: {_hx_index:17,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,BrClose: {_hx_index:18,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,POpen: {_hx_index:19,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,PClose: {_hx_index:20,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,Question: {_hx_index:21,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,At: {_hx_index:22,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,Eof: {_hx_index:23,__enum__:"tokentree.TokenTreeDef",toString:$estr}
};
class tokentree_TokenTreeDefPrinter {
	static toString(def) {
		switch(def._hx_index) {
		case 0:
			return "<root>";
		case 1:
			let k = def.k;
			return HxOverrides.substr($hxEnums[k.__enum__].__constructs__[k._hx_index],3,null).toLowerCase();
		case 2:
			let _g = def.c;
			switch(_g._hx_index) {
			case 0:
				let s = _g.v;
				return s;
			case 1:
				let s1 = _g.f;
				return s1;
			case 2:
				let _g1 = _g.kind;
				let s2 = _g.s;
				return "\"" + s2 + "\"";
			case 3:
				let s3 = _g.s;
				return s3;
			case 4:
				let opt = _g.opt;
				let r = _g.r;
				return "~/" + r + "/" + opt;
			}
			break;
		case 3:
			let s4 = def.s;
			return "#" + s4;
		case 4:
			let s5 = def.s;
			return "$" + s5;
		case 5:
			let op = def.op;
			return new haxe_macro_Printer("").printUnop(op);
		case 6:
			let op1 = def.op;
			return new haxe_macro_Printer("").printBinop(op1);
		case 7:
			let s6 = def.s;
			return "/*" + s6 + "*/";
		case 8:
			let s7 = def.s;
			return "//" + s7;
		case 9:
			let s8 = def.s;
			return "" + s8 + "...";
		case 10:
			return ";";
		case 11:
			return ".";
		case 12:
			return ":";
		case 13:
			return "->";
		case 14:
			return ",";
		case 15:
			return "[";
		case 16:
			return "]";
		case 17:
			return "{";
		case 18:
			return "}";
		case 19:
			return "(";
		case 20:
			return ")";
		case 21:
			return "?";
		case 22:
			return "@";
		case 23:
			return "<eof>";
		}
	}
}
$hxClasses["tokentree.TokenTreeDefPrinter"] = tokentree_TokenTreeDefPrinter;
tokentree_TokenTreeDefPrinter.__name__ = "tokentree.TokenTreeDefPrinter";
class tokentree_utils_FieldUtils {
	static getFieldType(field,defaultVisibility) {
		if(field == null) {
			return tokentree_utils_TokenFieldType.Unknown;
		}
		let _g = field.tok;
		if(_g._hx_index == 1) {
			switch(_g.k._hx_index) {
			case 0:
				return tokentree_utils_FieldUtils.getFunctionFieldType(field,defaultVisibility);
			case 2:case 41:
				return tokentree_utils_FieldUtils.getVarFieldType(field,defaultVisibility);
			default:
			}
		}
		return tokentree_utils_TokenFieldType.Unknown;
	}
	static getFunctionFieldType(field,defaultVisibility) {
		let access = tokentree_TokenTreeAccessHelper.firstChild(field);
		if(access == null) {
			return tokentree_utils_TokenFieldType.Unknown;
		}
		let name = tokentree_utils_TokenTreeCheckUtils.getName(tokentree_utils_TokenTreeCheckUtils.getNameToken(field));
		let visibility = defaultVisibility;
		let isStatic = false;
		let isInline = false;
		let isOverride = false;
		let isFinal = false;
		let isExtern = false;
		if(access.children != null) {
			let _g = 0;
			let _g1 = access.children;
			_hx_loop1: while(_g < _g1.length) {
				let child = _g1[_g];
				++_g;
				let _g2 = child.tok;
				switch(_g2._hx_index) {
				case 1:
					switch(_g2.k._hx_index) {
					case 17:
						isStatic = true;
						break;
					case 18:
						visibility = tokentree_utils_TokenFieldVisibility.Public;
						break;
					case 19:
						visibility = tokentree_utils_TokenFieldVisibility.Private;
						break;
					case 25:
						isExtern = true;
						break;
					case 30:
						isOverride = true;
						break;
					case 34:
						isInline = true;
						break;
					case 41:
						isFinal = true;
						break;
					default:
					}
					break;
				case 2:
					let _g3 = _g2.c;
					if(_g3._hx_index == 3) {
						if(_g3.s == "final") {
							isFinal = true;
						}
					}
					break;
				case 17:case 19:
					break _hx_loop1;
				default:
				}
			}
		}
		return tokentree_utils_TokenFieldType.Function(name,visibility,isStatic,isInline,isOverride,isFinal,isExtern);
	}
	static getVarFieldType(field,defaultVisibility) {
		let access = tokentree_TokenTreeAccessHelper.firstChild(field);
		if(access == null) {
			return tokentree_utils_TokenFieldType.Unknown;
		}
		let name = tokentree_utils_TokenTreeCheckUtils.getName(tokentree_utils_TokenTreeCheckUtils.getNameToken(field));
		let visibility = defaultVisibility;
		let isStatic = false;
		let isInline = false;
		let isFinal = field.is(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFinal));
		let isExtern = false;
		if(access.children != null) {
			let _g = 0;
			let _g1 = access.children;
			while(_g < _g1.length) {
				let child = _g1[_g];
				++_g;
				let _g2 = child.tok;
				if(_g2._hx_index == 1) {
					switch(_g2.k._hx_index) {
					case 17:
						isStatic = true;
						break;
					case 18:
						visibility = tokentree_utils_TokenFieldVisibility.Public;
						break;
					case 19:
						visibility = tokentree_utils_TokenFieldVisibility.Private;
						break;
					case 25:
						isExtern = true;
						break;
					case 34:
						isInline = true;
						break;
					default:
					}
				}
			}
		}
		access = tokentree_TokenTreeAccessHelper.firstOf(access,tokentree_TokenTreeDef.POpen);
		if(isFinal || access == null) {
			return tokentree_utils_TokenFieldType.Var(name,visibility,isStatic,isInline,isFinal,isExtern);
		}
		let getterAccess = tokentree_utils_FieldUtils.makePropertyAccess(tokentree_TokenTreeAccessHelper.firstChild(access));
		let setterAccess = tokentree_utils_FieldUtils.makePropertyAccess(tokentree_TokenTreeAccessHelper.child(access,1));
		return tokentree_utils_TokenFieldType.Prop(name,visibility,isStatic,getterAccess,setterAccess);
	}
	static makePropertyAccess(accessToken) {
		if(accessToken == null) {
			return tokentree_utils_TokenPropertyAccess.Default;
		}
		let _g = accessToken.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 16:
				return tokentree_utils_TokenPropertyAccess.Default;
			case 32:
				return tokentree_utils_TokenPropertyAccess.DynamicAccess;
			case 36:
				return tokentree_utils_TokenPropertyAccess.NullAccess;
			default:
				return tokentree_utils_TokenPropertyAccess.Default;
			}
			break;
		case 2:
			let _g1 = _g.c;
			if(_g1._hx_index == 3) {
				switch(_g1.s) {
				case "get":
					return tokentree_utils_TokenPropertyAccess.Get;
				case "never":
					return tokentree_utils_TokenPropertyAccess.Never;
				case "set":
					return tokentree_utils_TokenPropertyAccess.Set;
				default:
					return tokentree_utils_TokenPropertyAccess.Default;
				}
			} else {
				return tokentree_utils_TokenPropertyAccess.Default;
			}
			break;
		default:
			return tokentree_utils_TokenPropertyAccess.Default;
		}
	}
}
$hxClasses["tokentree.utils.FieldUtils"] = tokentree_utils_FieldUtils;
tokentree_utils_FieldUtils.__name__ = "tokentree.utils.FieldUtils";
var tokentree_utils_TokenFieldType = $hxEnums["tokentree.utils.TokenFieldType"] = { __ename__ : true, __constructs__ : ["Function","Var","Prop","Unknown"]
	,Function: ($_=function(name,visibility,isStatic,isInline,isOverride,isFinal,isExtern) { return {_hx_index:0,name:name,visibility:visibility,isStatic:isStatic,isInline:isInline,isOverride:isOverride,isFinal:isFinal,isExtern:isExtern,__enum__:"tokentree.utils.TokenFieldType",toString:$estr}; },$_.__params__ = ["name","visibility","isStatic","isInline","isOverride","isFinal","isExtern"],$_)
	,Var: ($_=function(name,visibility,isStatic,isInline,isFinal,isExtern) { return {_hx_index:1,name:name,visibility:visibility,isStatic:isStatic,isInline:isInline,isFinal:isFinal,isExtern:isExtern,__enum__:"tokentree.utils.TokenFieldType",toString:$estr}; },$_.__params__ = ["name","visibility","isStatic","isInline","isFinal","isExtern"],$_)
	,Prop: ($_=function(name,visibility,isStatic,getter,setter) { return {_hx_index:2,name:name,visibility:visibility,isStatic:isStatic,getter:getter,setter:setter,__enum__:"tokentree.utils.TokenFieldType",toString:$estr}; },$_.__params__ = ["name","visibility","isStatic","getter","setter"],$_)
	,Unknown: {_hx_index:3,__enum__:"tokentree.utils.TokenFieldType",toString:$estr}
};
var tokentree_utils_TokenFieldVisibility = $hxEnums["tokentree.utils.TokenFieldVisibility"] = { __ename__ : true, __constructs__ : ["Public","Private"]
	,Public: {_hx_index:0,__enum__:"tokentree.utils.TokenFieldVisibility",toString:$estr}
	,Private: {_hx_index:1,__enum__:"tokentree.utils.TokenFieldVisibility",toString:$estr}
};
var tokentree_utils_TokenPropertyAccess = $hxEnums["tokentree.utils.TokenPropertyAccess"] = { __ename__ : true, __constructs__ : ["Default","NullAccess","Get","Set","DynamicAccess","Never"]
	,Default: {_hx_index:0,__enum__:"tokentree.utils.TokenPropertyAccess",toString:$estr}
	,NullAccess: {_hx_index:1,__enum__:"tokentree.utils.TokenPropertyAccess",toString:$estr}
	,Get: {_hx_index:2,__enum__:"tokentree.utils.TokenPropertyAccess",toString:$estr}
	,Set: {_hx_index:3,__enum__:"tokentree.utils.TokenPropertyAccess",toString:$estr}
	,DynamicAccess: {_hx_index:4,__enum__:"tokentree.utils.TokenPropertyAccess",toString:$estr}
	,Never: {_hx_index:5,__enum__:"tokentree.utils.TokenPropertyAccess",toString:$estr}
};
class tokentree_utils_TokenTreeCheckUtils {
	static isImport(token) {
		let parent = token;
		while(parent != null) {
			if(parent.tok == tokentree_TokenTreeDef.Root) {
				return false;
			}
			let _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 13:
					return true;
				case 25:
					break;
				case 35:
					return true;
				case 40:
					break;
				default:
					return false;
				}
				break;
			case 2:
				let _g1 = _g.c;
				if(_g1._hx_index == 3) {
					let _g = _g1.s;
				} else {
					return false;
				}
				break;
			case 6:
				if(_g.op._hx_index != 23) {
					return false;
				}
				break;
			case 11:
				break;
			default:
				return false;
			}
			parent = parent.parent;
		}
		return false;
	}
	static isTypeParameter(token) {
		let _g = token.tok;
		if(_g._hx_index == 6) {
			switch(_g.op._hx_index) {
			case 7:
				return tokentree_TokenTreeAccessHelper.is(tokentree_TokenTreeAccessHelper.parent(token),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpLt)) != null;
			case 9:
				return tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt)) != null;
			default:
				return false;
			}
		} else {
			return false;
		}
	}
	static isOpGtTypedefExtension(token) {
		let _g = token.tok;
		if(_g._hx_index == 6) {
			if(_g.op._hx_index == 7) {
				return tokentree_TokenTreeAccessHelper.is(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.is(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.is(tokentree_TokenTreeAccessHelper.parent(token),tokentree_TokenTreeDef.BrOpen)),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign))))),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdTypedef)) != null;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}
	static filterOpSub(token) {
		if(token == null) {
			return false;
		}
		let _g = token.tok;
		if(!(_g._hx_index == 6 && _g.op._hx_index == 3)) {
			return false;
		}
		let prev = token.previousSibling;
		if(token.previousSibling == null) {
			prev = token.parent;
		} else {
			prev = tokentree_utils_TokenTreeCheckUtils.getLastToken(token.previousSibling);
			if(prev == null) {
				return false;
			}
		}
		let _g1 = prev.tok;
		switch(_g1._hx_index) {
		case 1:
			switch(_g1.k._hx_index) {
			case 4:
				return true;
			case 5:
				return true;
			case 6:
				return true;
			case 10:
				return true;
			default:
				return false;
			}
			break;
		case 6:
			if(_g1.op._hx_index == 23) {
				return true;
			} else {
				return true;
			}
			break;
		case 12:
			return true;
		case 13:
			return true;
		case 14:
			return true;
		case 15:
			return true;
		case 16:
			return false;
		case 17:
			return true;
		case 18:
			return true;
		case 19:
			return true;
		case 20:
			let pOpen = prev.parent;
			let type = tokentree_utils_TokenTreeCheckUtils.getPOpenType(pOpen);
			switch(type._hx_index) {
			case 0:
				return true;
			case 1:
				return true;
			case 2:
				return false;
			case 3:
				return true;
			case 4:
				return true;
			case 5:
				return true;
			case 6:
				return true;
			case 7:
				return false;
			case 8:
				return true;
			case 9:
				return false;
			}
			break;
		case 21:
			return true;
		default:
			return false;
		}
	}
	static isTernary(token) {
		if(token == null) {
			return false;
		}
		if(token.is(tokentree_TokenTreeDef.DblDot)) {
			return tokentree_utils_TokenTreeCheckUtils.isTernary(token.parent);
		}
		if(!token.is(tokentree_TokenTreeDef.Question)) {
			return false;
		}
		if(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.DblDot) == null) {
			return false;
		}
		if(token.parent == null) {
			return false;
		}
		let _g = token.parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:case 2:
				return false;
			case 41:
				return false;
			default:
				return true;
			}
			break;
		case 2:
			let _g1 = _g.c;
			if(_g1._hx_index == 3) {
				if(_g1.s == "final") {
					return false;
				} else {
					return true;
				}
			} else {
				return true;
			}
			break;
		case 3:
			let _g2 = _g.s;
			return false;
		case 6:
			let _g3 = _g.op;
			return true;
		case 14:
			return false;
		case 19:
			let prev = token.previousSibling;
			if(prev == null) {
				return false;
			}
			let lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(prev);
			if(lastToken == null) {
				return false;
			}
			switch(lastToken.tok._hx_index) {
			case 10:
				return false;
			case 14:
				return false;
			default:
				return true;
			}
			break;
		default:
			return true;
		}
	}
	static isTypeEnumAbstract(type) {
		let _g = type.tok;
		if(_g._hx_index == 1) {
			if(_g.k._hx_index == 39) {
				let name = tokentree_TokenTreeAccessHelper.firstChild(type);
				if(name == null || name.children == null || name.children.length <= 0) {
					return false;
				}
				if(tokentree_TokenTreeAccessHelper.firstOf(name,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdEnum)) != null) {
					return true;
				}
				let _g = 0;
				let _g1 = name.children;
				while(_g < _g1.length) {
					let child = _g1[_g];
					++_g;
					if(!child.is(tokentree_TokenTreeDef.At)) {
						continue;
					}
					let enumTok = tokentree_TokenTreeAccessHelper.is(tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.is(tokentree_TokenTreeAccessHelper.firstChild(child),tokentree_TokenTreeDef.DblDot)),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdEnum));
					if(enumTok == null) {
						continue;
					}
					return true;
				}
			}
		}
		return false;
	}
	static getName(token) {
		if(token == null) {
			return null;
		}
		let _g = token.tok;
		switch(_g._hx_index) {
		case 1:
			if(_g.k._hx_index == 22) {
				return "new";
			} else {
				return null;
			}
			break;
		case 2:
			let _g1 = _g.c;
			if(_g1._hx_index == 3) {
				let ident = _g1.s;
				return ident;
			} else {
				return null;
			}
			break;
		default:
			return null;
		}
	}
	static getNameToken(token) {
		if(tokentree_utils_TokenTreeCheckUtils.isNameToken(token)) {
			return token;
		}
		let nameToken = tokentree_TokenTreeAccessHelper.firstChild(token);
		if(tokentree_utils_TokenTreeCheckUtils.isNameToken(nameToken)) {
			return nameToken;
		}
		nameToken = tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.is(nameToken,tokentree_TokenTreeDef.Question));
		if(tokentree_utils_TokenTreeCheckUtils.isNameToken(nameToken)) {
			return nameToken;
		}
		return null;
	}
	static isNameToken(token) {
		if(token == null) {
			return false;
		}
		let _g = token.tok;
		switch(_g._hx_index) {
		case 1:
			if(_g.k._hx_index == 22) {
				return true;
			} else {
				return false;
			}
			break;
		case 2:
			let _g1 = _g.c;
			if(_g1._hx_index == 3) {
				let _g = _g1.s;
				return true;
			} else {
				return false;
			}
			break;
		default:
			return false;
		}
	}
	static getBrOpenType(token) {
		if(token == null) {
			return tokentree_utils_BrOpenType.Unknown;
		}
		if(token.tokenTypeCache.brOpenType != null) {
			return token.tokenTypeCache.brOpenType;
		}
		let type = tokentree_utils_TokenTreeCheckUtils.determineBrOpenType(token);
		token.tokenTypeCache.brOpenType = type;
		return type;
	}
	static determineBrOpenType(token) {
		if(token == null) {
			return tokentree_utils_BrOpenType.Unknown;
		}
		if(token.parent == null || token.parent.tok == tokentree_TokenTreeDef.Root) {
			return tokentree_utils_TokenTreeCheckUtils.determinBrChildren(token);
		}
		let _g = token.parent.tok;
		switch(_g._hx_index) {
		case 1:
			if(_g.k._hx_index == 10) {
				return tokentree_utils_TokenTreeCheckUtils.determinBrChildren(token);
			}
			break;
		case 2:
			let _g1 = _g.c;
			if(_g1._hx_index == 3) {
				switch(_g1.s) {
				case "from":case "to":
					return tokentree_utils_BrOpenType.AnonType;
				default:
					return tokentree_utils_BrOpenType.Block;
				}
			} else {
				return tokentree_utils_BrOpenType.Block;
			}
			break;
		case 4:
			let _g2 = _g.s;
			return tokentree_utils_BrOpenType.Block;
		case 6:
			switch(_g.op._hx_index) {
			case 4:
				if(tokentree_utils_TokenTreeCheckUtils.isInsideTypedef(token.parent)) {
					return tokentree_utils_BrOpenType.TypedefDecl;
				}
				return tokentree_utils_TokenTreeCheckUtils.determinBrChildren(token);
			case 9:
				return tokentree_utils_BrOpenType.AnonType;
			default:
				return tokentree_utils_BrOpenType.ObjectDecl;
			}
			break;
		case 12:
			if(tokentree_utils_TokenTreeCheckUtils.isTernary(token.parent)) {
				return tokentree_utils_BrOpenType.ObjectDecl;
			}
			let parent = token.parent.parent;
			let _g3 = parent.tok;
			switch(_g3._hx_index) {
			case 1:
				switch(_g3.k._hx_index) {
				case 15:
					return tokentree_utils_BrOpenType.ObjectDecl;
				case 16:
					return tokentree_utils_BrOpenType.ObjectDecl;
				default:
					return tokentree_utils_BrOpenType.AnonType;
				}
				break;
			case 2:
				let _g4 = _g3.c;
				switch(_g4._hx_index) {
				case 2:
					let _g5 = _g4.kind;
					let _g6 = _g4.s;
					break;
				case 3:
					let _g7 = _g4.s;
					break;
				default:
					return tokentree_utils_BrOpenType.AnonType;
				}
				break;
			default:
				return tokentree_utils_BrOpenType.AnonType;
			}
			parent = parent.parent;
			let _g8 = parent.tok;
			switch(_g8._hx_index) {
			case 1:
				switch(_g8.k._hx_index) {
				case 0:
					return tokentree_utils_BrOpenType.AnonType;
				case 2:
					return tokentree_utils_BrOpenType.AnonType;
				case 41:
					return tokentree_utils_BrOpenType.AnonType;
				default:
					return tokentree_utils_BrOpenType.ObjectDecl;
				}
				break;
			case 2:
				let _g9 = _g8.c;
				if(_g9._hx_index == 3) {
					if(_g9.s == "final") {
						return tokentree_utils_BrOpenType.AnonType;
					} else {
						return tokentree_utils_BrOpenType.ObjectDecl;
					}
				} else {
					return tokentree_utils_BrOpenType.ObjectDecl;
				}
				break;
			case 6:
				if(_g8.op._hx_index == 9) {
					return tokentree_utils_BrOpenType.AnonType;
				} else {
					return tokentree_utils_BrOpenType.ObjectDecl;
				}
				break;
			case 17:
				return tokentree_utils_TokenTreeCheckUtils.getBrOpenType(parent);
			case 19:
				return tokentree_utils_BrOpenType.AnonType;
			case 21:
				return tokentree_utils_BrOpenType.AnonType;
			default:
				return tokentree_utils_BrOpenType.ObjectDecl;
			}
			break;
		case 15:
			return tokentree_utils_BrOpenType.ObjectDecl;
		case 19:
			let pOpenType = tokentree_utils_TokenTreeCheckUtils.getPOpenType(token.parent);
			switch(pOpenType._hx_index) {
			case 0:
				return tokentree_utils_BrOpenType.ObjectDecl;
			case 1:
				return tokentree_utils_BrOpenType.AnonType;
			case 2:
				return tokentree_utils_BrOpenType.ObjectDecl;
			case 3:
				return tokentree_utils_BrOpenType.Unknown;
			case 4:
				return tokentree_utils_BrOpenType.Unknown;
			case 5:
				return tokentree_utils_BrOpenType.Unknown;
			case 6:
				return tokentree_utils_BrOpenType.Unknown;
			case 7:
				return tokentree_utils_BrOpenType.Unknown;
			case 8:
				return tokentree_utils_BrOpenType.Unknown;
			case 9:
				return tokentree_utils_BrOpenType.ObjectDecl;
			}
			break;
		case 21:
			if(tokentree_utils_TokenTreeCheckUtils.isTernary(token.parent)) {
				return tokentree_utils_BrOpenType.ObjectDecl;
			}
			break;
		default:
		}
		return tokentree_utils_TokenTreeCheckUtils.determinBrChildren(token);
	}
	static determinBrChildren(token) {
		if(token.children == null || token.children.length <= 0) {
			let _g = token.parent.tok;
			if(_g._hx_index == 1) {
				let _g1 = _g.k;
				return tokentree_utils_BrOpenType.Block;
			} else {
				return tokentree_utils_BrOpenType.ObjectDecl;
			}
		}
		if(token.parent != null && token.parent.tok != tokentree_TokenTreeDef.Root) {
			if(token.children.length == 1) {
				let _g = token.parent.tok;
				if(_g._hx_index == 1) {
					let _g1 = _g.k;
					return tokentree_utils_BrOpenType.Block;
				} else {
					return tokentree_utils_BrOpenType.ObjectDecl;
				}
			}
			if(token.children.length == 2 && token.getLastChild().is(tokentree_TokenTreeDef.Semicolon)) {
				let _g = token.parent.tok;
				if(_g._hx_index == 1) {
					let _g1 = _g.k;
					return tokentree_utils_BrOpenType.Block;
				} else {
					return tokentree_utils_BrOpenType.ObjectDecl;
				}
			}
		}
		if(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Arrow) != null) {
			return tokentree_utils_BrOpenType.AnonType;
		}
		if(token.nextSibling != null && token.nextSibling.is(tokentree_TokenTreeDef.Arrow)) {
			return tokentree_utils_BrOpenType.AnonType;
		}
		let onlyComment = true;
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			switch(_g2._hx_index) {
			case 2:
				let _g3 = _g2.c;
				switch(_g3._hx_index) {
				case 2:
					let _g4 = _g3.kind;
					let _g5 = _g3.s;
					if(tokentree_TokenTreeAccessHelper.is(tokentree_TokenTreeAccessHelper.firstChild(child),tokentree_TokenTreeDef.DblDot) == null) {
						return tokentree_utils_BrOpenType.Block;
					}
					onlyComment = false;
					break;
				case 3:
					let _g6 = _g3.s;
					if(tokentree_TokenTreeAccessHelper.is(tokentree_TokenTreeAccessHelper.firstChild(child),tokentree_TokenTreeDef.DblDot) == null) {
						return tokentree_utils_BrOpenType.Block;
					}
					onlyComment = false;
					break;
				default:
					return tokentree_utils_BrOpenType.Block;
				}
				break;
			case 3:
				let _g7 = _g2.s;
				break;
			case 7:
				let _g8 = _g2.s;
				break;
			case 8:
				let _g9 = _g2.s;
				break;
			case 18:
				if(onlyComment) {
					if(token.parent != null && token.parent.tok != tokentree_TokenTreeDef.Root) {
						let _g = token.parent.tok;
						if(_g._hx_index == 1) {
							let _g1 = _g.k;
							return tokentree_utils_BrOpenType.Block;
						} else {
							return tokentree_utils_BrOpenType.ObjectDecl;
						}
					} else {
						return tokentree_utils_BrOpenType.ObjectDecl;
					}
				}
				return tokentree_utils_BrOpenType.ObjectDecl;
			default:
				return tokentree_utils_BrOpenType.Block;
			}
		}
		return tokentree_utils_BrOpenType.ObjectDecl;
	}
	static getPOpenType(token) {
		if(token == null) {
			return tokentree_utils_POpenType.Expression;
		}
		switch(token.tok._hx_index) {
		case 19:
			break;
		case 20:
			return tokentree_utils_TokenTreeCheckUtils.getPOpenType(token.parent);
		default:
			return tokentree_utils_POpenType.Expression;
		}
		if(token.tokenTypeCache.pOpenType != null) {
			return token.tokenTypeCache.pOpenType;
		}
		let type = tokentree_utils_TokenTreeCheckUtils.determinePOpenType(token);
		token.tokenTypeCache.pOpenType = type;
		return type;
	}
	static determinePOpenType(token) {
		let parent = token.parent;
		if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
			return tokentree_utils_POpenType.Expression;
		}
		if(tokentree_utils_TokenTreeCheckUtils.hasAtParent(token)) {
			return tokentree_utils_POpenType.At;
		}
		let lastChild = token.getLastChild();
		if(lastChild != null) {
			if(lastChild.tok._hx_index == 13) {
				return tokentree_utils_POpenType.Parameter;
			}
		}
		_hx_loop1: while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) {
			let _g = parent.tok;
			switch(_g._hx_index) {
			case 3:
				switch(_g.s) {
				case "elseif":case "if":
					if(parent.getFirstChild() == token) {
						return tokentree_utils_POpenType.SharpCondition;
					}
					parent = parent.parent;
					break;
				default:
					break _hx_loop1;
				}
				break;
			case 6:
				if(_g.op._hx_index == 9) {
					parent = parent.parent;
				} else {
					break _hx_loop1;
				}
				break;
			default:
				break _hx_loop1;
			}
		}
		if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
			return tokentree_utils_POpenType.Expression;
		}
		let _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				return tokentree_utils_POpenType.Parameter;
			case 3:
				let firstChild = parent.getFirstChild();
				if(firstChild == null) {
					return tokentree_utils_POpenType.IfCondition;
				}
				if(firstChild.index == token.index) {
					return tokentree_utils_POpenType.IfCondition;
				}
				return tokentree_utils_POpenType.Expression;
			case 5:
				return tokentree_utils_POpenType.WhileCondition;
			case 7:
				return tokentree_utils_POpenType.ForLoop;
			case 14:
				return tokentree_utils_POpenType.SwitchCondition;
			case 21:
				return tokentree_utils_POpenType.Catch;
			case 22:
				return tokentree_utils_POpenType.Parameter;
			default:
			}
			break;
		case 2:
			let _g1 = _g.c;
			if(_g1._hx_index == 3) {
				let _g = _g1.s;
				if(parent.parent == null || parent.parent.tok == tokentree_TokenTreeDef.Root) {
					return tokentree_utils_POpenType.Call;
				}
				let _g2 = parent.parent.tok;
				switch(_g2._hx_index) {
				case 1:
					switch(_g2.k._hx_index) {
					case 0:
						if(parent.previousSibling == null) {
							return tokentree_utils_POpenType.Parameter;
						}
						return tokentree_utils_POpenType.Call;
					case 39:
						return tokentree_utils_POpenType.Parameter;
					default:
						return tokentree_utils_POpenType.Call;
					}
					break;
				case 17:
					if(tokentree_TokenTreeAccessHelper.is(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.parent(parent.parent)),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdEnum)) != null) {
						return tokentree_utils_POpenType.Parameter;
					}
					return tokentree_utils_POpenType.Call;
				default:
					return tokentree_utils_POpenType.Call;
				}
			}
			break;
		case 19:
			return tokentree_utils_POpenType.Expression;
		default:
		}
		if(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Arrow) != null) {
			return tokentree_utils_POpenType.Parameter;
		}
		return tokentree_utils_POpenType.Expression;
	}
	static hasAtParent(token) {
		let parent = token.parent;
		while(parent.tok != tokentree_TokenTreeDef.Root) {
			let _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				let _g1 = _g.k;
				break;
			case 2:
				let _g2 = _g.c;
				break;
			case 6:
				if(_g.op._hx_index != 23) {
					return false;
				}
				break;
			case 11:
				break;
			case 12:
				break;
			case 22:
				return true;
			default:
				return false;
			}
			parent = parent.parent;
		}
		return false;
	}
	static isInsideTypedef(token) {
		if(token == null) {
			return false;
		}
		let parent = token;
		while(parent.parent != null) {
			if(parent.is(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdTypedef))) {
				return true;
			}
			parent = parent.parent;
		}
		return false;
	}
	static getArrowType(token) {
		if(token == null) {
			return tokentree_utils_ArrowType.ArrowFunction;
		}
		if(token.tokenTypeCache.arrowType != null) {
			return token.tokenTypeCache.arrowType;
		}
		let type = tokentree_utils_TokenTreeCheckUtils.determineArrowType(token);
		if(type == null) {
			type = tokentree_utils_ArrowType.ArrowFunction;
		}
		token.tokenTypeCache.arrowType = type;
		return type;
	}
	static determineArrowType(token) {
		if(token == null) {
			return tokentree_utils_ArrowType.ArrowFunction;
		}
		let child = token.getFirstChild();
		while(child != null) {
			let _g = child.tok;
			switch(_g._hx_index) {
			case 1:
				if(_g.k._hx_index != 40) {
					return tokentree_utils_ArrowType.ArrowFunction;
				}
				break;
			case 2:
				let _g1 = _g.c;
				if(_g1._hx_index == 3) {
					let _g = _g1.s;
				} else {
					return tokentree_utils_ArrowType.ArrowFunction;
				}
				break;
			case 6:
				if(_g.op._hx_index == 9) {
					child = child.nextSibling;
					continue;
				} else {
					return tokentree_utils_ArrowType.ArrowFunction;
				}
				break;
			case 7:
				let _g2 = _g.s;
				break;
			case 8:
				let _g3 = _g.s;
				break;
			case 10:case 11:case 13:case 21:
				break;
			case 17:
				let brClose = child.getFirstChild();
				if(brClose.is(tokentree_TokenTreeDef.BrClose)) {
					return tokentree_utils_ArrowType.ArrowFunction;
				}
				let brType = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(child);
				if(brType == null) {
					brType = tokentree_utils_BrOpenType.Unknown;
				}
				if(brType != null) {
					switch(brType._hx_index) {
					case 0:
						return tokentree_utils_ArrowType.ArrowFunction;
					case 3:
						break;
					default:
					}
				}
				child = child.nextSibling;
				continue;
			case 19:
				break;
			default:
				return tokentree_utils_ArrowType.ArrowFunction;
			}
			child = child.getFirstChild();
		}
		let parent = token.parent;
		if(parent == null) {
			return tokentree_utils_ArrowType.ArrowFunction;
		}
		let resultType = tokentree_utils_TokenTreeCheckUtils.checkArrowParent(parent);
		if(resultType != null) {
			return resultType;
		}
		return tokentree_utils_TokenTreeCheckUtils.checkArrowChildren(parent);
	}
	static checkArrowChildren(parent) {
		let child = parent.getFirstChild();
		if(child == null) {
			return tokentree_utils_ArrowType.ArrowFunction;
		}
		let seenArrow = false;
		while(child != null) {
			let _g = child.tok;
			switch(_g._hx_index) {
			case 1:
				let _g1 = _g.k;
				return tokentree_utils_ArrowType.ArrowFunction;
			case 2:
				let _g2 = _g.c;
				if(_g2._hx_index == 3) {
					let _g = _g2.s;
				} else {
					return tokentree_utils_ArrowType.NewFunctionType;
				}
				break;
			case 6:
				if(_g.op._hx_index == 9) {
					child = child.nextSibling;
					continue;
				} else {
					return tokentree_utils_ArrowType.NewFunctionType;
				}
				break;
			case 7:
				let _g3 = _g.s;
				break;
			case 8:
				let _g4 = _g.s;
				break;
			case 10:case 11:
				break;
			case 12:case 17:
				break;
			case 13:
				seenArrow = true;
				break;
			case 19:
				let result = tokentree_utils_TokenTreeCheckUtils.checkArrowPOpen(child);
				if(result != null) {
					return result;
				}
				child = child.nextSibling;
				continue;
			case 20:
				break;
			case 21:
				break;
			default:
				return tokentree_utils_ArrowType.NewFunctionType;
			}
			child = child.getFirstChild();
		}
		if(seenArrow) {
			return tokentree_utils_ArrowType.OldFunctionType;
		}
		return tokentree_utils_ArrowType.NewFunctionType;
	}
	static checkArrowPOpen(token) {
		if(token.children == null || token.children.length <= 1) {
			return null;
		}
		if(token.parent.isCIdent()) {
			return tokentree_utils_ArrowType.ArrowFunction;
		}
		let childArrows = token.filter([tokentree_TokenTreeDef.Arrow],tokentree_TokenFilterMode.All);
		if(childArrows.length <= 0) {
			return tokentree_utils_ArrowType.ArrowFunction;
		}
		let childArrows1 = token.filter([tokentree_TokenTreeDef.DblDot],tokentree_TokenFilterMode.All);
		if(childArrows1.length > 0) {
			return tokentree_utils_ArrowType.NewFunctionType;
		}
		return tokentree_utils_ArrowType.OldFunctionType;
	}
	static checkArrowParent(parent) {
		if(parent == null) {
			return tokentree_utils_ArrowType.ArrowFunction;
		}
		let _g = parent.tok;
		switch(_g._hx_index) {
		case 2:
			let _g1 = _g.c;
			if(_g1._hx_index == 3) {
				let _g = _g1.s;
				if(parent.parent == null || parent.parent.tok == tokentree_TokenTreeDef.Root) {
					return tokentree_utils_ArrowType.ArrowFunction;
				}
				let _g2 = parent.parent.tok;
				switch(_g2._hx_index) {
				case 6:
					switch(_g2.op._hx_index) {
					case 4:
						if(tokentree_utils_TokenTreeCheckUtils.isInsideTypedef(parent.parent)) {
							return tokentree_utils_ArrowType.OldFunctionType;
						}
						return tokentree_utils_ArrowType.ArrowFunction;
					case 22:
						return tokentree_utils_ArrowType.ArrowFunction;
					default:
					}
					break;
				case 12:
					let type = tokentree_utils_TokenTreeCheckUtils.getColonType(parent.parent);
					switch(type._hx_index) {
					case 1:
						return tokentree_utils_ArrowType.OldFunctionType;
					case 2:
						return tokentree_utils_ArrowType.OldFunctionType;
					case 0:case 3:case 4:case 5:case 6:
						return tokentree_utils_ArrowType.ArrowFunction;
					}
					break;
				case 13:
					return tokentree_utils_ArrowType.OldFunctionType;
				case 19:
					let type1 = tokentree_utils_TokenTreeCheckUtils.getPOpenType(parent.parent);
					if(type1 == null) {
						type1 = tokentree_utils_POpenType.Expression;
					}
					switch(type1._hx_index) {
					case 1:
						return tokentree_utils_ArrowType.OldFunctionType;
					case 9:
						return tokentree_utils_ArrowType.OldFunctionType;
					default:
						return tokentree_utils_ArrowType.ArrowFunction;
					}
					break;
				default:
				}
			} else {
				return tokentree_utils_ArrowType.OldFunctionType;
			}
			break;
		case 19:
			break;
		default:
			return tokentree_utils_ArrowType.OldFunctionType;
		}
		return null;
	}
	static getColonType(token) {
		if(token == null) {
			return tokentree_utils_ColonType.Unknown;
		}
		if(token.tokenTypeCache.colonType != null) {
			return token.tokenTypeCache.colonType;
		}
		let type = tokentree_utils_TokenTreeCheckUtils.determineColonType(token);
		token.tokenTypeCache.colonType = type;
		return type;
	}
	static determineColonType(token) {
		if(token == null) {
			return tokentree_utils_ColonType.Unknown;
		}
		if(tokentree_utils_TokenTreeCheckUtils.isTernary(token)) {
			return tokentree_utils_ColonType.Ternary;
		}
		let parent = token.parent;
		if(parent == null) {
			return tokentree_utils_ColonType.Unknown;
		}
		let _g = parent.tok;
		if(_g._hx_index == 3) {
			let _g1 = _g.s;
			parent = parent.parent;
			if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
				return tokentree_utils_ColonType.Unknown;
			}
		}
		let _g1 = parent.tok;
		switch(_g1._hx_index) {
		case 1:
			switch(_g1.k._hx_index) {
			case 0:
				return tokentree_utils_ColonType.TypeHint;
			case 15:case 16:
				return tokentree_utils_ColonType.SwitchCase;
			case 22:
				return tokentree_utils_TokenTreeCheckUtils.findColonParent(parent);
			case 23:
				return tokentree_utils_TokenTreeCheckUtils.findColonParent(parent);
			default:
			}
			break;
		case 2:
			let _g2 = _g1.c;
			return tokentree_utils_TokenTreeCheckUtils.findColonParent(parent);
		case 6:
			if(_g1.op._hx_index == 9) {
				return tokentree_utils_TokenTreeCheckUtils.findColonParent(parent);
			}
			break;
		case 17:
			let brClose = tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.BrClose);
			if(brClose == null) {
				return tokentree_utils_ColonType.Unknown;
			}
			if(brClose.pos.max <= token.pos.min) {
				return tokentree_utils_ColonType.TypeCheck;
			}
			break;
		case 19:
			return tokentree_utils_TokenTreeCheckUtils.findColonParent(token);
		case 21:
			return tokentree_utils_TokenTreeCheckUtils.findColonParent(parent);
		case 22:
			return tokentree_utils_ColonType.At;
		default:
		}
		return tokentree_utils_ColonType.Unknown;
	}
	static findColonParent(token) {
		let parent = token;
		while(parent.tok != tokentree_TokenTreeDef.Root) {
			let _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:case 2:
					return tokentree_utils_ColonType.TypeHint;
				case 41:
					return tokentree_utils_ColonType.TypeHint;
				default:
				}
				break;
			case 2:
				let _g1 = _g.c;
				if(_g1._hx_index == 3) {
					if(_g1.s == "final") {
						return tokentree_utils_ColonType.TypeHint;
					}
				}
				break;
			case 17:
				let brType = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(parent);
				switch(brType._hx_index) {
				case 0:
					return tokentree_utils_ColonType.Unknown;
				case 1:
					return tokentree_utils_ColonType.TypeHint;
				case 2:
					return tokentree_utils_ColonType.ObjectLiteral;
				case 3:
					return tokentree_utils_ColonType.TypeHint;
				case 4:
					return tokentree_utils_ColonType.Unknown;
				}
				break;
			case 19:
				let pClose = tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.PClose);
				if(pClose != null && pClose.pos.max <= token.pos.min) {
					return tokentree_utils_ColonType.TypeCheck;
				}
				let pType = tokentree_utils_TokenTreeCheckUtils.getPOpenType(parent);
				switch(pType._hx_index) {
				case 0:
					return tokentree_utils_ColonType.ObjectLiteral;
				case 1:
					return tokentree_utils_ColonType.TypeHint;
				case 2:
					return tokentree_utils_ColonType.Unknown;
				case 3:
					return tokentree_utils_ColonType.TypeCheck;
				case 4:
					return tokentree_utils_ColonType.Unknown;
				case 5:
					return tokentree_utils_ColonType.Unknown;
				case 6:
					return tokentree_utils_ColonType.Unknown;
				case 7:
					return tokentree_utils_ColonType.Unknown;
				case 8:
					return tokentree_utils_ColonType.TypeCheck;
				case 9:
					return tokentree_utils_ColonType.TypeCheck;
				}
				break;
			default:
			}
			parent = parent.parent;
		}
		return tokentree_utils_ColonType.Unknown;
	}
	static getLastToken(token) {
		if(token == null) {
			return null;
		}
		if(token.children == null) {
			return token;
		}
		if(token.children.length <= 0) {
			return token;
		}
		let lastChild = token.getLastChild();
		while(lastChild != null) {
			let newLast = lastChild.getLastChild();
			if(newLast == null) {
				return lastChild;
			}
			lastChild = newLast;
		}
		return null;
	}
	static isMetadata(token) {
		if(token == null || token.tok == tokentree_TokenTreeDef.Root) {
			return false;
		}
		let parent = token.parent;
		while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) switch(parent.tok._hx_index) {
		case 12:
			parent = parent.parent;
			if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
				return false;
			}
			if(parent.tok._hx_index == 22) {
				return true;
			} else {
				return false;
			}
			break;
		case 22:
			return true;
		default:
			parent = parent.parent;
		}
		return false;
	}
}
$hxClasses["tokentree.utils.TokenTreeCheckUtils"] = tokentree_utils_TokenTreeCheckUtils;
tokentree_utils_TokenTreeCheckUtils.__name__ = "tokentree.utils.TokenTreeCheckUtils";
var tokentree_utils_BrOpenType = $hxEnums["tokentree.utils.BrOpenType"] = { __ename__ : true, __constructs__ : ["Block","TypedefDecl","ObjectDecl","AnonType","Unknown"]
	,Block: {_hx_index:0,__enum__:"tokentree.utils.BrOpenType",toString:$estr}
	,TypedefDecl: {_hx_index:1,__enum__:"tokentree.utils.BrOpenType",toString:$estr}
	,ObjectDecl: {_hx_index:2,__enum__:"tokentree.utils.BrOpenType",toString:$estr}
	,AnonType: {_hx_index:3,__enum__:"tokentree.utils.BrOpenType",toString:$estr}
	,Unknown: {_hx_index:4,__enum__:"tokentree.utils.BrOpenType",toString:$estr}
};
var tokentree_utils_POpenType = $hxEnums["tokentree.utils.POpenType"] = { __ename__ : true, __constructs__ : ["At","Parameter","Call","SwitchCondition","WhileCondition","IfCondition","SharpCondition","Catch","ForLoop","Expression"]
	,At: {_hx_index:0,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,Parameter: {_hx_index:1,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,Call: {_hx_index:2,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,SwitchCondition: {_hx_index:3,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,WhileCondition: {_hx_index:4,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,IfCondition: {_hx_index:5,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,SharpCondition: {_hx_index:6,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,Catch: {_hx_index:7,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,ForLoop: {_hx_index:8,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,Expression: {_hx_index:9,__enum__:"tokentree.utils.POpenType",toString:$estr}
};
var tokentree_utils_ArrowType = $hxEnums["tokentree.utils.ArrowType"] = { __ename__ : true, __constructs__ : ["ArrowFunction","OldFunctionType","NewFunctionType"]
	,ArrowFunction: {_hx_index:0,__enum__:"tokentree.utils.ArrowType",toString:$estr}
	,OldFunctionType: {_hx_index:1,__enum__:"tokentree.utils.ArrowType",toString:$estr}
	,NewFunctionType: {_hx_index:2,__enum__:"tokentree.utils.ArrowType",toString:$estr}
};
var tokentree_utils_ColonType = $hxEnums["tokentree.utils.ColonType"] = { __ename__ : true, __constructs__ : ["SwitchCase","TypeHint","TypeCheck","Ternary","ObjectLiteral","At","Unknown"]
	,SwitchCase: {_hx_index:0,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,TypeHint: {_hx_index:1,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,TypeCheck: {_hx_index:2,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,Ternary: {_hx_index:3,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,ObjectLiteral: {_hx_index:4,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,At: {_hx_index:5,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,Unknown: {_hx_index:6,__enum__:"tokentree.utils.ColonType",toString:$estr}
};
class tokentree_walk_WalkAbstract {
	static walkAbstract(stream,parent) {
		let typeTok = stream.consumeToken();
		parent.addChild(typeTok);
		let name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
		stream.applyTempStore(name);
		if(stream.is(tokentree_TokenTreeDef.POpen)) {
			tokentree_walk_WalkPOpen.walkPOpen(stream,name);
		}
		let typeParent = name;
		let typeChild;
		let progress = new tokentree_TokenStreamProgress(stream);
		_hx_loop1: while(progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 2:
				let _g1 = _g.c;
				if(_g1._hx_index == 3) {
					switch(_g1.s) {
					case "from":case "to":
						let fromToken = stream.consumeToken();
						name.addChild(fromToken);
						tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,fromToken);
						break;
					default:
						typeChild = stream.consumeToken();
						typeParent.addChild(typeChild);
						typeParent = typeChild;
					}
				} else {
					typeChild = stream.consumeToken();
					typeParent.addChild(typeChild);
					typeParent = typeChild;
				}
				break;
			case 7:
				let _g2 = _g.s;
				name.addChild(stream.consumeToken());
				break;
			case 8:
				let _g3 = _g.s;
				name.addChild(stream.consumeToken());
				break;
			case 17:
				break _hx_loop1;
			default:
				typeChild = stream.consumeToken();
				typeParent.addChild(typeChild);
				typeParent = typeChild;
			}
		}
		let block = stream.consumeTokenDef(tokentree_TokenTreeDef.BrOpen);
		name.addChild(block);
		tokentree_walk_WalkAbstract.walkAbstractBody(stream,block);
		block.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BrClose));
	}
	static walkAbstractBody(stream,parent) {
		let progress = new tokentree_TokenStreamProgress(stream);
		_hx_loop1: while(progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:
					tokentree_walk_WalkFunction.walkFunction(stream,parent);
					break;
				case 2:
					tokentree_walk_WalkVar.walkVar(stream,parent);
					break;
				case 41:
					tokentree_walk_WalkFinal.walkFinal(stream,parent);
					break;
				default:
					stream.consumeToTempStore();
				}
				break;
			case 2:
				let _g1 = _g.c;
				if(_g1._hx_index == 3) {
					if(_g1.s == "final") {
						tokentree_walk_WalkFinal.walkFinal(stream,parent);
					} else {
						stream.consumeToTempStore();
					}
				} else {
					stream.consumeToTempStore();
				}
				break;
			case 3:
				let _g2 = _g.s;
				tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkAbstract.walkAbstractBody);
				break;
			case 7:
				let _g3 = _g.s;
				parent.addChild(stream.consumeToken());
				break;
			case 8:
				let _g4 = _g.s;
				parent.addChild(stream.consumeToken());
				break;
			case 10:
				parent.addChild(stream.consumeToken());
				break;
			case 18:
				break _hx_loop1;
			case 22:
				stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
				break;
			default:
				stream.consumeToTempStore();
			}
		}
		stream.applyTempStore(parent);
	}
}
$hxClasses["tokentree.walk.WalkAbstract"] = tokentree_walk_WalkAbstract;
tokentree_walk_WalkAbstract.__name__ = "tokentree.walk.WalkAbstract";
class tokentree_walk_WalkArrayAccess {
	static walkArrayAccess(stream,parent) {
		let bkOpen = stream.consumeTokenDef(tokentree_TokenTreeDef.BkOpen);
		parent.addChild(bkOpen);
		stream.applyTempStore(bkOpen);
		let progress = new tokentree_TokenStreamProgress(stream);
		_hx_loop1: while(progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:
					tokentree_walk_WalkFunction.walkFunction(stream,bkOpen);
					break;
				case 5:
					stream.applyTempStore(bkOpen);
					tokentree_walk_WalkWhile.walkWhile(stream,bkOpen);
					break;
				case 7:
					stream.applyTempStore(bkOpen);
					tokentree_walk_WalkFor.walkFor(stream,bkOpen);
					break;
				default:
					stream.applyTempStore(bkOpen);
					tokentree_walk_WalkStatement.walkStatement(stream,bkOpen);
				}
				break;
			case 6:
				if(_g.op._hx_index == 22) {
					let child = bkOpen.getLastChild();
					if(child == null) {
						child = bkOpen;
					}
					tokentree_walk_WalkStatement.walkStatement(stream,child);
				} else {
					stream.applyTempStore(bkOpen);
					tokentree_walk_WalkStatement.walkStatement(stream,bkOpen);
				}
				break;
			case 14:
				let comma = stream.consumeToken();
				let child = bkOpen.getLastChild();
				if(child == null) {
					child = bkOpen;
				}
				child.addChild(comma);
				break;
			case 15:
				tokentree_walk_WalkArrayAccess.walkArrayAccess(stream,bkOpen);
				break;
			case 16:
				break _hx_loop1;
			case 17:
				stream.applyTempStore(bkOpen);
				tokentree_walk_WalkBlock.walkBlock(stream,bkOpen);
				break;
			case 19:
				stream.applyTempStore(bkOpen);
				tokentree_walk_WalkPOpen.walkPOpen(stream,bkOpen);
				break;
			case 22:
				stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
				break;
			default:
				stream.applyTempStore(bkOpen);
				tokentree_walk_WalkStatement.walkStatement(stream,bkOpen);
			}
		}
		bkOpen.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BkClose));
	}
}
$hxClasses["tokentree.walk.WalkArrayAccess"] = tokentree_walk_WalkArrayAccess;
tokentree_walk_WalkArrayAccess.__name__ = "tokentree.walk.WalkArrayAccess";
class tokentree_walk_WalkAt {
	static walkAt(stream) {
		let atTok = stream.consumeTokenDef(tokentree_TokenTreeDef.At);
		let parent = atTok;
		if(stream.is(tokentree_TokenTreeDef.DblDot)) {
			let dblDot = stream.consumeTokenDef(tokentree_TokenTreeDef.DblDot);
			atTok.addChild(dblDot);
			parent = dblDot;
		}
		tokentree_walk_WalkAt.walkIdent(stream,parent);
		return atTok;
	}
	static walkIdent(stream,parent) {
		let ident;
		let _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			let _g1 = _g.k;
			ident = stream.consumeToken();
			break;
		case 2:
			let _g2 = _g.c;
			if(_g2._hx_index == 3) {
				let _g = _g2.s;
				ident = stream.consumeConstIdent();
			} else {
				return;
			}
			break;
		case 6:
			if(_g.op._hx_index == 23) {
				ident = stream.consumeToken();
			} else {
				return;
			}
			break;
		default:
			return;
		}
		parent.addChild(ident);
		switch(stream.token()._hx_index) {
		case 11:
			let child = stream.consumeToken();
			ident.addChild(child);
			tokentree_walk_WalkAt.walkIdent(stream,child);
			break;
		case 19:
			let pOpenPos = stream.getTokenPos();
			if(ident.pos.max == pOpenPos.min) {
				let tempStore = stream.getTempStore();
				stream.clearTempStore();
				tokentree_walk_WalkPOpen.walkPOpen(stream,ident,false);
				let _g = 0;
				while(_g < tempStore.length) {
					let temp = tempStore[_g];
					++_g;
					stream.addToTempStore(temp);
				}
			}
			break;
		default:
		}
	}
	static walkAts(stream) {
		let progress = new tokentree_TokenStreamProgress(stream);
		while(progress.streamHasChanged()) if(stream.token()._hx_index == 22) {
			stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
		}
	}
}
$hxClasses["tokentree.walk.WalkAt"] = tokentree_walk_WalkAt;
tokentree_walk_WalkAt.__name__ = "tokentree.walk.WalkAt";
class tokentree_walk_WalkBinopSub {
	static walkBinopSub(stream,parent) {
		let sub = stream.consumeOpSub(parent);
		parent.addChild(sub);
		let _g = sub.tok;
		if(_g._hx_index == 2) {
			let _g1 = _g.c;
			tokentree_walk_WalkStatement.walkStatementContinue(stream,sub);
		} else {
			tokentree_walk_WalkStatement.walkStatement(stream,sub);
		}
	}
}
$hxClasses["tokentree.walk.WalkBinopSub"] = tokentree_walk_WalkBinopSub;
tokentree_walk_WalkBinopSub.__name__ = "tokentree.walk.WalkBinopSub";
class tokentree_walk_WalkBlock {
	static walkBlock(stream,parent) {
		while(stream.is(tokentree_TokenTreeDef.At)) stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
		if(stream.is(tokentree_TokenTreeDef.BrOpen)) {
			let openTok = stream.consumeTokenDef(tokentree_TokenTreeDef.BrOpen);
			parent.addChild(openTok);
			stream.applyTempStore(openTok);
			tokentree_walk_WalkBlock.walkBlockContinue(stream,openTok);
		} else {
			tokentree_walk_WalkStatement.walkStatement(stream,parent);
		}
	}
	static walkBlockContinue(stream,parent) {
		let progress = new tokentree_TokenStreamProgress(stream);
		_hx_loop1: while(progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 15:case 16:
					tokentree_walk_WalkSwitch.walkSwitchCases(stream,parent);
					break;
				default:
					tokentree_walk_WalkStatement.walkStatement(stream,parent);
				}
				break;
			case 14:
				let child = stream.consumeToken();
				let lastChild = parent.getLastChild();
				if(lastChild == null) {
					parent.addChild(child);
				} else {
					lastChild.addChild(child);
				}
				break;
			case 18:
				break _hx_loop1;
			case 16:case 20:
				let child1 = stream.consumeToken();
				parent.addChild(child1);
				break;
			default:
				tokentree_walk_WalkStatement.walkStatement(stream,parent);
			}
		}
		tokentree_walk_WalkBlock.walkBlockEnd(stream,parent);
	}
	static walkBlockEnd(stream,parent) {
		parent.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BrClose));
		if(stream.hasMore()) {
			let _g = stream.token();
			if(_g._hx_index == 6) {
				if(_g.op._hx_index == 7) {
					return;
				}
			}
			tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
			if(stream.hasMore()) {
				if(stream.token()._hx_index == 10) {
					let semicolon = stream.consumeToken();
					parent.addChild(semicolon);
				}
			}
		}
	}
}
$hxClasses["tokentree.walk.WalkBlock"] = tokentree_walk_WalkBlock;
tokentree_walk_WalkBlock.__name__ = "tokentree.walk.WalkBlock";
class tokentree_walk_WalkClass {
	static walkClass(stream,parent) {
		let typeTok = stream.consumeToken();
		parent.addChild(typeTok);
		tokentree_walk_WalkComment.walkComment(stream,parent);
		let name = typeTok;
		let _g = stream.token();
		switch(_g._hx_index) {
		case 2:
			let _g1 = _g.c;
			if(_g1._hx_index == 3) {
				let _g = _g1.s;
				name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
				stream.applyTempStore(name);
			}
			break;
		case 4:
			let _g2 = _g.s;
			name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
			stream.applyTempStore(name);
			break;
		default:
		}
		tokentree_walk_WalkClass.walkClassExtends(stream,name);
		let block = stream.consumeTokenDef(tokentree_TokenTreeDef.BrOpen);
		name.addChild(block);
		tokentree_walk_WalkClass.walkClassBody(stream,block);
		block.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BrClose));
	}
	static walkClassExtends(stream,name) {
		let progress = new tokentree_TokenStreamProgress(stream);
		while(progress.streamHasChanged()) {
			tokentree_walk_WalkExtends.walkExtends(stream,name);
			tokentree_walk_WalkImplements.walkImplements(stream,name);
			if(stream.isSharp()) {
				tokentree_walk_WalkSharp.walkSharp(stream,name,tokentree_walk_WalkClass.walkClassExtends);
			}
			tokentree_walk_WalkComment.walkComment(stream,name);
		}
	}
	static walkClassBody(stream,parent) {
		let progress = new tokentree_TokenStreamProgress(stream);
		_hx_loop1: while(stream.hasMore() && progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:
					tokentree_walk_WalkFunction.walkFunction(stream,parent);
					break;
				case 2:
					tokentree_walk_WalkVar.walkVar(stream,parent);
					break;
				case 17:case 18:case 19:case 25:case 30:case 32:case 34:case 40:
					stream.consumeToTempStore();
					break;
				case 41:
					tokentree_walk_WalkFinal.walkFinal(stream,parent);
					break;
				default:
					switch(tokentree_TokenStream.MODE._hx_index) {
					case 0:
						throw haxe_Exception.thrown("invalid token tree structure - found:" + ("" + Std.string(stream.token())));
					case 1:
						tokentree_walk_WalkStatement.walkStatement(stream,parent);
						break;
					}
				}
				break;
			case 2:
				let _g1 = _g.c;
				if(_g1._hx_index == 3) {
					if(_g1.s == "final") {
						tokentree_walk_WalkFinal.walkFinal(stream,parent);
					} else {
						switch(tokentree_TokenStream.MODE._hx_index) {
						case 0:
							throw haxe_Exception.thrown("invalid token tree structure - found:" + ("" + Std.string(stream.token())));
						case 1:
							tokentree_walk_WalkStatement.walkStatement(stream,parent);
							break;
						}
					}
				} else {
					switch(tokentree_TokenStream.MODE._hx_index) {
					case 0:
						throw haxe_Exception.thrown("invalid token tree structure - found:" + ("" + Std.string(stream.token())));
					case 1:
						tokentree_walk_WalkStatement.walkStatement(stream,parent);
						break;
					}
				}
				break;
			case 3:
				let _g2 = _g.s;
				tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkClass.walkClassBody);
				tokentree_walk_WalkClass.walkClassContinueAfterSharp(stream,parent);
				break;
			case 7:
				let _g3 = _g.s;
				parent.addChild(stream.consumeToken());
				break;
			case 8:
				let _g4 = _g.s;
				parent.addChild(stream.consumeToken());
				break;
			case 10:
				parent.addChild(stream.consumeToken());
				break;
			case 18:
				break _hx_loop1;
			case 22:
				stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
				break;
			default:
				switch(tokentree_TokenStream.MODE._hx_index) {
				case 0:
					throw haxe_Exception.thrown("invalid token tree structure - found:" + ("" + Std.string(stream.token())));
				case 1:
					tokentree_walk_WalkStatement.walkStatement(stream,parent);
					break;
				}
			}
		}
		let tempStore = stream.getTempStore();
		if(tempStore.length > 0) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("invalid token tree structure - found:" + ("" + Std.string(tempStore)));
			case 1:
				stream.applyTempStore(parent);
				break;
			}
		}
	}
	static walkClassContinueAfterSharp(stream,parent) {
		let brOpen = tokentree_TokenTreeAccessHelper.is(tokentree_TokenTreeAccessHelper.lastChild(tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.lastOf(tokentree_TokenTreeAccessHelper.is(tokentree_TokenTreeAccessHelper.lastChild(parent),tokentree_TokenTreeDef.Sharp("if")),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFunction)))),tokentree_TokenTreeDef.BrOpen);
		if(brOpen == null) {
			return;
		}
		if(tokentree_TokenTreeAccessHelper.is(tokentree_TokenTreeAccessHelper.lastChild(brOpen),tokentree_TokenTreeDef.BrClose) != null) {
			return;
		}
		tokentree_walk_WalkBlock.walkBlockContinue(stream,parent);
	}
}
$hxClasses["tokentree.walk.WalkClass"] = tokentree_walk_WalkClass;
tokentree_walk_WalkClass.__name__ = "tokentree.walk.WalkClass";
class tokentree_walk_WalkComment {
	static walkComment(stream,parent) {
		let progress = new tokentree_TokenStreamProgress(stream);
		while(stream.hasMore() && progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 7:
				let _g1 = _g.s;
				let comment = stream.consumeToken();
				parent.addChild(comment);
				break;
			case 8:
				let _g2 = _g.s;
				let comment1 = stream.consumeToken();
				parent.addChild(comment1);
				break;
			default:
				return;
			}
		}
	}
	static tryWalkComment(stream,parent,expect) {
		let currentPos = stream.getStreamIndex();
		let progress = new tokentree_TokenStreamProgress(stream);
		let comments = [];
		while(stream.hasMore() && progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 7:
				let _g1 = _g.s;
				comments.push(stream.consumeToken());
				break;
			case 8:
				let _g2 = _g.s;
				comments.push(stream.consumeToken());
				break;
			default:
				if(stream.is(expect)) {
					let _g = 0;
					while(_g < comments.length) {
						let comment = comments[_g];
						++_g;
						parent.addChild(comment);
					}
					return;
				}
				stream.rewindTo(currentPos);
				return;
			}
		}
	}
}
$hxClasses["tokentree.walk.WalkComment"] = tokentree_walk_WalkComment;
tokentree_walk_WalkComment.__name__ = "tokentree.walk.WalkComment";
class tokentree_walk_WalkDoWhile {
	static walkDoWhile(stream,parent) {
		let doTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdDo));
		parent.addChild(doTok);
		stream.applyTempStore(doTok);
		tokentree_walk_WalkComment.walkComment(stream,doTok);
		tokentree_walk_WalkBlock.walkBlock(stream,doTok);
		let whileTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdWhile));
		doTok.addChild(whileTok);
		tokentree_walk_WalkStatement.walkStatement(stream,whileTok);
		tokentree_walk_WalkComment.walkComment(stream,whileTok);
		if(stream.is(tokentree_TokenTreeDef.Semicolon)) {
			whileTok.addChild(stream.consumeToken());
		}
	}
}
$hxClasses["tokentree.walk.WalkDoWhile"] = tokentree_walk_WalkDoWhile;
tokentree_walk_WalkDoWhile.__name__ = "tokentree.walk.WalkDoWhile";
class tokentree_walk_WalkEnum {
	static walkEnum(stream,parent) {
		let typeTok = stream.consumeToken();
		if(stream.is(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdAbstract))) {
			stream.addToTempStore(typeTok);
			tokentree_walk_WalkAbstract.walkAbstract(stream,parent);
			return;
		}
		parent.addChild(typeTok);
		let name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
		stream.applyTempStore(name);
		tokentree_walk_WalkBlock.walkBlock(stream,name);
	}
}
$hxClasses["tokentree.walk.WalkEnum"] = tokentree_walk_WalkEnum;
tokentree_walk_WalkEnum.__name__ = "tokentree.walk.WalkEnum";
class tokentree_walk_WalkExtends {
	static walkExtends(stream,parent) {
		if(!stream.is(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdExtends))) {
			return;
		}
		let parentType = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdExtends));
		parent.addChild(parentType);
		tokentree_walk_WalkComment.walkComment(stream,parent);
		tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,parentType);
		tokentree_walk_WalkComment.walkComment(stream,parent);
		tokentree_walk_WalkExtends.walkExtends(stream,parentType);
		tokentree_walk_WalkComment.walkComment(stream,parent);
	}
}
$hxClasses["tokentree.walk.WalkExtends"] = tokentree_walk_WalkExtends;
tokentree_walk_WalkExtends.__name__ = "tokentree.walk.WalkExtends";
class tokentree_walk_WalkFieldDef {
	static walkFieldDef(stream,parent) {
		let progress = new tokentree_TokenStreamProgress(stream);
		_hx_loop1: while(progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:case 2:
					let tok = stream.consumeToken();
					parent.addChild(tok);
					parent = tok;
					break;
				case 41:
					let tok1 = stream.consumeToken();
					parent.addChild(tok1);
					parent = tok1;
					break;
				default:
					break _hx_loop1;
				}
				break;
			case 2:
				let _g1 = _g.c;
				if(_g1._hx_index == 3) {
					if(_g1.s == "final") {
						let tok = stream.consumeToken();
						parent.addChild(tok);
						parent = tok;
					} else {
						break _hx_loop1;
					}
				} else {
					break _hx_loop1;
				}
				break;
			case 7:
				let _g2 = _g.s;
				tokentree_walk_WalkComment.walkComment(stream,parent);
				break;
			case 8:
				let _g3 = _g.s;
				tokentree_walk_WalkComment.walkComment(stream,parent);
				break;
			case 22:
				stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
				break;
			default:
				break _hx_loop1;
			}
		}
		let name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,parent);
		stream.applyTempStore(name);
		if(stream.is(tokentree_TokenTreeDef.DblDot)) {
			let dblDot = stream.consumeTokenDef(tokentree_TokenTreeDef.DblDot);
			name.addChild(dblDot);
			tokentree_walk_WalkTypedefBody.walkTypedefBody(stream,dblDot);
		}
		if(stream.is(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign))) {
			tokentree_walk_WalkStatement.walkStatement(stream,name);
		}
		switch(stream.token()._hx_index) {
		case 10:
			name.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.Semicolon));
			break;
		case 14:
			name.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.Comma));
			break;
		default:
		}
	}
}
$hxClasses["tokentree.walk.WalkFieldDef"] = tokentree_walk_WalkFieldDef;
tokentree_walk_WalkFieldDef.__name__ = "tokentree.walk.WalkFieldDef";
class tokentree_walk_WalkFile {
	static walkFile(stream,parent) {
		let progress = new tokentree_TokenStreamProgress(stream);
		while(stream.hasMore() && progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:
					tokentree_walk_WalkFunction.walkFunction(stream,parent);
					break;
				case 2:
					tokentree_walk_WalkVar.walkVar(stream,parent);
					break;
				case 13:case 33:case 35:
					stream.applyTempStore(parent);
					tokentree_walk_WalkPackageImport.walkPackageImport(stream,parent);
					break;
				case 17:case 18:case 19:case 25:case 32:case 34:case 40:
					stream.consumeToTempStore();
					break;
				case 1:case 26:case 27:case 31:case 39:
					tokentree_walk_WalkType.walkType(stream,parent);
					break;
				case 41:
					tokentree_walk_WalkFinal.walkFinal(stream,parent);
					break;
				default:
					tokentree_walk_WalkBlock.walkBlock(stream,parent);
				}
				break;
			case 2:
				let _g1 = _g.c;
				if(_g1._hx_index == 2) {
					let _g = _g1.kind;
					if(_g1.s == "final") {
						stream.consumeToTempStore();
					} else {
						tokentree_walk_WalkBlock.walkBlock(stream,parent);
					}
				} else {
					tokentree_walk_WalkBlock.walkBlock(stream,parent);
				}
				break;
			case 3:
				let _g2 = _g.s;
				tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkFile.walkFile);
				if(!stream.hasMore()) {
					return;
				}
				if(stream.token()._hx_index == 17) {
					tokentree_walk_WalkBlock.walkBlock(stream,parent.children[parent.children.length - 1]);
				}
				break;
			case 7:
				let _g3 = _g.s;
				tokentree_walk_WalkComment.walkComment(stream,parent);
				break;
			case 8:
				let _g4 = _g.s;
				tokentree_walk_WalkComment.walkComment(stream,parent);
				break;
			case 10:case 14:case 16:case 18:case 20:
				parent.addChild(stream.consumeToken());
				break;
			case 22:
				stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
				break;
			default:
				tokentree_walk_WalkBlock.walkBlock(stream,parent);
			}
		}
		let tempStore = stream.getTempStore();
		let _g = 0;
		while(_g < tempStore.length) {
			let stored = tempStore[_g];
			++_g;
			let _g1 = stored.tok;
			switch(_g1._hx_index) {
			case 1:
				switch(_g1.k._hx_index) {
				case 18:case 19:case 25:
					switch(tokentree_TokenStream.MODE._hx_index) {
					case 0:
						throw haxe_Exception.thrown("invalid token tree structure - found:" + Std.string(stored));
					case 1:
						parent.addChild(stored);
						break;
					}
					break;
				default:
					parent.addChild(stored);
				}
				break;
			case 22:
				switch(tokentree_TokenStream.MODE._hx_index) {
				case 0:
					throw haxe_Exception.thrown("invalid token tree structure - found:" + Std.string(stored));
				case 1:
					parent.addChild(stored);
					break;
				}
				break;
			default:
				parent.addChild(stored);
			}
		}
	}
}
$hxClasses["tokentree.walk.WalkFile"] = tokentree_walk_WalkFile;
tokentree_walk_WalkFile.__name__ = "tokentree.walk.WalkFile";
class tokentree_walk_WalkFinal {
	static walkFinal(stream,parent) {
		let name = null;
		let finalTok = stream.consumeToken();
		stream.addToTempStore(finalTok);
		tokentree_walk_WalkComment.walkComment(stream,parent);
		let progress = new tokentree_TokenStreamProgress(stream);
		_hx_loop1: while(progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:
					return;
				case 1:case 27:
					return;
				case 17:case 18:case 19:case 25:case 30:case 32:case 34:case 40:
					stream.consumeToTempStore();
					break;
				default:
				}
				break;
			case 2:
				let _g1 = _g.c;
				if(_g1._hx_index == 3) {
					let _g = _g1.s;
					break _hx_loop1;
				}
				break;
			case 7:
				let _g2 = _g.s;
				stream.consumeToTempStore();
				break;
			case 8:
				let _g3 = _g.s;
				stream.consumeToTempStore();
				break;
			default:
			}
		}
		parent.addChild(finalTok);
		let progress1 = new tokentree_TokenStreamProgress(stream);
		while(progress1.streamHasChanged()) {
			tokentree_walk_WalkComment.walkComment(stream,parent);
			if(stream.token()._hx_index == 22) {
				tokentree_walk_WalkAt.walkAts(stream);
			}
			tokentree_walk_WalkComment.walkComment(stream,parent);
			let nameParent = finalTok;
			if(stream.is(tokentree_TokenTreeDef.Question)) {
				nameParent = stream.consumeToken();
				finalTok.addChild(nameParent);
			}
			name = stream.consumeConstIdent();
			nameParent.addChild(name);
			let tempStore = stream.getTempStore();
			let _g = 0;
			while(_g < tempStore.length) {
				let stored = tempStore[_g];
				++_g;
				let _g1 = stored.tok;
				switch(_g1._hx_index) {
				case 1:
					if(_g1.k._hx_index != 41) {
						name.addChild(stored);
					}
					break;
				case 2:
					let _g2 = _g1.c;
					if(_g2._hx_index == 3) {
						if(_g2.s != "final") {
							name.addChild(stored);
						}
					} else {
						name.addChild(stored);
					}
					break;
				default:
					name.addChild(stored);
				}
			}
			stream.clearTempStore();
			tokentree_walk_WalkComment.walkComment(stream,name);
			if(stream.is(tokentree_TokenTreeDef.POpen)) {
				tokentree_walk_WalkPOpen.walkPOpen(stream,name);
			}
			if(stream.is(tokentree_TokenTreeDef.DblDot)) {
				let dblDot = stream.consumeTokenDef(tokentree_TokenTreeDef.DblDot);
				name.addChild(dblDot);
				tokentree_walk_WalkTypedefBody.walkTypedefAlias(stream,dblDot);
			}
			if(stream.is(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign))) {
				tokentree_walk_WalkStatement.walkStatement(stream,name);
			}
			if(stream.is(tokentree_TokenTreeDef.Comma)) {
				let comma = stream.consumeTokenDef(tokentree_TokenTreeDef.Comma);
				name.addChild(comma);
				continue;
			}
			break;
		}
		if(stream.is(tokentree_TokenTreeDef.Semicolon)) {
			name.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.Semicolon));
		}
	}
}
$hxClasses["tokentree.walk.WalkFinal"] = tokentree_walk_WalkFinal;
tokentree_walk_WalkFinal.__name__ = "tokentree.walk.WalkFinal";
class tokentree_walk_WalkFor {
	static walkFor(stream,parent) {
		let forTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFor));
		parent.addChild(forTok);
		stream.applyTempStore(forTok);
		tokentree_walk_WalkComment.walkComment(stream,forTok);
		tokentree_walk_WalkFor.walkForPOpen(stream,forTok);
		tokentree_walk_WalkComment.walkComment(stream,forTok);
		tokentree_walk_WalkBlock.walkBlock(stream,forTok);
	}
	static walkForPOpen(stream,parent) {
		let pOpen = stream.consumeTokenDef(tokentree_TokenTreeDef.POpen);
		parent.addChild(pOpen);
		tokentree_walk_WalkComment.walkComment(stream,pOpen);
		let identifier = null;
		let _g = stream.token();
		if(_g._hx_index == 4) {
			let _g1 = _g.s;
			tokentree_walk_WalkStatement.walkStatement(stream,pOpen);
			identifier = pOpen.getLastChild();
		} else {
			identifier = stream.consumeConstIdent();
			pOpen.addChild(identifier);
		}
		tokentree_walk_WalkComment.walkComment(stream,identifier);
		if(stream.is(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpArrow))) {
			let arrowTok = stream.consumeToken();
			identifier.addChild(arrowTok);
			let _g = stream.token();
			if(_g._hx_index == 4) {
				let _g1 = _g.s;
				tokentree_walk_WalkStatement.walkStatement(stream,arrowTok);
			} else {
				arrowTok.addChild(stream.consumeConstIdent());
			}
		}
		let inTok = null;
		let _g1 = stream.token();
		switch(_g1._hx_index) {
		case 6:
			if(_g1.op._hx_index == 23) {
				inTok = stream.consumeToken();
				identifier.addChild(inTok);
				tokentree_walk_WalkComment.walkComment(stream,inTok);
				tokentree_walk_WalkStatement.walkStatement(stream,inTok);
				tokentree_walk_WalkComment.walkComment(stream,pOpen);
				pOpen.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.PClose));
				tokentree_walk_WalkComment.walkComment(stream,parent);
			}
			break;
		case 20:
			pOpen.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.PClose));
			tokentree_walk_WalkComment.walkComment(stream,parent);
			return;
		default:
		}
	}
}
$hxClasses["tokentree.walk.WalkFor"] = tokentree_walk_WalkFor;
tokentree_walk_WalkFor.__name__ = "tokentree.walk.WalkFor";
class tokentree_walk_WalkFunction {
	static walkFunction(stream,parent) {
		let funcTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFunction));
		parent.addChild(funcTok);
		tokentree_walk_WalkComment.walkComment(stream,funcTok);
		let name = funcTok;
		let _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			if(_g.k._hx_index == 22) {
				name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,funcTok);
			} else {
				name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,funcTok);
			}
			break;
		case 6:
			if(_g.op._hx_index == 9) {
				tokentree_walk_WalkLtGt.walkLtGt(stream,funcTok);
				name = funcTok.getLastChild();
			} else {
				name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,funcTok);
			}
			break;
		case 19:
			break;
		default:
			name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,funcTok);
		}
		stream.applyTempStore(name);
		tokentree_walk_WalkComment.walkComment(stream,name);
		tokentree_walk_WalkFunction.walkFunctionParameters(stream,name);
		tokentree_walk_WalkComment.walkComment(stream,name);
		if(stream.is(tokentree_TokenTreeDef.DblDot)) {
			let dblDot = stream.consumeTokenDef(tokentree_TokenTreeDef.DblDot);
			name.addChild(dblDot);
			tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,dblDot);
		}
		tokentree_walk_WalkBlock.walkBlock(stream,name);
	}
	static walkFunctionParameters(stream,parent) {
		let pOpen = stream.consumeTokenDef(tokentree_TokenTreeDef.POpen);
		parent.addChild(pOpen);
		let progress = new tokentree_TokenStreamProgress(stream);
		while(progress.streamHasChanged()) {
			tokentree_walk_WalkComment.walkComment(stream,pOpen);
			if(stream.is(tokentree_TokenTreeDef.PClose)) {
				break;
			}
			tokentree_walk_WalkFieldDef.walkFieldDef(stream,pOpen);
		}
		pOpen.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.PClose));
	}
}
$hxClasses["tokentree.walk.WalkFunction"] = tokentree_walk_WalkFunction;
tokentree_walk_WalkFunction.__name__ = "tokentree.walk.WalkFunction";
class tokentree_walk_WalkIf {
	static walkIf(stream,parent) {
		let ifTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdIf));
		parent.addChild(ifTok);
		stream.applyTempStore(ifTok);
		tokentree_walk_WalkStatement.walkStatement(stream,ifTok);
		if(stream.is(tokentree_TokenTreeDef.DblDot)) {
			return;
		}
		tokentree_walk_WalkBlock.walkBlock(stream,ifTok);
		tokentree_walk_WalkComment.tryWalkComment(stream,ifTok,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse));
		if(stream.is(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse))) {
			let elseTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse));
			ifTok.addChild(elseTok);
			tokentree_walk_WalkBlock.walkBlock(stream,elseTok);
		}
	}
}
$hxClasses["tokentree.walk.WalkIf"] = tokentree_walk_WalkIf;
tokentree_walk_WalkIf.__name__ = "tokentree.walk.WalkIf";
class tokentree_walk_WalkImplements {
	static walkImplements(stream,parent) {
		if(!stream.is(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdImplements))) {
			return;
		}
		let interfacePart = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdImplements));
		parent.addChild(interfacePart);
		tokentree_walk_WalkComment.walkComment(stream,parent);
		tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,interfacePart);
		tokentree_walk_WalkComment.walkComment(stream,parent);
		tokentree_walk_WalkImplements.walkImplements(stream,parent);
		tokentree_walk_WalkComment.walkComment(stream,parent);
	}
}
$hxClasses["tokentree.walk.WalkImplements"] = tokentree_walk_WalkImplements;
tokentree_walk_WalkImplements.__name__ = "tokentree.walk.WalkImplements";
class tokentree_walk_WalkInterface {
	static walkInterface(stream,parent) {
		let typeTok = stream.consumeToken();
		parent.addChild(typeTok);
		let name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
		stream.applyTempStore(name);
		tokentree_walk_WalkClass.walkClassExtends(stream,name);
		let block = stream.consumeTokenDef(tokentree_TokenTreeDef.BrOpen);
		name.addChild(block);
		tokentree_walk_WalkInterface.walkInterfaceBody(stream,block);
		block.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BrClose));
	}
	static walkInterfaceBody(stream,parent) {
		let progress = new tokentree_TokenStreamProgress(stream);
		_hx_loop1: while(progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:
					tokentree_walk_WalkFunction.walkFunction(stream,parent);
					break;
				case 2:
					tokentree_walk_WalkVar.walkVar(stream,parent);
					break;
				case 17:case 18:case 19:case 25:case 30:case 32:case 34:case 40:
					stream.consumeToTempStore();
					break;
				case 41:
					tokentree_walk_WalkFinal.walkFinal(stream,parent);
					break;
				default:
					stream.consumeToTempStore();
				}
				break;
			case 2:
				let _g1 = _g.c;
				if(_g1._hx_index == 3) {
					if(_g1.s == "final") {
						tokentree_walk_WalkFinal.walkFinal(stream,parent);
					} else {
						stream.consumeToTempStore();
					}
				} else {
					stream.consumeToTempStore();
				}
				break;
			case 3:
				let _g2 = _g.s;
				tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkInterface.walkInterfaceBody);
				break;
			case 7:
				let _g3 = _g.s;
				parent.addChild(stream.consumeToken());
				break;
			case 8:
				let _g4 = _g.s;
				parent.addChild(stream.consumeToken());
				break;
			case 10:
				parent.addChild(stream.consumeToken());
				break;
			case 18:
				break _hx_loop1;
			case 22:
				stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
				break;
			default:
				stream.consumeToTempStore();
			}
		}
		stream.applyTempStore(parent);
	}
}
$hxClasses["tokentree.walk.WalkInterface"] = tokentree_walk_WalkInterface;
tokentree_walk_WalkInterface.__name__ = "tokentree.walk.WalkInterface";
class tokentree_walk_WalkLtGt {
	static walkLtGt(stream,parent) {
		let ltTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpLt));
		parent.addChild(ltTok);
		let progress = new tokentree_TokenStreamProgress(stream);
		_hx_loop1: while(progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 6:
				if(_g.op._hx_index == 7) {
					break _hx_loop1;
				} else {
					tokentree_walk_WalkFieldDef.walkFieldDef(stream,ltTok);
				}
				break;
			case 12:
				let dblDot = stream.consumeTokenDef(tokentree_TokenTreeDef.DblDot);
				ltTok.addChild(dblDot);
				tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,ltTok);
				break;
			case 14:
				let comma = stream.consumeTokenDef(tokentree_TokenTreeDef.Comma);
				ltTok.addChild(comma);
				tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,ltTok);
				tokentree_walk_WalkFieldDef.walkFieldDef(stream,ltTok);
				break;
			default:
				tokentree_walk_WalkFieldDef.walkFieldDef(stream,ltTok);
			}
		}
		ltTok.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt)));
	}
}
$hxClasses["tokentree.walk.WalkLtGt"] = tokentree_walk_WalkLtGt;
tokentree_walk_WalkLtGt.__name__ = "tokentree.walk.WalkLtGt";
class tokentree_walk_WalkNew {
	static walkNew(stream,parent) {
		let newTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdNew));
		parent.addChild(newTok);
		let name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,newTok);
		tokentree_walk_WalkComment.walkComment(stream,name);
		let _g = stream.token();
		switch(_g._hx_index) {
		case 3:
			let _g1 = _g.s;
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkStatement.walkStatement);
			break;
		case 19:
			tokentree_walk_WalkPOpen.walkPOpen(stream,name);
			break;
		default:
		}
		tokentree_walk_WalkComment.walkComment(stream,name);
		if(stream.is(tokentree_TokenTreeDef.Dot)) {
			tokentree_walk_WalkStatement.walkStatement(stream,name);
		}
	}
}
$hxClasses["tokentree.walk.WalkNew"] = tokentree_walk_WalkNew;
tokentree_walk_WalkNew.__name__ = "tokentree.walk.WalkNew";
class tokentree_walk_WalkPOpen {
	static walkPOpen(stream,parent,walkTrailingComments) {
		if(walkTrailingComments == null) {
			walkTrailingComments = true;
		}
		let pOpen = stream.consumeTokenDef(tokentree_TokenTreeDef.POpen);
		parent.addChild(pOpen);
		tokentree_walk_WalkPOpen.walkPOpenParts(stream,pOpen);
		pOpen.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.PClose));
		if(walkTrailingComments) {
			tokentree_walk_WalkComment.walkComment(stream,parent);
		}
		return pOpen;
	}
	static walkPOpenParts(stream,parent) {
		let progress = new tokentree_TokenStreamProgress(stream);
		_hx_loop1: while(progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 3:
				let _g1 = _g.s;
				tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkPOpen.walkPOpenParts);
				break;
			case 14:
				let comma = stream.consumeToken();
				let child = parent.getLastChild();
				if(child == null) {
					child = parent;
				}
				child.addChild(comma);
				break;
			case 15:
				tokentree_walk_WalkArrayAccess.walkArrayAccess(stream,parent);
				break;
			case 17:
				tokentree_walk_WalkBlock.walkBlock(stream,parent);
				break;
			case 20:
				break _hx_loop1;
			default:
				tokentree_walk_WalkStatement.walkStatement(stream,parent);
			}
		}
	}
}
$hxClasses["tokentree.walk.WalkPOpen"] = tokentree_walk_WalkPOpen;
tokentree_walk_WalkPOpen.__name__ = "tokentree.walk.WalkPOpen";
class tokentree_walk_WalkPackageImport {
	static walkPackageImport(stream,parent) {
		let progress = new tokentree_TokenStreamProgress(stream);
		while(stream.hasMore() && progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 3:
				let _g1 = _g.s;
				tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkPackageImport.walkPackageImport);
				break;
			case 10:
				let newChild = stream.consumeToken();
				parent.addChild(newChild);
				return;
			default:
				let newChild1 = stream.consumeToken();
				parent.addChild(newChild1);
				parent = newChild1;
			}
		}
	}
}
$hxClasses["tokentree.walk.WalkPackageImport"] = tokentree_walk_WalkPackageImport;
tokentree_walk_WalkPackageImport.__name__ = "tokentree.walk.WalkPackageImport";
class tokentree_walk_WalkQuestion {
	static walkQuestion(stream,parent) {
		let ternary = tokentree_walk_WalkQuestion.isTernary(parent);
		let question = stream.consumeTokenDef(tokentree_TokenTreeDef.Question);
		parent.addChild(question);
		tokentree_walk_WalkComment.walkComment(stream,question);
		if(!ternary) {
			tokentree_walk_WalkStatement.walkStatement(stream,question);
			return;
		}
		tokentree_walk_WalkStatement.walkStatement(stream,question);
		tokentree_walk_WalkComment.walkComment(stream,question);
		let dblDotTok = stream.consumeTokenDef(tokentree_TokenTreeDef.DblDot);
		question.addChild(dblDotTok);
		tokentree_walk_WalkStatement.walkStatement(stream,dblDotTok);
	}
	static isTernary(parent) {
		let lastChild = parent.getLastChild();
		if(lastChild == null) {
			let _g = parent.tok;
			if(_g._hx_index == 2) {
				let _g1 = _g.c;
				return true;
			} else {
				return false;
			}
		} else {
			let _g = lastChild.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:
					return true;
				case 22:
					return true;
				case 23:case 28:case 40:
					return true;
				case 29:
					return true;
				case 36:case 37:case 38:
					return true;
				default:
					return false;
				}
				break;
			case 2:
				let _g1 = _g.c;
				return true;
			case 4:
				let _g2 = _g.s;
				return true;
			case 5:
				let _g3 = _g.op;
				return true;
			case 6:
				switch(_g.op._hx_index) {
				case 0:case 3:
					return true;
				default:
					return false;
				}
				break;
			case 12:
				return true;
			case 15:
				return true;
			case 17:
				return true;
			case 19:
				return true;
			case 20:
				return true;
			default:
				return false;
			}
		}
	}
}
$hxClasses["tokentree.walk.WalkQuestion"] = tokentree_walk_WalkQuestion;
tokentree_walk_WalkQuestion.__name__ = "tokentree.walk.WalkQuestion";
class tokentree_walk_WalkSharp {
	static walkSharp(stream,parent,walker) {
		let _g = stream.token();
		if(_g._hx_index == 3) {
			switch(_g.s) {
			case "else":
				tokentree_walk_WalkSharp.walkSharpElse(stream,parent);
				break;
			case "elseif":
				tokentree_walk_WalkSharp.walkSharpElseIf(stream,parent);
				break;
			case "end":
				tokentree_walk_WalkSharp.walkSharpEnd(stream,parent);
				break;
			case "error":
				let errorToken = stream.consumeToken();
				parent.addChild(errorToken);
				let _g1 = stream.token();
				if(_g1._hx_index == 2) {
					let _g = _g1.c;
					if(_g._hx_index == 2) {
						let _g1 = _g.kind;
						let _g2 = _g.s;
						errorToken.addChild(stream.consumeToken());
					}
				}
				break;
			case "if":
				tokentree_walk_WalkSharp.walkSharpIf(stream,parent,walker);
				break;
			default:
				parent.addChild(stream.consumeToken());
			}
		}
	}
	static walkSharpIf(stream,parent,walker) {
		let ifToken = stream.consumeToken();
		parent.addChild(ifToken);
		tokentree_walk_WalkSharp.walkSharpIfExpr(stream,ifToken);
		stream.pushSharpIf(ifToken);
		let newParent = ifToken;
		let progress = new tokentree_TokenStreamProgress(stream);
		while(progress.streamHasChanged()) try {
			walker(stream,newParent);
			switch(stream.token()._hx_index) {
			case 14:case 18:case 20:
				let newChild = stream.consumeToken();
				newParent.addChild(newChild);
				break;
			default:
			}
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			let _g1 = haxe_Exception.caught(_g).unwrap();
			if(((_g1) instanceof tokentree_walk_SharpElseException)) {
				let e = _g1;
				newParent = e.token;
			} else if(((_g1) instanceof tokentree_walk_SharpEndException)) {
				stream.popSharpIf();
				return;
			} else {
				throw _g;
			}
		}
	}
	static walkSharpElse(stream,parent) {
		let sharpIfParent = stream.peekSharpIf();
		let ifToken = stream.consumeToken();
		sharpIfParent.addChild(ifToken);
		stream.applyTempStore(sharpIfParent);
		throw haxe_Exception.thrown(new tokentree_walk_SharpElseException(ifToken));
	}
	static walkSharpElseIf(stream,parent) {
		let sharpIfParent = stream.peekSharpIf();
		let ifToken = stream.consumeToken();
		sharpIfParent.addChild(ifToken);
		stream.applyTempStore(sharpIfParent);
		tokentree_walk_WalkSharp.walkSharpIfExpr(stream,ifToken);
		throw haxe_Exception.thrown(new tokentree_walk_SharpElseException(ifToken));
	}
	static walkSharpEnd(stream,parent) {
		let sharpIfParent = stream.peekSharpIf();
		let endToken = stream.consumeToken();
		stream.applyTempStore(sharpIfParent);
		sharpIfParent.addChild(endToken);
		throw haxe_Exception.thrown(new tokentree_walk_SharpEndException());
	}
	static walkSharpIfExpr(stream,parent) {
		let childToken;
		let progress = new tokentree_TokenStreamProgress(stream);
		while(progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 1:
				let _g1 = _g.k;
				childToken = stream.consumeToken();
				parent.addChild(childToken);
				if(!stream.hasMore()) {
					return;
				}
				if(stream.token()._hx_index != 11) {
					return;
				}
				let pos = stream.getTokenPos();
				if(pos == null) {
					return;
				}
				if(pos.min == childToken.pos.max + 1) {
					continue;
				}
				let dot = stream.consumeToken();
				childToken.addChild(dot);
				tokentree_walk_WalkSharp.walkSharpIfExpr(stream,dot);
				return;
			case 2:
				let _g2 = _g.c;
				if(_g2._hx_index == 3) {
					let _g = _g2.s;
					childToken = stream.consumeToken();
					parent.addChild(childToken);
					if(!stream.hasMore()) {
						return;
					}
					if(stream.token()._hx_index != 11) {
						return;
					}
					let pos = stream.getTokenPos();
					if(pos == null) {
						return;
					}
					if(pos.min == childToken.pos.max + 1) {
						continue;
					}
					let dot = stream.consumeToken();
					childToken.addChild(dot);
					tokentree_walk_WalkSharp.walkSharpIfExpr(stream,dot);
					return;
				} else {
					return;
				}
				break;
			case 5:
				if(_g.op._hx_index == 2) {
					childToken = stream.consumeToken();
					parent.addChild(childToken);
					tokentree_walk_WalkSharp.walkSharpIfExpr(stream,childToken);
					return;
				} else {
					return;
				}
				break;
			case 19:
				tokentree_walk_WalkPOpen.walkPOpen(stream,parent);
				return;
			default:
				return;
			}
		}
	}
}
$hxClasses["tokentree.walk.WalkSharp"] = tokentree_walk_WalkSharp;
tokentree_walk_WalkSharp.__name__ = "tokentree.walk.WalkSharp";
class tokentree_walk_SharpElseException {
	constructor(token) {
		this.token = token;
	}
}
$hxClasses["tokentree.walk.SharpElseException"] = tokentree_walk_SharpElseException;
tokentree_walk_SharpElseException.__name__ = "tokentree.walk.SharpElseException";
Object.assign(tokentree_walk_SharpElseException.prototype, {
	__class__: tokentree_walk_SharpElseException
	,token: null
});
class tokentree_walk_SharpEndException {
	constructor() {
	}
}
$hxClasses["tokentree.walk.SharpEndException"] = tokentree_walk_SharpEndException;
tokentree_walk_SharpEndException.__name__ = "tokentree.walk.SharpEndException";
Object.assign(tokentree_walk_SharpEndException.prototype, {
	__class__: tokentree_walk_SharpEndException
});
class tokentree_walk_WalkStatement {
	static walkStatement(stream,parent) {
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		if(stream.is(tokentree_TokenTreeDef.Semicolon)) {
			let semicolon = stream.consumeToken();
			let lastChild = parent.getLastChild();
			if(lastChild == null) {
				lastChild = parent;
			}
			switch(lastChild.tok._hx_index) {
			case 16:case 18:case 20:
				lastChild = parent;
				break;
			default:
			}
			lastChild.addChild(semicolon);
		}
	}
	static walkStatementWithoutSemicolon(stream,parent) {
		tokentree_walk_WalkComment.walkComment(stream,parent);
		let wantMore = true;
		tokentree_walk_WalkAt.walkAts(stream);
		let _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			let _g1 = _g.k;
			if(tokentree_walk_WalkStatement.walkKeyword(stream,parent)) {
				wantMore = true;
			} else {
				return;
			}
			break;
		case 2:
			let _g2 = _g.c;
			if(_g2._hx_index == 3) {
				if(_g2.s == "final") {
					if(tokentree_walk_WalkStatement.walkKeyword(stream,parent)) {
						wantMore = true;
					} else {
						return;
					}
				} else {
					wantMore = false;
				}
			} else {
				wantMore = false;
			}
			break;
		case 3:
			let _g3 = _g.s;
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkStatement.walkStatement);
			tokentree_walk_WalkStatement.walkStatementContinueAfterSharp(stream,parent);
			return;
		case 4:
			let name = _g.s;
			let dollarTok = stream.consumeToken();
			parent.addChild(dollarTok);
			if(stream.is(tokentree_TokenTreeDef.DblDot)) {
				return;
			}
			tokentree_walk_WalkBlock.walkBlock(stream,dollarTok);
			return;
		case 5:
			let _g4 = _g.op;
			if(parent.isCIdentOrCString()) {
				let newChild = stream.consumeToken();
				parent.addChild(newChild);
				if(!stream.hasMore()) {
					return;
				}
				if(stream.token()._hx_index == 11) {
					tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,newChild);
				}
				return;
			}
			break;
		case 6:
			switch(_g.op._hx_index) {
			case 3:
				tokentree_walk_WalkBinopSub.walkBinopSub(stream,parent);
				return;
			case 7:
				let gtTok = stream.consumeOpGt();
				parent.addChild(gtTok);
				tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,gtTok);
				return;
			case 9:
				if(stream.isTypedParam()) {
					tokentree_walk_WalkLtGt.walkLtGt(stream,parent);
					if(stream.is(tokentree_TokenTreeDef.Arrow)) {
						tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
					}
					return;
				}
				wantMore = true;
				break;
			case 12:
				if(parent.parent != null && parent.parent.tok != tokentree_TokenTreeDef.Root) {
					let _g = parent.parent.tok;
					if(_g._hx_index == 1) {
						if(_g.k._hx_index == 15) {
							let orTok = stream.consumeToken();
							parent.addChild(orTok);
							tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent.parent);
							return;
						}
					}
				}
				wantMore = true;
				break;
			default:
				wantMore = true;
			}
			break;
		case 9:
			let _g5 = _g.s;
			wantMore = true;
			break;
		case 10:
			return;
		case 11:
			wantMore = true;
			break;
		case 12:
			if(parent.is(tokentree_TokenTreeDef.Dot)) {
				return;
			}
			if(tokentree_walk_WalkQuestion.isTernary(parent)) {
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				return;
			}
			wantMore = true;
			break;
		case 13:
			wantMore = true;
			break;
		case 14:
			return;
		case 15:
			tokentree_walk_WalkArrayAccess.walkArrayAccess(stream,parent);
			tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
			return;
		case 17:
			tokentree_walk_WalkBlock.walkBlock(stream,parent);
			return;
		case 16:case 18:case 20:
			return;
		case 19:
			tokentree_walk_WalkStatement.walkPOpen(stream,parent);
			return;
		case 21:
			tokentree_walk_WalkQuestion.walkQuestion(stream,parent);
			return;
		default:
			wantMore = false;
		}
		let newChild = stream.consumeToken();
		parent.addChild(newChild);
		stream.applyTempStore(newChild);
		tokentree_walk_WalkStatement.walkTrailingComment(stream,newChild);
		if(wantMore) {
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,newChild);
		}
		tokentree_walk_WalkStatement.walkStatementContinue(stream,newChild);
		tokentree_walk_WalkStatement.walkTrailingComment(stream,newChild);
	}
	static walkTrailingComment(stream,parent) {
		if(!stream.hasMore()) {
			return;
		}
		let _g = stream.token();
		if(_g._hx_index == 8) {
			let _g1 = _g.s;
			let currentPos = stream.getStreamIndex();
			let commentTok = stream.consumeToken();
			if(!stream.is(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse))) {
				stream.rewindTo(currentPos);
				return;
			}
			parent.addChild(commentTok);
		}
	}
	static walkStatementContinue(stream,parent) {
		if(!stream.hasMore()) {
			return;
		}
		let _g = stream.token();
		switch(_g._hx_index) {
		case 5:
			let _g1 = _g.op;
			if(parent.isCIdentOrCString()) {
				tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
			}
			break;
		case 6:
			switch(_g.op._hx_index) {
			case 0:case 3:
				tokentree_walk_WalkStatement.walkOpAdd(stream,parent);
				break;
			case 14:case 15:
				tokentree_walk_WalkStatement.walkOpBool(stream,parent);
				break;
			default:
				tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
			}
			break;
		case 7:
			let _g2 = _g.s;
			let nextTokDef = stream.peekNonCommentToken();
			if(nextTokDef == null) {
				return;
			}
			if(nextTokDef != null) {
				switch(nextTokDef._hx_index) {
				case 5:
					let _g3 = nextTokDef.op;
					tokentree_walk_WalkComment.walkComment(stream,parent);
					tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
					break;
				case 6:
					let _g4 = nextTokDef.op;
					tokentree_walk_WalkComment.walkComment(stream,parent);
					tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
					break;
				case 11:case 12:case 21:
					tokentree_walk_WalkComment.walkComment(stream,parent);
					tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
					break;
				default:
				}
			}
			break;
		case 8:
			let _g5 = _g.s;
			let nextTokDef1 = stream.peekNonCommentToken();
			if(nextTokDef1 == null) {
				return;
			}
			if(nextTokDef1 != null) {
				switch(nextTokDef1._hx_index) {
				case 5:
					let _g6 = nextTokDef1.op;
					tokentree_walk_WalkComment.walkComment(stream,parent);
					tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
					break;
				case 6:
					let _g7 = nextTokDef1.op;
					tokentree_walk_WalkComment.walkComment(stream,parent);
					tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
					break;
				case 11:case 12:case 21:
					tokentree_walk_WalkComment.walkComment(stream,parent);
					tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
					break;
				default:
				}
			}
			break;
		case 10:
			return;
		case 11:
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
			break;
		case 12:
			tokentree_walk_WalkStatement.walkDblDot(stream,parent);
			break;
		case 13:
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
			break;
		case 15:
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
			break;
		case 19:
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
			break;
		case 21:
			tokentree_walk_WalkQuestion.walkQuestion(stream,parent);
			break;
		default:
		}
	}
	static walkKeyword(stream,parent) {
		let _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				tokentree_walk_WalkFunction.walkFunction(stream,parent);
				break;
			case 1:
				tokentree_walk_WalkClass.walkClass(stream,parent);
				break;
			case 2:
				tokentree_walk_WalkVar.walkVar(stream,parent);
				break;
			case 3:
				tokentree_walk_WalkIf.walkIf(stream,parent);
				break;
			case 5:
				if(!parent.is(tokentree_TokenTreeDef.BrOpen) && parent.parent.is(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdDo))) {
					return false;
				}
				tokentree_walk_WalkWhile.walkWhile(stream,parent);
				break;
			case 6:
				tokentree_walk_WalkDoWhile.walkDoWhile(stream,parent);
				break;
			case 7:
				tokentree_walk_WalkFor.walkFor(stream,parent);
				break;
			case 10:case 40:
				return true;
			case 14:
				tokentree_walk_WalkSwitch.walkSwitch(stream,parent);
				break;
			case 15:
				return false;
			case 16:
				if(parent.is(tokentree_TokenTreeDef.BrOpen)) {
					return false;
				}
				return true;
			case 20:
				tokentree_walk_WalkTry.walkTry(stream,parent);
				break;
			case 22:
				if(parent.is(tokentree_TokenTreeDef.Dot)) {
					let newChild = stream.consumeToken();
					parent.addChild(newChild);
					tokentree_walk_WalkStatement.walkStatementContinue(stream,newChild);
				} else {
					tokentree_walk_WalkNew.walkNew(stream,parent);
				}
				break;
			case 23:
				let newChild = stream.consumeToken();
				parent.addChild(newChild);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,newChild);
				return false;
			case 29:
				let newChild1 = stream.consumeToken();
				parent.addChild(newChild1);
				tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,newChild1);
				return false;
			case 36:case 37:case 38:
				let newChild2 = stream.consumeToken();
				parent.addChild(newChild2);
				let _g1 = stream.token();
				if(_g1._hx_index == 6) {
					switch(_g1.op._hx_index) {
					case 14:case 15:
						tokentree_walk_WalkStatement.walkOpBool(stream,newChild2);
						break;
					default:
						tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,newChild2);
					}
				}
				return false;
			case 41:
				tokentree_walk_WalkFinal.walkFinal(stream,parent);
				break;
			default:
				return true;
			}
			break;
		case 2:
			let _g2 = _g.c;
			if(_g2._hx_index == 3) {
				if(_g2.s == "final") {
					tokentree_walk_WalkFinal.walkFinal(stream,parent);
				} else {
					return true;
				}
			} else {
				return true;
			}
			break;
		default:
			return true;
		}
		return false;
	}
	static walkDblDot(stream,parent) {
		let question = tokentree_walk_WalkStatement.findQuestionParent(parent);
		if(question != null) {
			return;
		}
		let dblDotTok = stream.consumeToken();
		parent.addChild(dblDotTok);
		if(parent.isCIdentOrCString() && parent.parent.is(tokentree_TokenTreeDef.BrOpen)) {
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,dblDotTok);
			return;
		}
		if(stream.is(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdNew))) {
			tokentree_walk_WalkNew.walkNew(stream,dblDotTok);
			return;
		}
		if(!tokentree_walk_WalkStatement.walkKeyword(stream,dblDotTok)) {
			return;
		}
		tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,dblDotTok);
		if(stream.is(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign))) {
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		}
		if(stream.is(tokentree_TokenTreeDef.Arrow)) {
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		}
	}
	static walkPOpen(stream,parent) {
		let pOpen = tokentree_walk_WalkPOpen.walkPOpen(stream,parent);
		if(parent.tok == tokentree_TokenTreeDef.Root) {
			return;
		}
		if(parent.isCIdent()) {
			tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
		} else {
			let _g = parent.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 3:case 5:case 7:case 14:
					let _g1 = stream.token();
					switch(_g1._hx_index) {
					case 6:
						if(_g1.op._hx_index == 3) {
							return;
						}
						break;
					case 11:
						break;
					default:
						return;
					}
					break;
				default:
				}
			}
			tokentree_walk_WalkStatement.walkStatementContinue(stream,pOpen);
		}
	}
	static findQuestionParent(token) {
		let parent = token;
		while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) {
			let _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 10:
					return parent;
				case 15:
					return parent;
				case 16:
					return parent;
				default:
				}
				break;
			case 6:
				let _g1 = _g.op;
				return parent;
			case 14:
				return null;
			case 17:
				if(tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.BrClose) == null) {
					return null;
				}
				break;
			case 19:
				if(tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.PClose) == null) {
					return null;
				}
				break;
			case 21:
				if(tokentree_walk_WalkQuestion.isTernary(parent)) {
					return parent;
				}
				return null;
			default:
			}
			parent = parent.parent;
		}
		return null;
	}
	static walkStatementContinueAfterSharp(stream,parent) {
		let _g = stream.token();
		if(_g._hx_index == 1) {
			switch(_g.k._hx_index) {
			case 15:case 16:
				let lastChild = parent.getLastChild();
				if(lastChild == null) {
					lastChild = parent;
				}
				tokentree_walk_WalkSwitch.walkSwitchCases(stream,lastChild);
				break;
			default:
			}
		}
	}
	static walkOpBool(stream,token) {
		let parent = token.parent;
		_hx_loop1: while(parent.tok != tokentree_TokenTreeDef.Root) {
			let _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:
					break _hx_loop1;
				case 3:case 5:case 10:case 24:case 28:
					break _hx_loop1;
				case 14:case 15:case 16:
					break _hx_loop1;
				default:
					token = parent;
					parent = parent.parent;
				}
				break;
			case 6:
				let _g1 = _g.op;
				switch(_g1._hx_index) {
				case 4:
					break _hx_loop1;
				case 14:case 15:
					token = parent.parent;
					break _hx_loop1;
				case 20:
					let _g2 = _g1.op;
					break _hx_loop1;
				default:
					token = parent;
					parent = parent.parent;
				}
				break;
			case 12:
				token = parent;
				break _hx_loop1;
			case 19:
				if(token.is(tokentree_TokenTreeDef.POpen)) {
					token = parent;
				}
				break _hx_loop1;
			case 13:case 21:
				break _hx_loop1;
			default:
				token = parent;
				parent = parent.parent;
			}
		}
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,token);
	}
	static walkOpAdd(stream,token) {
		let parent = token.parent;
		_hx_loop1: while(parent.tok != tokentree_TokenTreeDef.Root) {
			let _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:
					break _hx_loop1;
				case 3:case 5:case 10:case 24:case 28:
					break _hx_loop1;
				default:
					token = parent;
					parent = parent.parent;
				}
				break;
			case 6:
				let _g1 = _g.op;
				switch(_g1._hx_index) {
				case 0:case 3:
					token = parent.parent;
					break _hx_loop1;
				case 1:case 2:
					token = parent;
					parent = parent.parent;
					break;
				case 4:
					break _hx_loop1;
				case 20:
					let _g2 = _g1.op;
					break _hx_loop1;
				default:
					break _hx_loop1;
				}
				break;
			case 9:
				let _g3 = _g.s;
				break _hx_loop1;
			case 12:
				break _hx_loop1;
			case 15:case 17:
				break _hx_loop1;
			case 19:
				let pClose = tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.PClose);
				if(pClose == null) {
					token = parent;
					break _hx_loop1;
				}
				token = parent;
				parent = parent.parent;
				break;
			case 13:case 21:
				break _hx_loop1;
			default:
				token = parent;
				parent = parent.parent;
			}
		}
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,token);
	}
}
$hxClasses["tokentree.walk.WalkStatement"] = tokentree_walk_WalkStatement;
tokentree_walk_WalkStatement.__name__ = "tokentree.walk.WalkStatement";
class tokentree_walk_WalkSwitch {
	static walkSwitch(stream,parent) {
		let switchTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdSwitch));
		parent.addChild(switchTok);
		stream.applyTempStore(switchTok);
		tokentree_walk_WalkComment.walkComment(stream,switchTok);
		tokentree_walk_WalkStatement.walkStatement(stream,switchTok);
		tokentree_walk_WalkComment.walkComment(stream,switchTok);
		let _g = stream.token();
		if(_g._hx_index == 3) {
			let _g1 = _g.s;
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkSwitch.walkSwitchCases);
		}
		if(stream.is(tokentree_TokenTreeDef.BrOpen)) {
			let brOpen = stream.consumeTokenDef(tokentree_TokenTreeDef.BrOpen);
			switchTok.addChild(brOpen);
			tokentree_walk_WalkSwitch.walkSwitchCases(stream,brOpen);
			brOpen.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BrClose));
		}
	}
	static walkSwitchCases(stream,parent) {
		let progress = new tokentree_TokenStreamProgress(stream);
		_hx_loop1: while(progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 15:case 16:
					tokentree_walk_WalkSwitch.walkCase(stream,parent);
					break;
				default:
					tokentree_walk_WalkStatement.walkStatement(stream,parent);
				}
				break;
			case 3:
				let _g1 = _g.s;
				tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkSwitch.walkSwitchCases);
				break;
			case 7:
				let _g2 = _g.s;
				tokentree_walk_WalkComment.walkComment(stream,parent);
				break;
			case 8:
				let _g3 = _g.s;
				tokentree_walk_WalkComment.walkComment(stream,parent);
				break;
			case 18:
				break _hx_loop1;
			default:
				tokentree_walk_WalkStatement.walkStatement(stream,parent);
			}
		}
	}
	static walkCase(stream,parent) {
		tokentree_walk_WalkComment.walkComment(stream,parent);
		let caseTok = stream.consumeToken();
		parent.addChild(caseTok);
		tokentree_walk_WalkSwitch.walkCaseExpr(stream,caseTok);
		let dblDot = stream.consumeTokenDef(tokentree_TokenTreeDef.DblDot);
		caseTok.addChild(dblDot);
		let progress = new tokentree_TokenStreamProgress(stream);
		while(progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 15:case 16:
					return;
				default:
					tokentree_walk_WalkStatement.walkStatement(stream,dblDot);
				}
				break;
			case 3:
				let _g1 = _g.s;
				tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkSwitch.walkSwitchCases);
				tokentree_walk_WalkSwitch.relocateSharpTree(parent,dblDot);
				break;
			case 7:
				let _g2 = _g.s;
				let _g3 = stream.peekNonCommentToken();
				if(_g3 != null) {
					if(_g3._hx_index == 1) {
						switch(_g3.k._hx_index) {
						case 15:case 16:
							return;
						default:
						}
					}
				}
				tokentree_walk_WalkComment.walkComment(stream,dblDot);
				break;
			case 8:
				let _g4 = _g.s;
				let _g5 = stream.peekNonCommentToken();
				if(_g5 != null) {
					if(_g5._hx_index == 1) {
						switch(_g5.k._hx_index) {
						case 15:case 16:
							return;
						default:
						}
					}
				}
				tokentree_walk_WalkComment.walkComment(stream,dblDot);
				break;
			case 17:
				tokentree_walk_WalkBlock.walkBlock(stream,dblDot);
				break;
			case 18:
				return;
			default:
				tokentree_walk_WalkStatement.walkStatement(stream,dblDot);
			}
		}
	}
	static relocateSharpTree(parent,dblDot) {
		let sharp = parent.getLastChild();
		if(sharp.children.length < 2) {
			return;
		}
		let body = sharp.children[1];
		if(body.is(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdCase))) {
			return;
		}
		parent.children.pop();
		dblDot.addChild(sharp);
	}
	static walkCaseExpr(stream,parent) {
		let progress = new tokentree_TokenStreamProgress(stream);
		while(progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 1:
				if(_g.k._hx_index == 2) {
					let varTok = stream.consumeToken();
					parent.addChild(varTok);
					tokentree_walk_WalkStatement.walkStatement(stream,varTok);
				} else {
					tokentree_walk_WalkStatement.walkStatement(stream,parent);
				}
				break;
			case 14:
				let comma = stream.consumeToken();
				let child = parent.getLastChild();
				if(child == null) {
					child = parent;
				}
				child.addChild(comma);
				break;
			case 10:case 12:case 16:case 18:case 20:
				return;
			default:
				tokentree_walk_WalkStatement.walkStatement(stream,parent);
			}
		}
	}
}
$hxClasses["tokentree.walk.WalkSwitch"] = tokentree_walk_WalkSwitch;
tokentree_walk_WalkSwitch.__name__ = "tokentree.walk.WalkSwitch";
class tokentree_walk_WalkTry {
	static walkTry(stream,parent) {
		let tryTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdTry));
		parent.addChild(tryTok);
		stream.applyTempStore(tryTok);
		tokentree_walk_WalkBlock.walkBlock(stream,tryTok);
		let currentPos = stream.getStreamIndex();
		let progress = new tokentree_TokenStreamProgress(stream);
		let comments = [];
		while(stream.hasMore() && progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 1:
				if(_g.k._hx_index == 21) {
					let _g = 0;
					while(_g < comments.length) {
						let comment = comments[_g];
						++_g;
						tryTok.addChild(comment);
					}
					comments = [];
					tokentree_walk_WalkTry.walkCatch(stream,tryTok);
					currentPos = stream.getStreamIndex();
				} else {
					stream.rewindTo(currentPos);
					return;
				}
				break;
			case 7:
				let _g1 = _g.s;
				comments.push(stream.consumeToken());
				break;
			case 8:
				let _g2 = _g.s;
				comments.push(stream.consumeToken());
				break;
			default:
				stream.rewindTo(currentPos);
				return;
			}
		}
	}
	static walkCatch(stream,parent) {
		let catchTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdCatch));
		parent.addChild(catchTok);
		tokentree_walk_WalkPOpen.walkPOpen(stream,catchTok);
		tokentree_walk_WalkComment.walkComment(stream,catchTok);
		tokentree_walk_WalkBlock.walkBlock(stream,catchTok);
	}
}
$hxClasses["tokentree.walk.WalkTry"] = tokentree_walk_WalkTry;
tokentree_walk_WalkTry.__name__ = "tokentree.walk.WalkTry";
class tokentree_walk_WalkType {
	static walkType(stream,parent) {
		let _g = stream.token();
		if(_g._hx_index == 1) {
			switch(_g.k._hx_index) {
			case 1:
				tokentree_walk_WalkClass.walkClass(stream,parent);
				break;
			case 26:
				tokentree_walk_WalkEnum.walkEnum(stream,parent);
				break;
			case 27:
				tokentree_walk_WalkInterface.walkInterface(stream,parent);
				break;
			case 31:
				tokentree_walk_WalkTypedef.walkTypedef(stream,parent);
				break;
			case 39:
				tokentree_walk_WalkAbstract.walkAbstract(stream,parent);
				break;
			default:
			}
		}
	}
}
$hxClasses["tokentree.walk.WalkType"] = tokentree_walk_WalkType;
tokentree_walk_WalkType.__name__ = "tokentree.walk.WalkType";
class tokentree_walk_WalkTypeNameDef {
	static walkTypeNameDef(stream,parent) {
		tokentree_walk_WalkComment.walkComment(stream,parent);
		tokentree_walk_WalkAt.walkAts(stream);
		if(stream.is(tokentree_TokenTreeDef.Question)) {
			let questTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Question);
			parent.addChild(questTok);
			parent = questTok;
			tokentree_walk_WalkComment.walkComment(stream,parent);
		}
		let name;
		let bAdd = true;
		let _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 22:case 25:case 40:
				name = stream.consumeToken();
				break;
			default:
				name = stream.consumeToken();
			}
			break;
		case 2:
			let _g1 = _g.c;
			name = stream.consumeConst();
			break;
		case 3:
			let _g2 = _g.s;
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkStatement.walkStatement);
			if(!stream.hasMore()) {
				return parent.getFirstChild();
			}
			let _g3 = stream.token();
			if(_g3._hx_index == 2) {
				let _g = _g3.c;
				name = stream.consumeConst();
			} else {
				return parent.getFirstChild();
			}
			break;
		case 4:
			let _g4 = _g.s;
			name = stream.consumeToken();
			break;
		case 15:
			tokentree_walk_WalkArrayAccess.walkArrayAccess(stream,parent);
			return parent.getFirstChild();
		case 17:
			tokentree_walk_WalkTypedefBody.walkTypedefBody(stream,parent);
			return parent.getFirstChild();
		case 19:
			name = tokentree_walk_WalkPOpen.walkPOpen(stream,parent);
			if(stream.is(tokentree_TokenTreeDef.Question)) {
				tokentree_walk_WalkQuestion.walkQuestion(stream,name);
			}
			bAdd = false;
			break;
		default:
			name = stream.consumeToken();
		}
		stream.applyTempStore(name);
		if(bAdd) {
			parent.addChild(name);
		}
		tokentree_walk_WalkTypeNameDef.walkTypeNameDefContinue(stream,name);
		return name;
	}
	static walkTypeNameDefContinue(stream,parent) {
		tokentree_walk_WalkTypeNameDef.walkTypeNameDefComment(stream,parent);
		if(stream.is(tokentree_TokenTreeDef.Dot)) {
			let dot = stream.consumeTokenDef(tokentree_TokenTreeDef.Dot);
			parent.addChild(dot);
			tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,dot);
			return;
		}
		if(stream.is(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpLt))) {
			tokentree_walk_WalkLtGt.walkLtGt(stream,parent);
		}
		if(stream.is(tokentree_TokenTreeDef.Arrow)) {
			let arrow = stream.consumeTokenDef(tokentree_TokenTreeDef.Arrow);
			parent.addChild(arrow);
			tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,arrow);
			return;
		}
		if(stream.is(tokentree_TokenTreeDef.BkOpen)) {
			tokentree_walk_WalkArrayAccess.walkArrayAccess(stream,parent);
		}
		tokentree_walk_WalkTypeNameDef.walkTypeNameDefComment(stream,parent);
	}
	static walkTypeNameDefComment(stream,parent) {
		let currentPos = stream.getStreamIndex();
		let progress = new tokentree_TokenStreamProgress(stream);
		let comments = [];
		while(stream.hasMore() && progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 6:
				let _g1 = _g.op;
				let _g2 = 0;
				while(_g2 < comments.length) {
					let comment = comments[_g2];
					++_g2;
					parent.addChild(comment);
				}
				return;
			case 7:
				let _g3 = _g.s;
				comments.push(stream.consumeToken());
				break;
			case 8:
				let _g4 = _g.s;
				comments.push(stream.consumeToken());
				break;
			case 10:case 11:case 12:case 14:case 15:case 17:case 19:
				let _g5 = 0;
				while(_g5 < comments.length) {
					let comment = comments[_g5];
					++_g5;
					parent.addChild(comment);
				}
				return;
			default:
				stream.rewindTo(currentPos);
				return;
			}
		}
	}
}
$hxClasses["tokentree.walk.WalkTypeNameDef"] = tokentree_walk_WalkTypeNameDef;
tokentree_walk_WalkTypeNameDef.__name__ = "tokentree.walk.WalkTypeNameDef";
class tokentree_walk_WalkTypedef {
	static walkTypedef(stream,parent) {
		let typeTok = stream.consumeToken();
		parent.addChild(typeTok);
		let name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
		stream.applyTempStore(name);
		if(stream.is(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign))) {
			let assign = stream.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign));
			name.addChild(assign);
			name = assign;
		}
		tokentree_walk_WalkTypedefBody.walkTypedefBody(stream,name);
	}
}
$hxClasses["tokentree.walk.WalkTypedef"] = tokentree_walk_WalkTypedef;
tokentree_walk_WalkTypedef.__name__ = "tokentree.walk.WalkTypedef";
class tokentree_walk_WalkTypedefBody {
	static walkTypedefBody(stream,parent) {
		if(stream.is(tokentree_TokenTreeDef.BrOpen)) {
			let openTok = stream.consumeTokenDef(tokentree_TokenTreeDef.BrOpen);
			parent.addChild(openTok);
			tokentree_walk_WalkTypedefBody.walkTypedefCurlyBody(stream,openTok);
			openTok.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BrClose));
		} else {
			tokentree_walk_WalkTypedefBody.walkTypedefAlias(stream,parent);
		}
		if(stream.is(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAnd))) {
			let and = stream.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAnd));
			parent.getLastChild().addChild(and);
			tokentree_walk_WalkTypedefBody.walkTypedefBody(stream,parent);
		}
		if(stream.is(tokentree_TokenTreeDef.Arrow)) {
			tokentree_walk_WalkStatement.walkStatement(stream,parent);
		}
	}
	static walkTypedefCurlyBody(stream,openTok) {
		let progress = new tokentree_TokenStreamProgress(stream);
		_hx_loop1: while(progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:
					tokentree_walk_WalkFunction.walkFunction(stream,openTok);
					break;
				case 2:
					tokentree_walk_WalkVar.walkVar(stream,openTok);
					break;
				case 17:case 18:case 19:case 25:case 30:case 32:case 34:case 40:
					stream.consumeToTempStore();
					break;
				case 41:
					tokentree_walk_WalkFinal.walkFinal(stream,openTok);
					break;
				default:
					tokentree_walk_WalkFieldDef.walkFieldDef(stream,openTok);
				}
				break;
			case 2:
				let _g1 = _g.c;
				if(_g1._hx_index == 3) {
					if(_g1.s == "final") {
						tokentree_walk_WalkFinal.walkFinal(stream,openTok);
					} else {
						tokentree_walk_WalkFieldDef.walkFieldDef(stream,openTok);
					}
				} else {
					tokentree_walk_WalkFieldDef.walkFieldDef(stream,openTok);
				}
				break;
			case 3:
				let _g2 = _g.s;
				tokentree_walk_WalkSharp.walkSharp(stream,openTok,tokentree_walk_WalkTypedefBody.walkTypedefCurlyBody);
				break;
			case 6:
				if(_g.op._hx_index == 7) {
					tokentree_walk_WalkTypedefBody.walkStructureExtension(stream,openTok);
				} else {
					tokentree_walk_WalkFieldDef.walkFieldDef(stream,openTok);
				}
				break;
			case 7:
				let _g3 = _g.s;
				tokentree_walk_WalkComment.walkComment(stream,openTok);
				break;
			case 8:
				let _g4 = _g.s;
				tokentree_walk_WalkComment.walkComment(stream,openTok);
				break;
			case 18:
				break _hx_loop1;
			case 22:
				stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
				break;
			default:
				tokentree_walk_WalkFieldDef.walkFieldDef(stream,openTok);
			}
		}
		let tempStore = stream.getTempStore();
		if(tempStore.length > 0) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("invalid token tree structure - found:" + ("" + Std.string(tempStore)));
			case 1:
				stream.applyTempStore(openTok);
				break;
			}
		}
	}
	static walkTypedefAlias(stream,parent) {
		let newParent;
		if(stream.is(tokentree_TokenTreeDef.POpen)) {
			newParent = tokentree_walk_WalkPOpen.walkPOpen(stream,parent);
		} else {
			newParent = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,parent);
		}
		if(stream.is(tokentree_TokenTreeDef.Arrow)) {
			let arrowTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Arrow);
			newParent.addChild(arrowTok);
			tokentree_walk_WalkTypedefBody.walkTypedefAlias(stream,arrowTok);
		}
		if(stream.is(tokentree_TokenTreeDef.Semicolon)) {
			newParent.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.Semicolon));
		}
	}
	static walkStructureExtension(stream,parent) {
		let gt = stream.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt));
		parent.addChild(gt);
		let name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,parent);
		gt.addChild(name);
		if(stream.is(tokentree_TokenTreeDef.Comma)) {
			name.addChild(stream.consumeToken());
		}
	}
}
$hxClasses["tokentree.walk.WalkTypedefBody"] = tokentree_walk_WalkTypedefBody;
tokentree_walk_WalkTypedefBody.__name__ = "tokentree.walk.WalkTypedefBody";
class tokentree_walk_WalkVar {
	static walkVar(stream,parent) {
		let name = null;
		let varTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdVar));
		parent.addChild(varTok);
		tokentree_walk_WalkComment.walkComment(stream,parent);
		let progress = new tokentree_TokenStreamProgress(stream);
		while(progress.streamHasChanged()) {
			if(stream.is(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdVar))) {
				return;
			}
			tokentree_walk_WalkComment.walkComment(stream,parent);
			if(stream.token()._hx_index == 22) {
				tokentree_walk_WalkAt.walkAts(stream);
			}
			tokentree_walk_WalkComment.walkComment(stream,parent);
			let nameParent = varTok;
			if(stream.is(tokentree_TokenTreeDef.Question)) {
				nameParent = stream.consumeToken();
				varTok.addChild(nameParent);
			}
			name = stream.consumeConstIdent();
			nameParent.addChild(name);
			stream.applyTempStore(name);
			tokentree_walk_WalkComment.walkComment(stream,name);
			if(stream.is(tokentree_TokenTreeDef.POpen)) {
				tokentree_walk_WalkPOpen.walkPOpen(stream,name);
			}
			if(stream.is(tokentree_TokenTreeDef.DblDot)) {
				let dblDot = stream.consumeTokenDef(tokentree_TokenTreeDef.DblDot);
				name.addChild(dblDot);
				tokentree_walk_WalkTypedefBody.walkTypedefAlias(stream,dblDot);
			}
			if(stream.is(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign))) {
				tokentree_walk_WalkStatement.walkStatement(stream,name);
			}
			if(stream.is(tokentree_TokenTreeDef.Comma)) {
				let comma = stream.consumeTokenDef(tokentree_TokenTreeDef.Comma);
				name.addChild(comma);
				continue;
			}
			break;
		}
		if(stream.is(tokentree_TokenTreeDef.Semicolon)) {
			name.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.Semicolon));
		}
	}
}
$hxClasses["tokentree.walk.WalkVar"] = tokentree_walk_WalkVar;
tokentree_walk_WalkVar.__name__ = "tokentree.walk.WalkVar";
class tokentree_walk_WalkWhile {
	static walkWhile(stream,parent) {
		let whileTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdWhile));
		parent.addChild(whileTok);
		stream.applyTempStore(whileTok);
		tokentree_walk_WalkComment.walkComment(stream,whileTok);
		tokentree_walk_WalkStatement.walkStatement(stream,whileTok);
		tokentree_walk_WalkComment.walkComment(stream,whileTok);
		tokentree_walk_WalkBlock.walkBlock(stream,whileTok);
	}
}
$hxClasses["tokentree.walk.WalkWhile"] = tokentree_walk_WalkWhile;
tokentree_walk_WalkWhile.__name__ = "tokentree.walk.WalkWhile";
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
$hxClasses["Math"] = Math;
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.prototype.__class__ = $hxClasses["String"] = String;
String.__name__ = "String";
$hxClasses["Array"] = Array;
Array.__name__ = "Array";
var Int = { };
var Dynamic = { };
var Float = Number;
var Bool = Boolean;
var Class = { };
var Enum = { };
js_Boot.__toStr = ({ }).toString;
codesamples_SampleBase.DATA_FIELD_PATH = "field-path";
codesamples_CommonSamples.__meta__ = { obj : { sectionName : ["Common samples"]}, fields : { allman_curlies : { codeSampleName : ["allman.curlies"], keywords : [["allman","curlies","probably","most","searched","option","formatter","note","lineends","leftcurly","affects","left","there","specialised","options","different","curly","places","blockcurly","objectliteralcurly","haxeflixel","style","sample","codesamples","commonsamples","haxeflixel_style","both","emptycurly","break"]]}, haxeflixel_style : { codeSampleName : ["haxeflixel.style"], keywords : [["haxeflixel","style","formatter","configuration","used","lineends","leftcurly","both","rightcurly","objectliteralcurly","after","sameline","ifelse","next","dowhile","trybody","trycatch"]]}, indentation_with_space : { codeSampleName : ["indentation.with.space"], keywords : [["indentation","with","space","character","takes","string","that","either","number","literal","spaces","text","tabs"]]}}};
codesamples_EmptylinesSamples.__meta__ = { obj : { sectionName : ["Emptylines samples"]}, fields : { enum_abstract_emptylines : { codeSampleName : ["enum_abstract_emptylines"], keywords : [["enum_abstract_emptylines","emptylines","enumabstractemptylines","begintype","endtype","betweenvars","aftervars","betweenfunctions","existingbetweenfields","keep","maxanywhereinfile"]]}, import_and_using_emptylines : { codeSampleName : ["import.and.using.emptylines"], keywords : [["import","using","emptylines","showcases","different","empty","lines","settings","imports","goes","great","with","vscode","organise","code","action","importandusing","betweenimportslevel","firstlevelpackage","betweenimports","beforeusing","maxanywhereinfile"]]}}};
codesamples_IndentationSamples.__meta__ = { obj : { sectionName : ["Indentation samples"]}, fields : { trailing_whitespace : { codeSampleName : ["trailing.whitespace"], keywords : [["trailing","whitespace","adds","empty","lines","copying","indentation","from","previous","line","trailingwhitespace","true"]]}}};
codesamples_LineendsSamples.__meta__ = { obj : { sectionName : ["Lineends samples"]}};
codesamples_SamelineSamples.__meta__ = { obj : { sectionName : ["Sameline samples"]}, fields : { blockless_function_body : { codeSampleName : ["blockless.function.body"], keywords : [["blockless","function","body","keep","tries","linebreaks","from","input","source","sameline","functionbody","same","anonfunctionbody"]]}}};
codesamples_WhitespaceSamples.__meta__ = { obj : { sectionName : ["Whitespace samples"]}, fields : { colon_whitespace : { codeSampleName : ["colon.whitespace"], keywords : [["colon","whitespace","note","policies","overruled","code","parts","preceeding","following","location","because","these","might","have","that","contradict","their","neighbours","colonpolicy","none","casecolonpolicy","onlyafter","objectfieldcolonpolicy","after","typehintcolonpolicy","typecheckcolonpolicy","around","ternarypolicy"]]}, conditional_parens_detailed : { codeSampleName : ["conditional.parens.detailed"], keywords : [["conditional","parens","detailed","following","whitespace","settings","were","added","version","childs","parenconfig","catchparens","catch","expr","ifconditionparens","sharpconditionparens","switchconditionparens","switch","whileconditionparens","while","same","structure","conditionparens","short","codesamples","whitespacesamples","conditional_parens_short","allow","finer","control","over","each","location","default","null","which","means","applies","locations","also","only","have","values","those","where","want","formatter","behave","differently","note","using","removeinnerwhenempty","technically","possible","since","code","with","empty","condtion","expression","doesn","make","sense","probably","compile","there","much","openingpolicy","onlyafter","closingpolicy","before"]]}, conditional_parens_short : { codeSampleName : ["conditional.parens.short"], keywords : [["conditional","parens","short","whitespace","policies","parenconfig","well","bracesconfig","curly","braces","data","structure","that","three","fields","each","their","locations","openingpolicy","policy","opening","closingpolicy","closing","removeinnerwhenempty","true","when","want","remove","inner","curlies","empty","following","element","being","either","none","before","after","nonebefore","never","onlybefore","only","noneafter","onlyafter","around","note","overruled","code","parts","preceeding","location","because","these","might","have","contradict","neighbours","conditionparens"]]}, function_parens : { codeSampleName : ["function.parens"], keywords : [["function","parens","conditional","short","codesamples","whitespacesamples","conditional_parens_short","details","about","structure","values","note","whitespace","policies","overruled","code","parts","preceeding","following","location","because","these","might","have","that","contradict","their","neighbours","parenconfig","funcparamparens","openingpolicy","before","closingpolicy","none","removeinnerwhenempty","true","anonfuncparamparens","onlyafter"]]}, function_types_and_arrows : { codeSampleName : ["function.types.and.arrows"], keywords : [["function","types","arrows","note","whitespace","policies","overruled","code","parts","preceeding","following","location","because","these","might","have","that","contradict","their","neighbours","arrowfunctionspolicy","around","functiontypehaxe3policy","none","functiontypehaxe4policy"]]}, type_parameter : { codeSampleName : ["type.parameter"], keywords : [["type","parameter","conditional","parens","short","codesamples","whitespacesamples","conditional_parens_short","details","about","values","note","whitespace","policies","overruled","code","parts","preceeding","following","location","because","these","might","have","that","contradict","their","neighbours","typeparamopenpolicy","after","typeparamclosepolicy","before"]]}}};
codesamples_WrappingSamples.__meta__ = { obj : { sectionName : ["Wrapping samples"]}, fields : { array_matrix_wrapping : { codeSampleName : ["array.matrix.wrapping"], keywords : [["array","matrix","wrapping","arrays","layout","only","works","that","have","equal","number","elements","line","your","input","source","code","should","already","shape","note","equalnumber","implemented","arraymatrixwrap","matrixwrapwithalign","arraywrap","defaultwrap","fillline","defaultlocation","afterlast","maxlinelength"]]}, case_pattern_wrapping : { codeSampleName : ["case.pattern.wrapping"], keywords : [["case","pattern","wrapping","large","amounts","patterns","note","equalnumber","implemented","casepattern","defaultwrap","fillline","defaultlocation","beforelast","maxlinelength"]]}, method_chain_wrapping : { codeSampleName : ["method.chain.wrapping"], keywords : [["method","chain","wrapping","chains","calls","note","equalnumber","implemented","methodchain","defaultwrap","oneperline","defaultlocation","afterlast","rules","maxlinelength"]]}, operator_add_chain_wrapping : { codeSampleName : ["operator.add.chain.wrapping"], keywords : [["operator","chain","wrapping","chains","note","equalnumber","implemented","opaddsubchain","defaultwrap","fillline","defaultlocation","beforelast","rules","maxlinelength"]]}}};
doc_Docs.__meta__ = { obj : { sectionName : ["Documentation"]}, fields : { compile_dev_version : { docName : ["compile.dev.version"], keywords : [["compile","version","command","line","haxe","clone","https","github","haxecheckstyle","formatter","install","download","buildall","hxml","neko","nodejs","java","json","schema","buildcpp","haxe_libraries","haxe4_libraries","haxe3_libraries","language","server","vshaxe","languageserver","tokentree","build","target","vscode","extensions","nadako","vshaxe_version","replace","with","actual","assuming","have","installed","restart","note","will","whenever","there","marketplace","release","since","wipe","your","folder"]]}}};
formatter_FormatStats.totalLinesOrig = 0;
formatter_FormatStats.totalLinesFormatted = 0;
hxparse_LexEngine.EMPTY = [];
hxparse_LexEngine.ALL_CHARS = [new hxparse__$LexEngine_CharRange(0,255)];
haxeparser_HaxeLexer.keywords = (function($this) {
	var $r;
	let _g = new haxe_ds_StringMap();
	_g.h["abstract"] = haxeparser_Keyword.KwdAbstract;
	_g.h["break"] = haxeparser_Keyword.KwdBreak;
	_g.h["case"] = haxeparser_Keyword.KwdCase;
	_g.h["cast"] = haxeparser_Keyword.KwdCast;
	_g.h["catch"] = haxeparser_Keyword.KwdCatch;
	_g.h["class"] = haxeparser_Keyword.KwdClass;
	_g.h["continue"] = haxeparser_Keyword.KwdContinue;
	_g.h["default"] = haxeparser_Keyword.KwdDefault;
	_g.h["do"] = haxeparser_Keyword.KwdDo;
	_g.h["dynamic"] = haxeparser_Keyword.KwdDynamic;
	_g.h["else"] = haxeparser_Keyword.KwdElse;
	_g.h["enum"] = haxeparser_Keyword.KwdEnum;
	_g.h["extends"] = haxeparser_Keyword.KwdExtends;
	_g.h["extern"] = haxeparser_Keyword.KwdExtern;
	_g.h["false"] = haxeparser_Keyword.KwdFalse;
	_g.h["final"] = haxeparser_Keyword.KwdFinal;
	_g.h["for"] = haxeparser_Keyword.KwdFor;
	_g.h["function"] = haxeparser_Keyword.KwdFunction;
	_g.h["if"] = haxeparser_Keyword.KwdIf;
	_g.h["implements"] = haxeparser_Keyword.KwdImplements;
	_g.h["import"] = haxeparser_Keyword.KwdImport;
	_g.h["inline"] = haxeparser_Keyword.KwdInline;
	_g.h["interface"] = haxeparser_Keyword.KwdInterface;
	_g.h["macro"] = haxeparser_Keyword.KwdMacro;
	_g.h["new"] = haxeparser_Keyword.KwdNew;
	_g.h["null"] = haxeparser_Keyword.KwdNull;
	_g.h["override"] = haxeparser_Keyword.KwdOverride;
	_g.h["package"] = haxeparser_Keyword.KwdPackage;
	_g.h["private"] = haxeparser_Keyword.KwdPrivate;
	_g.h["public"] = haxeparser_Keyword.KwdPublic;
	_g.h["return"] = haxeparser_Keyword.KwdReturn;
	_g.h["static"] = haxeparser_Keyword.KwdStatic;
	_g.h["switch"] = haxeparser_Keyword.KwdSwitch;
	_g.h["this"] = haxeparser_Keyword.KwdThis;
	_g.h["throw"] = haxeparser_Keyword.KwdThrow;
	_g.h["true"] = haxeparser_Keyword.KwdTrue;
	_g.h["try"] = haxeparser_Keyword.KwdTry;
	_g.h["typedef"] = haxeparser_Keyword.KwdTypedef;
	_g.h["untyped"] = haxeparser_Keyword.KwdUntyped;
	_g.h["using"] = haxeparser_Keyword.KwdUsing;
	_g.h["var"] = haxeparser_Keyword.KwdVar;
	_g.h["while"] = haxeparser_Keyword.KwdWhile;
	$r = _g;
	return $r;
}(this));
haxeparser_HaxeLexer.buf = new StringBuf();
haxeparser_HaxeLexer.tok = hxparse_Lexer.buildRuleset([{ rule : "", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Eof);
}},{ rule : "[\r\n\t ]+", func : function(lexer) {
	return lexer.token(haxeparser_HaxeLexer.tok);
}},{ rule : "0x[0-9a-fA-F]+", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CInt(lexer.current)));
}},{ rule : "([1-9][0-9]*)|0", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CInt(lexer.current)));
}},{ rule : "(([1-9][0-9]*)|0)(\\.[0-9]+)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CFloat(lexer.current)));
}},{ rule : "\\.[0-9]+", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CFloat(lexer.current)));
}},{ rule : "(([1-9][0-9]*)|0)([eE][\\+\\-]?[0-9]+)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CFloat(lexer.current)));
}},{ rule : "(([1-9][0-9]*)|0)(\\.[0-9]*[eE][\\+\\-]?[0-9]+)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CFloat(lexer.current)));
}},{ rule : "(([1-9][0-9]*)|0)(\\.\\.\\.)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.IntInterval(HxOverrides.substr(lexer.current,0,-3)));
}},{ rule : "//[^\n\r]*", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.CommentLine(HxOverrides.substr(lexer.current,2,null)));
}},{ rule : "+\\+", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Unop(haxe_macro_Unop.OpIncrement));
}},{ rule : "--", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Unop(haxe_macro_Unop.OpDecrement));
}},{ rule : "~", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Unop(haxe_macro_Unop.OpNegBits));
}},{ rule : "%=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpMod)));
}},{ rule : "&=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpAnd)));
}},{ rule : "|=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpOr)));
}},{ rule : "^=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpXor)));
}},{ rule : "+=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpAdd)));
}},{ rule : "-=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpSub)));
}},{ rule : "*=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpMult)));
}},{ rule : "/=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpDiv)));
}},{ rule : "<<=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpShl)));
}},{ rule : "==", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpEq));
}},{ rule : "!=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpNotEq));
}},{ rule : "<=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpLte));
}},{ rule : "&&", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpBoolAnd));
}},{ rule : "|\\|", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpBoolOr));
}},{ rule : "<<", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpShl));
}},{ rule : "->", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Arrow);
}},{ rule : "\\.\\.\\.", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpInterval));
}},{ rule : "=>", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpArrow));
}},{ rule : "!", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Unop(haxe_macro_Unop.OpNot));
}},{ rule : "<", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpLt));
}},{ rule : ">", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpGt));
}},{ rule : ";", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Semicolon);
}},{ rule : ":", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.DblDot);
}},{ rule : ",", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Comma);
}},{ rule : "\\.", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Dot);
}},{ rule : "%", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpMod));
}},{ rule : "&", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAnd));
}},{ rule : "|", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpOr));
}},{ rule : "^", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpXor));
}},{ rule : "+", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAdd));
}},{ rule : "*", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpMult));
}},{ rule : "/", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpDiv));
}},{ rule : "-", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpSub));
}},{ rule : "=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssign));
}},{ rule : "in", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpIn));
}},{ rule : "[", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.BkOpen);
}},{ rule : "]", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.BkClose);
}},{ rule : "{", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.BrOpen);
}},{ rule : "}", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.BrClose);
}},{ rule : "\\(", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.POpen);
}},{ rule : "\\)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.PClose);
}},{ rule : "?", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Question);
}},{ rule : "@", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.At);
}},{ rule : "\"", func : function(lexer) {
	haxeparser_HaxeLexer.buf = new StringBuf();
	let pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	let pmax;
	try {
		pmax = lexer.token(haxeparser_HaxeLexer.string);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedString,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	let token = haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CString(haxeparser_HaxeLexer.unescape(haxeparser_HaxeLexer.buf.b,haxeparser_HaxeLexer.mkPos(pmin)))));
	token.pos.min = pmin.pmin;
	return token;
}},{ rule : "'", func : function(lexer) {
	haxeparser_HaxeLexer.buf = new StringBuf();
	let pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	let pmax;
	try {
		pmax = lexer.token(haxeparser_HaxeLexer.string2);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedString,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	let token = haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CString(haxeparser_HaxeLexer.unescape(haxeparser_HaxeLexer.buf.b,haxeparser_HaxeLexer.mkPos(pmin)))));
	token.pos.min = pmin.pmin;
	return token;
}},{ rule : "~/", func : function(lexer) {
	haxeparser_HaxeLexer.buf = new StringBuf();
	let pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	let info;
	try {
		info = lexer.token(haxeparser_HaxeLexer.regexp);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedRegExp,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	let token = haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CRegexp(haxeparser_HaxeLexer.buf.b,info.opt)));
	token.pos.min = pmin.pmin;
	return token;
}},{ rule : "/\\*", func : function(lexer) {
	haxeparser_HaxeLexer.buf = new StringBuf();
	let pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	let pmax;
	try {
		pmax = lexer.token(haxeparser_HaxeLexer.comment);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnclosedComment,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	let token = haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Comment(haxeparser_HaxeLexer.buf.b));
	token.pos.min = pmin.pmin;
	return token;
}},{ rule : "(#)(_*[a-z][a-zA-Z0-9_]*|_+|_+[0-9][_a-zA-Z0-9]*)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Sharp(HxOverrides.substr(lexer.current,1,null)));
}},{ rule : "$[_a-zA-Z0-9]*", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Dollar(HxOverrides.substr(lexer.current,1,null)));
}},{ rule : "_*[a-z][a-zA-Z0-9_]*|_+|_+[0-9][_a-zA-Z0-9]*", func : function(lexer) {
	let kwd = haxeparser_HaxeLexer.keywords.h[lexer.current];
	if(kwd != null) {
		return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Kwd(kwd));
	} else {
		return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CIdent(lexer.current)));
	}
}},{ rule : "_*[A-Z][a-zA-Z0-9_]*", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CIdent(lexer.current)));
}}],"tok");
haxeparser_HaxeLexer.string = hxparse_Lexer.buildRuleset([{ rule : "\\\\\\\\", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\\\\";
	return lexer.token(haxeparser_HaxeLexer.string);
}},{ rule : "\\\\", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\\";
	return lexer.token(haxeparser_HaxeLexer.string);
}},{ rule : "\\\\\"", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\"";
	return lexer.token(haxeparser_HaxeLexer.string);
}},{ rule : "\"", func : function(lexer) {
	return new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos).pmax;
}},{ rule : "[^\\\\\"]+", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	return lexer.token(haxeparser_HaxeLexer.string);
}}],"string");
haxeparser_HaxeLexer.string2 = hxparse_Lexer.buildRuleset([{ rule : "\\\\\\\\", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\\\\";
	return lexer.token(haxeparser_HaxeLexer.string2);
}},{ rule : "\\\\", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\\";
	return lexer.token(haxeparser_HaxeLexer.string2);
}},{ rule : "\\\\'", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "'";
	return lexer.token(haxeparser_HaxeLexer.string2);
}},{ rule : "'", func : function(lexer) {
	return new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos).pmax;
}},{ rule : "($$)|(\\$)|$", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "$";
	return lexer.token(haxeparser_HaxeLexer.string2);
}},{ rule : "${", func : function(lexer) {
	let pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	try {
		lexer.token(haxeparser_HaxeLexer.codeString);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnclosedCode,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	return lexer.token(haxeparser_HaxeLexer.string2);
}},{ rule : "[^$\\\\']+", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	return lexer.token(haxeparser_HaxeLexer.string2);
}}],"string2");
haxeparser_HaxeLexer.codeString = hxparse_Lexer.buildRuleset([{ rule : "{|/", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	lexer.token(haxeparser_HaxeLexer.codeString);
}},{ rule : "}", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
}},{ rule : "\"", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += String.fromCodePoint(34);
	let pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	try {
		lexer.token(haxeparser_HaxeLexer.string);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedString,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	haxeparser_HaxeLexer.buf.b += String.fromCodePoint(34);
	lexer.token(haxeparser_HaxeLexer.codeString);
}},{ rule : "'", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += String.fromCodePoint(39);
	let pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	try {
		lexer.token(haxeparser_HaxeLexer.string2);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedString,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	haxeparser_HaxeLexer.buf.b += String.fromCodePoint(39);
	lexer.token(haxeparser_HaxeLexer.codeString);
}},{ rule : "/\\*", func : function(lexer) {
	let pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	try {
		lexer.token(haxeparser_HaxeLexer.comment);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnclosedComment,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	lexer.token(haxeparser_HaxeLexer.codeString);
}},{ rule : "//[^\n\r]*", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	lexer.token(haxeparser_HaxeLexer.codeString);
}},{ rule : "[^/\"'{}\n\r]+", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	lexer.token(haxeparser_HaxeLexer.codeString);
}},{ rule : "[\r\n\t ]+", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	lexer.token(haxeparser_HaxeLexer.codeString);
}}],"codeString");
haxeparser_HaxeLexer.comment = hxparse_Lexer.buildRuleset([{ rule : "*/", func : function(lexer) {
	return new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos).pmax;
}},{ rule : "*", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "*";
	return lexer.token(haxeparser_HaxeLexer.comment);
}},{ rule : "[^\\*]+", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	return lexer.token(haxeparser_HaxeLexer.comment);
}}],"comment");
haxeparser_HaxeLexer.regexp = hxparse_Lexer.buildRuleset([{ rule : "\\\\/", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "/";
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\\\r", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\r";
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\\\n", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\n";
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\\\t", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\t";
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\\\[\\\\$\\.*+\\^|{}\\[\\]()?\\-0-9]", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\\\[wWbBsSdDx]", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "/", func : function(lexer) {
	return lexer.token(haxeparser_HaxeLexer.regexp_options);
}},{ rule : "[^\\\\/\r\n]+", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	return lexer.token(haxeparser_HaxeLexer.regexp);
}}],"regexp");
haxeparser_HaxeLexer.regexp_options = hxparse_Lexer.buildRuleset([{ rule : "[gimsu]*", func : function(lexer) {
	return { pmax : new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos).pmax, opt : lexer.current};
}}],"regexp_options");
markdown_BlockSyntax.RE_EMPTY = new EReg("^([ \\t]*)$","");
markdown_BlockSyntax.RE_SETEXT = new EReg("^((=+)|(-+))$","");
markdown_BlockSyntax.RE_HEADER = new EReg("^(#{1,6})(.*?)( +#* *)?$","");
markdown_BlockSyntax.RE_BLOCKQUOTE = new EReg("^[ ]{0,3}>[ ]?(.*)$","");
markdown_BlockSyntax.RE_INDENT = new EReg("^(?:    |\t)(.*)$","");
markdown_BlockSyntax.RE_CODE = new EReg("^```(\\w*)\\s*$","");
markdown_BlockSyntax.RE_HR = new EReg("^[ ]{0,3}((-+[ ]{0,2}){3,}|(_+[ ]{0,2}){3,}|(\\*+[ ]{0,2}){3,})$","");
markdown_BlockSyntax.RE_HTML = new EReg("^<[ ]*\\w+[ >]","");
markdown_BlockSyntax.RE_UL = new EReg("^[ ]{0,3}[*+-][ \\t]+(.*)$","");
markdown_BlockSyntax.RE_OL = new EReg("^[ ]{0,3}\\d+\\.[ \\t]+(.*)$","");
markdown_TableSyntax.TABLE_PATTERN = new EReg("^(.+?:?\\|:?)+(.+)$","");
markdown_TableSyntax.CELL_PATTERN = new EReg("(\\|)?([^\\|]+)(\\|)?","g");
markdown_HtmlRenderer.BLOCK_TAGS = new EReg("blockquote|h1|h2|h3|h4|h5|h6|hr|p|pre","");
markdown_HtmlRenderer.attributeOrder = ["src","alt"];
markdown_LinkSyntax.linkPattern = "\\](?:(" + "\\s?\\[([^\\]]*)\\]" + "|" + "\\s?\\(([^ )]+)(?:[ ]*\"([^\"]+)\"|)\\)" + ")|)";
markdown_ImgSyntax.linkPattern = "\\](?:(" + "\\s?\\[([^\\]]*)\\]" + "|" + "\\s?\\(([^ )]+)(?:[ ]*\"([^\"]+)\"|)\\)" + ")|)";
markdown_InlineParser.defaultSyntaxes = [new markdown_AutolinkSyntaxWithoutBrackets(),new markdown_TextSyntax(" {2,}\n","<br />\n"),new markdown_TextSyntax("\\s*[A-Za-z0-9]+"),new markdown_AutolinkSyntax(),new markdown_LinkSyntax(),new markdown_ImgSyntax(),new markdown_TextSyntax(" \\* "),new markdown_TextSyntax(" _ "),new markdown_TextSyntax("&[#a-zA-Z0-9]*;"),new markdown_TextSyntax("&","&amp;"),new markdown_TextSyntax("<(?:!--[ ]*|/)?\\w+.*?>"),new markdown_TextSyntax("<","&lt;"),new markdown_TagSyntax("\\*\\*","strong"),new markdown_TagSyntax("__","strong"),new markdown_TagSyntax("\\*","em"),new markdown_TagSyntax("\\b_","em","_\\b"),new markdown_CodeSyntax("``\\s?((?:.|\\n)*?)\\s?``"),new markdown_CodeSyntax("`([^`]*)`")];
tokentree_TokenStream.MODE = tokentree_TokenStreamMode.Strict;
Main.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
